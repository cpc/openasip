#!/usr/bin/env python
# -*- coding: utf-8 -*-
# 
# Copyright (c) 2002-2011 Tampere University of Technology.
#
# This file is part of TTA-Based Codesign Environment (TCE).
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
# @author 2006-2009 Veli-Pekka Jääskeläinen
# @author 2006-2011 Pekka Jääskeläinen
#
# High-level language compiler driver for TCE.
#

import os, sys, commands, optparse, shutil, glob, signal
import os.path
import re

from tempfile import mkdtemp, mkstemp
from optparse import OptionParser
from shutil import rmtree
from subprocess import Popen, PIPE

def runCommandBuffered(command, echoOutput):
    """Runs a command and prints everything if requested."""

    if echoOutput:
        print command

    (exitCode, output) = commands.getstatusoutput(command)

    if echoOutput:
        print output

    return (exitCode, output)

# global variables...
debugMode = False
options = None
newlib_libdir = ""
newlib_includes = ""
lowerintrinsicsplugin=""

def handler(signum, frame):
    cleanup(tempDir)
    sys.exit(2)

def cleanup(tmpDir):
    """Removes temporary files created during build."""
    if not options.leave_dirty:
        rmtree(tmpDir, ignore_errors=True)
    else:
        sys.stdout.write("Intermediate files left in build dir " +\
                         tmpDir + "\n")

def tryRemove(filename):
    """Tries to remove a file."""
    try:
        os.remove(filename)
    except:
        pass

def runCommand(command, echoOutput=True, echoStderr=False, stdoutFD=None):
    """Runs the given shell command and returns its exit code.

    If echoOutput is False, stdout and stderr are redirected to /dev/null."""
       
    if echoOutput:
        print command
        stderrFD = None
    else:
        if stdoutFD is None:
            stdoutRedir = open('/dev/null', 'w')
            stdoutFD = stdoutRedir.fileno()
        if not echoStderr:
            stderrRedir = open('/dev/null', 'w')
            stderrFD = stderrRedir.fileno()
        else:
            stderrFD = None

    process = \
       Popen(command, shell=True, stdin=PIPE, stdout=stdoutFD,
             stderr=stderrFD, close_fds=False)
    return process.wait()
    

# TODO: add support for ll and check if file is .bc object from magic number...
def processInputFiles(inFiles, tmpDir, verbose):
    
    """ Compiles input files to .bc files and returns list
    cotaining all the files to link together.
    """

    compileFlags = newlib_includes + " " + bclib_includes + " "

    if options.compile_only and not options.use_clang:
        compileFlags += "-c "

    if options.g_cc_switch:
        compileFlags += "-g "

    for i in options.defines:
        compileFlags += "-D" + i + " "

    for i in options.include_dirs:
        compileFlags += "-I" + i + " "

    compileFlags += "-include " + tmpDir + "/tceops.h "

    for w in options.warnings:
        # Types of warnings supported by the compiler:
        white_list = []
        if options.use_clang:
            white_list = ['no-unknown-warning-option',
                          'no-bad-literal',
                          'no-literal-range',
                          'no-pointer-sign',
                          'no-return-type', 
                          'no-unused-value',
                          'no-implicit-function-declaration']
        if w in white_list:
            compileFlags += "-W" + w + " "

    if not options.use_clang: # Clang 1.0 does not support -B
        for i in options.B_cc_switches:
            compileFlags += "-B" + i + " "
        
    for i in options.f_cc_switches:
        if options.use_clang:
            # Some of the gcc -f flags not supported by clang,
            # just skip them silently for now for gcc compatibility.
            if i == "short-enums": continue
        compileFlags += "-f" + i + " "

    for i in options.isystem_cc_switches:
        compileFlags += "-isystem" + i + " "

    # list of valid suffixes
    knownSuffices = [".cpp", ".cc", ".c", ".ll", ".bc", ".o", ".a"]
    if @OPENCL_ENABLED@:
        knownSuffices.append(".cl")

    linkList = []

    # Compile input files if needed
    if len(inFiles) == 0:
        exitWithError(
            1, 
            "There must be at least one .bc, .c, .cc or .cpp file given.\n")
    else: 
        for fName in inFiles:
            # check file type based on knownSuffices
            baseName = ""
            suffix = ""
            temp_file = None
            # The OpenCL C device specific header file that is
            # generated from the ADF.
            device_header = None
            for i in range(len(knownSuffices)):
                testSuffix = knownSuffices[i]
                suffixStart = fName.rfind(testSuffix)

                if suffixStart != -1:
                    suffix = fName[suffixStart:len(fName)]
                    baseName = fName[0:suffixStart]

                    if suffix == testSuffix:
                        break
                    else:
                        baseName = ""
                        suffix = ""
            
            if baseName != "" and suffix != "":
                # gen command for compiling, for files that need to
                # be compiled first
                command = ""
                
                extra_opts = ""
                if options.language != "":
                    extra_opts += "-x %s " % options.language

                # After compilation all malloc instructions are lowered
                # to function calls... if malloc function
                # is implemented as a instruction in llvm assembler,
                # it won't be linked to final binary from libc.a
                # (ld knows how to select only needed parts from libc.a,
                # even thoug it does it very badly, it shortens optimize time)

                outFileName = tmpDir + "/" + os.path.basename(baseName) + ".o"
                if suffix == ".c":
                    if options.use_clang:
                        command =  ("clang -O%d -ccc-host-triple tce-tut-llvm -emit-llvm -c "\
                                       "-I" + tmpDir +\
                                       " " + compileFlags + baseName + suffix + " -o " +\
                                       outFileName + ".tobelowered;" ) % \
                                       options.frontend_optlevel
                    else:
                        command = ("tce-llvm-gcc --emit-llvm -O%d -ffreestanding "\
                                       "-fno-unit-at-a-time -fno-inline -c -I" + tmpDir +\
                                       " " + compileFlags + baseName + suffix + " -o " +\
                                       outFileName + ".tobelowered;") % \
                                       options.frontend_optlevel

                    command += lowerMemIntrinsicCommand(outFileName + ".tobelowered", outFileName)
                    
                elif suffix == ".cl":

                    if options.adf_file == "":
                        exitWithError(1, "ADF file required when compiling OpenCL kernels.")

                    input_file = baseName + suffix
                    oclextgen = os.path.join(tceOclExtGenDir, "tceoclextgen") + " "  + options.adf_file

                    # Generate the ADF specific header file with extension 
                    # functions for (custom) operations etc.
                    device_header = mkstemp("_oclext.h", dir=tempDir)

                    exitCode = runCommand(oclextgen, verbose, echoStderr=True, stdoutFD=device_header[0]) 

                    if exitCode != 0:
                        os.unlink(device_header[1])
                        exitWithError(
                            1, 
                            "Error while generating the OpenCL C device header.\n")

                    # Generate the parallelized bitcode, the trampoline and the kernel 
                    # registration object.
                    cpp_trampoline = mkstemp("_ocl_launcher.cpp", dir=tempDir)[1]
                    kernel_bc = mkstemp("_kernel.o", dir=tempDir)[1]

                    runCommand(('EXTRA_CLANG_FLAGS="-D__TCE_DEVICE__ -ccc-host-triple tce-tut-llvm -fasm -include %s" ' % device_header[1]) + \
                               "pocl-standalone -t tce -h %s -o %s %s" % \
                               (cpp_trampoline, kernel_bc, input_file), verbose, 
                               echoStderr=True)
                    if exitCode != 0:
                        exitWithError(
                            1, "Error while compiling the OpenCL C file %s.\n" % input_file)

                    def compile(input, output):
                        command = ("clang -ccc-host-triple tce-tut-llvm " + \
                                       "-emit-llvm -O3 "\
                                       "-fno-inline -c -I" + tmpDir +\
                                       " " + input + \
                                       " %s `pkg-config pocl --cflags`" + \
                                       " -o " + output) % \
                                       ("-I " + tceSAOpenCLIncDir + " "  + newlib_includes)
# + " -I" + poclDir + "/lib" + " -I" + poclDir
                        exitCode = runCommand(command, verbose, echoStderr=True) 
                        if exitCode != 0:
                            exitWithError(1, "Error while compiling %s." % input)

                    # append the trampoline functions and the registration object
                    # after the kernel information macros generated by the
                    # pocl-standalone script

                    class OpenCLKernelInfo(object):
                        def __init__(self, name, arg_count):
                            self.name = name
                            self.arg_count = int(arg_count)

                    kernels = []
                    # figure out the kernel names from the generated header file
                    tfr = open(cpp_trampoline, 'r')
                    for line in tfr.readlines():
                        m = re.search(r'#define\s_(\S+)_NUM_ARGS\s(\d+)', line)
                        if m is not None:
                            kernels.append(OpenCLKernelInfo(m.group(1), m.group(2)))
                    tfr.close()                                           

                    tf = open(cpp_trampoline, 'a')
                    tf.write(\
"""
#define min(a,b) (((a) < (b)) ? (a) : (b))

#include <stdlib.h>
#include <stdio.h>
#include "cl_tce.h"
#include <pocl/pocl.h>

#ifdef __TCE__

extern "C" int _get_core_count();

/* The maximum number of work groups to execute in parallel threads. */
#define _MAX_WG_THREADS _get_core_count()

#else

#define _MAX_WG_THREADS 2

#endif

#define USE_MT 0
//#define DEBUG_MT
//#define DEBUG_OCL

#if USE_MT == 1
#include <pthread.h>
#endif

/* The arguments and context data passed to a work group function. */
struct _ocl_args {
    void** args;
    int work_dim;
    const size_t* local_work_size;
    const size_t* global_work_size;
    int first_gid_x;
    int last_gid_x;
};

/* this function should be called to register the kernel to the Host API's kernel
   registry */
extern "C" void _register_opencl_kernel(struct _OpenCLKernel* kernel);

""")

                    trampoline_func_template = \
"""
extern "C" void %(converted_name)s(void** args, pocl_context*);

static void __opencl_trampoline_%(kernel_name)s(
    void** args, 
    int work_dim, 
    const size_t* local_work_size, 
    const size_t* global_work_size,
    int first_gidx, int last_gidx) {

    const int local_size_x = local_work_size[0];
    const int local_size_y = (work_dim >= 2) ? local_work_size[1] : 1;
    const int local_size_z = (work_dim == 3) ? local_work_size[2] : 1;

    const int global_size_x = global_work_size[0];
    const int global_size_y = (work_dim >= 2) ? global_work_size[1] : 1;
    const int global_size_z = (work_dim == 3) ? global_work_size[2] : 1;

    const int num_groups_x = global_size_x / local_size_x;
    const int num_groups_y = (work_dim >= 2) ? (global_size_y / local_size_y) : 1;
    const int num_groups_z = (work_dim == 3) ? (global_size_z / local_size_z) : 1;

    for (unsigned gid_x = first_gidx; gid_x <= last_gidx; gid_x++) { 
        for (unsigned gid_y = 0; gid_y < num_groups_y; gid_y++) { 
            for (unsigned gid_z = 0; gid_z < num_groups_z; gid_z++) {
                pocl_context context;
                context.work_dim = work_dim;
                context.num_groups[0] = num_groups_x;
                context.num_groups[1] = num_groups_y;
                context.num_groups[2] = num_groups_z;
                context.group_id[0] = gid_x;
                context.group_id[1] = gid_y;
                context.group_id[2] = gid_z;
                context.global_offset[0] = 0;
                context.global_offset[1] = 0;
                context.global_offset[2] = 0;
#ifdef DEBUG_OCL
                iprintf("### launching a WG %%d-%%d-%%d of %%d-%%d-%%d\\n", 
                        gid_x, gid_y, gid_z, num_groups_x, num_groups_y, num_groups_z);
#endif
                %(converted_name)s(args, &context);
            } 
        }
    }
}

static void* __opencl_wg_thread_%(kernel_name)s(void* arg_struct) {
    _ocl_args* args = (_ocl_args*)arg_struct;
    __opencl_trampoline_%(kernel_name)s(
        args->args, args->work_dim, 
        args->local_work_size, args->global_work_size, 
        args->first_gid_x, args->last_gid_x);
    return 0;
}

void __opencl_trampoline_mt_%(kernel_name)s(
    void** args, 
    size_t* sizes,
    int work_dim, 
    const size_t* local_work_size, 
    const size_t* global_work_size) {
    int num_groups_x = global_work_size[0] / local_work_size[0];
    int i, first_gid_x, last_gid_x;

    if (USE_MT && _MAX_WG_THREADS > 1) {
#if USE_MT == 1
        int num_threads = min(_MAX_WG_THREADS, num_groups_x);
        int wgs_per_thread = num_groups_x / num_threads;
        /* In case the work group count is not divisible by the
           number of threads, we have to execute some additional
           workgroups in the last thread. */
        int leftover_wgs = num_groups_x - (num_threads*wgs_per_thread);
        pthread_t* threads = (pthread_t*)malloc(sizeof(pthread_t)*num_threads);
        _ocl_args* arguments = (_ocl_args*)malloc(sizeof(_ocl_args)*num_threads);

#ifdef DEBUG_MT    
    iprintf("### global_work_size[0]==%%d local_work_size[0]==%%d\\n", 
             global_work_size[0], local_work_size[0]);
    iprintf("### creating %%d work group threads\\n", num_threads);
    iprintf("### wgs per thread==%%d leftover wgs==%%d\\n", wgs_per_thread, leftover_wgs);
#endif
    
        for (i = 0, first_gid_x = 0, last_gid_x = wgs_per_thread - 1; 
             i < num_threads; 
             ++i, first_gid_x += wgs_per_thread, last_gid_x += wgs_per_thread) {
           arguments[i].args = args;
           arguments[i].work_dim = work_dim;
           arguments[i].local_work_size = local_work_size;
           arguments[i].global_work_size = global_work_size;
           arguments[i].first_gid_x = first_gid_x;
           if (i + 1 == num_threads) last_gid_x += leftover_wgs;
           arguments[i].last_gid_x = last_gid_x;


#ifdef DEBUG_MT       
       iprintf("### creating wg thread: first_gid_x==%%d, last_gid_x==%%d\\n",
                first_gid_x, last_gid_x);
#endif
       
           pthread_attr_t attr;
           pthread_attr_init(&attr);
          /* TODO: set stack size according to WG size so we don't waste space nor
             allocate too small stack  */
           pthread_attr_setstacksize(&attr, 32*1024); 
           pthread_create(&threads[i], &attr, &__opencl_wg_thread_%(kernel_name)s, &arguments[i]);
        }

        for (i = 0; i < num_threads; ++i) {
            pthread_join(threads[i], NULL);
        /*
        iprintf("### thread %%x finished\\n", (unsigned)threads[i]);
        */
        }
        free(arguments);
        free(threads);
#endif
   } else {
        /* single thread version: execute all work groups in
           a single trampoline call as fast as possible. 

           Do not create any threads. */
        /* allocate data for the local buffers. TODO: this is not
           thread safe due to the shared 'args' struct. In MT we need
           to copy the local pointers for each invocation. */
        int arg_is_local[] = _%(kernel_name)s_ARG_IS_LOCAL;
        for (int i = 0; i < _%(kernel_name)s_NUM_ARGS; ++i) {
            if (!arg_is_local[i]) continue;
            args[i] = malloc(sizeof(void*));             
            *((void**)args[i]) = malloc(sizes[i]);
            if (*((void**)args[i]) == NULL) {
#if 0
               puts("### out of memory while allocating the local buffers\\n");
#endif
               exit(1);
            }
        }
        __opencl_trampoline_%(kernel_name)s(
           args, work_dim, local_work_size, global_work_size,
           0, num_groups_x - 1);

        /* free the local buffers */
        for (int i = 0; i < _%(kernel_name)s_NUM_ARGS; ++i) {
            if (!arg_is_local[i]) continue;
            free(*((void**)args[i]));
            free(args[1]);
        }

   }
}

"""
                    # Generate the argument lists for the kernel workgroup
                    # function declaration and invocation.
                    for kernel in kernels:
                        count = 0
                        converted_name = "_" + kernel.name + "_workgroup"

        
                        # Add a class that registers the kernel to host API's kernel 
                        # registry at program startup
                        initializer_object = \
"""
class %(kernel_name)s_kernel {
public:    
    %(kernel_name)s_kernel() {
        kernel_obj.name = "%(kernel_name)s";
        kernel_obj.call = __opencl_trampoline_mt_%(kernel_name)s;
        _register_opencl_kernel(&kernel_obj);
    }
private:
    _OpenCLKernel kernel_obj;
} _kernel_initializer_obj_%(kernel_name)s;

""" % {'kernel_name' : kernel.name}

                        trampoline_func = trampoline_func_template % {\
                                  'kernel_name' : kernel.name,
                                  'converted_name' : converted_name} + \
                                  initializer_object

                    
                        tf.write(trampoline_func + "\n")
                    
                    tf.close()

                    trampoline_bc = cpp_trampoline + ".o"                   
                    compile(cpp_trampoline, trampoline_bc)

                    # Link the trampoline (+registration object) and the kernel together.
                    command = "llvm-link %s %s -o %s.tobelowered;" % \
                               (kernel_bc, trampoline_bc, outFileName)

                    command += lowerMemIntrinsicCommand(outFileName + ".tobelowered", outFileName)
                   
                elif suffix == ".cpp" or suffix == ".cc":
                    input_file = baseName + suffix
                    
                    if options.use_clang:
                        command = ("clang -ccc-host-triple tce-tut-llvm %s -emit-llvm " +\
                                    "-O%d "\
                                    "-fno-inline -c -I" + tmpDir + \
                                    " " + compileFlags + " " + input_file + " -o " +\
                                    outFileName + ".tobelowered1;") % \
                                    (extra_opts, options.frontend_optlevel)
                    else:
                        command = ("tce-llvm-g++ %s --emit-llvm -O%d "\
                                    "-fno-unit-at-a-time -fno-inline -c -I" + tmpDir + \
                                    " " + compileFlags + " " + input_file + " -o " +\
                                    outFileName + ".tobelowered1;") % \
                                    (extra_opts, options.frontend_optlevel)

                    # For some reason C++ code does not get mallocs lowered to
                    # calls by the frontend, do it manually here with the -lowerallocs
                    # pass.
                    # lowerallocs removed in 2.7?
                    #command += "opt -lowerallocs %s -o %s;" % \
#                        (outFileName + ".tobelowered1", outFileName + ".tobelowered")

                    command += lowerMemIntrinsicCommand(outFileName + ".tobelowered1", outFileName)
                elif suffix == ".ll":
                    command = ("llvm-as " + baseName + suffix + " -o " + outFileName + ".tobelowered;")

                    command += lowerMemIntrinsicCommand(outFileName + ".tobelowered", outFileName)

                elif suffix == ".bc":
                    exitWithError(
                        1, 
                        "Bytecode files can't be relinked. "
                        "Use .o suffix for unlinked bytecode files.\n")

                elif suffix == ".o":
                    outFileName =  fName

                elif suffix == ".a":
                    outFileName = fName

                # add all files to list for linkage
                linkList += [outFileName]

                if command != "":                    
                    exitCode = runCommand(command, verbose, echoStderr=True)
                    if exitCode != 0:
                        exitWithError(
                            1, 
                            "Error while compiling file: " +\
                            baseName + suffix + "\n")
            else:
                exitWithError(
                    1, 
                    "Unknown input file type: " +\
                    fName + ". Supported file types " +\
                    str(knownSuffices) + "\n")
    return linkList

def exitWithError(status, errorMessage=None):
    if errorMessage is not None:
        print >>sys.stderr, errorMessage
    cleanup(tempDir)
    sys.exit(status)

def lowerMemIntrinsicCommand(srcFile, dstFile):
    commandp = "opt -load=" + lowerintrinsicsplugin + " -lowerintrinsics "
    command = commandp + " -o " + dstFile + " " + srcFile
    return command
    
###
# Links bytecode files and returns name of the linked file.
##
def linkBytecode(linkFiles, fileNamePrefix, verbose):

    startFiles = os.path.join(newlib_libdir,"crt0.o ")

    libNoSys = os.path.join(newlib_libdir,"libnosys.a")
    if not os.path.exists(libNoSys):
        libNoSys = ""

    # libm must be linked first to make sure that necessary parts of libc will be linkend in (e.g. errno)
    endFiles = (os.path.join(newlib_libdir,"libm.a") + " " +
                os.path.join(newlib_libdir,"libc.a") + " " +
                libNoSys + " " +
                os.path.join(newlib_libdir,"crtend.o") + " ")


    linkedFileName = fileNamePrefix + "_linked"
    #### Link all binary code together
    command = "llvm-ld -disable-opt -o " + linkedFileName + " " + startFiles
    for name in linkFiles:
        command += " " + name

    command += " " + endFiles

    exitCode = runCommand(command, options.verbose, echoStderr=True)
    if exitCode != 0:
        if options.verbose:
            exitWithError(exitCode, "Error while linking bytecode: " + command + "\n")
        else:
            sys.exit(exitCode)

    # remove annoying autogenerated script.
    tryRemove(linkedFileName)


    return linkedFileName + ".bc"

####
# Optimizes linked bc. Returns name of the optimized file.
#
# You can check default switches with command:
# opt -O3 -debug-pass=Arguments systemtest/bintools/Scheduler/tests/QuickTests/HelloWorld/program.bc
###
def optimizeBytecode(inFile, fileNamePrefix):

    verbose = options.verbose

    # lets trust llvm team that they know which is the best
    # optimization set for overall performance... since when separately
    # adding own set we just end up tuning denbench / fft optimed switches
    # (its practically impossible to know how switches effect on any other case)

    # disable-simplify-libcalls needed to prevent memset/memset loop detection in
    # LoopIdiomRecognize pass, which breaks things due to memset contents being
    # converted to memset calls which causes infinite recursion. This has to be done 
    # because we always do full program linkage and optimization for TTA targets.
    default_opts = " -O3 --disable-simplify-libcalls "

    # no inline 
    default_opts += options.noinline and "-disable-inlining " or "-inline-threshold=%d " % options.inline_threshold

    # no need to run this, since intrinsics are lowered in isel...

    # hower if it's run before some optimizations is might be still
    # possible before isel in that case later optimization passes
    # must be selected very carefully in TCETargetMachine::addPreISel()
    
    #lowerIntrinsicsPass = " -load=" + lowerintrinsicsplugin + " -lowerintrinsics "
    #default_opts += lowerIntrinsicsPass

    # unroll swithes and disabling (threshold 0 should work as disable in opt)
    default_opts += "-unroll-allow-partial -unroll-threshold=%d " % options.unroll_threshold
       
    # -O0 optimization doesn't exist in opt
    optSwitches = ""

    if options.optimization_level == 0:
        options.sequential_schedule = True
    elif options.optimization_level == 1:
        optSwitches = (default_opts + "-disable-internalize ") 
    elif options.optimization_level > 1:
        optSwitches = (" -internalize "+ default_opts)

    if options.extra_llvm_opts != "":
        extra_opts = options.extra_llvm_opts.split(',')
        optSwitches += ' -' + ' -'.join(extra_opts)
    
    internalize_api_list = " -internalize-public-api-list=_start,_pthread_start"
    if options.keep_symbols != "":
        internalize_api_list += "," + options.keep_symbols
        
    optSwitches += internalize_api_list

    outputName = fileNamePrefix + "_optimized.bc"
        
    command = "opt -f " + inFile + " -o " + outputName + " " + optSwitches

    exitCode = runCommand(command, verbose)

    if exitCode != 0:
        exitWithError(1, "Error while optimizing bytecode: " + command + "\n")

    return outputName

####
# Link emulation function bytecode to program.
###
def linkEmulationFuncs(inFile, fileNamePrefix):

    verbose = options.verbose

    # if software floatingpoint should be lowered, link the emulation functions in
    emulationLib = os.path.join(newlib_libdir,"float_emulation.o") + " "
    linkedName = fileNamePrefix + "_libemul.bc"
        
    command = ("llvm-link -f " + inFile + " " + emulationLib + " -o " + linkedName)

    (exitCode, output) = runCommandBuffered(command, verbose)

    if exitCode != 0:
        exitWithError(1, "Error while linking emulation lib: " + command + "\n")

    outputName = fileNamePrefix + "_emul_internalized.bc"

    internalize_api_list = " -internalize-public-api-list=_start"
    if options.keep_symbols != "":
        internalize_api_list += "," + options.keep_symbols
    
    no_inline = ""
    if options.noinline:
        no_inline = " -disable-inlining"

    command = ("opt " + linkedName + no_inline +
               " -f -internalize " + internalize_api_list + " -o " + outputName)

    (exitCode, output) = runCommandBuffered(command, verbose)

    if exitCode != 0:
        sys.stderr.write("Error while internalizing emulation functions: " + command + "\n")
        exitWithError(1, output)

    return outputName

#############################################
# Main program
#############################################

# Options..
usage = "usage: %prog [options] source-or-bc-file1 source-or-bc-file2 ..."

p = optparse.OptionParser(usage)

p.add_option('-a', '--adf-file',
             type="string", action="store", metavar='file',
             dest="adf_file", default="",
             help="Architecture which for program is scheduled after "
             "the compilation. Note that 'schedule' must be installed.")

p.add_option('-s', '--scheduler-config',
             type="string", action="store", metavar='file',
             dest="scheduler_config", default=None,
             help="Configure file for scheduling command.")

p.add_option('-O', '--optimization-level',
             type="int", action="store", metavar='level',
             dest='optimization_level', default=3,
             help="Optimization level. 0=no optimizations, "
             "1=preserve program API, 2=don't respect original API, "
             "3 = same that 2. NOTE: For optimal floating point performance,"
             "this switch must be given also when compiling bc files to tpef.")

p.add_option('-k', '--keep-symbols',
             type="string", action="store",
             metavar='sym1,sym2,sym3', dest='keep_symbols', default="",
             help="List of symbols whose optimization away is prevented. "
             "If you are using this, remember to define "
             "at least 'main' symbol.")

p.add_option('-o', '--output-name',
             type="string", action="store", metavar='file',
             dest="output_name", default="",
             help="File name for output binary.")

p.add_option('-d', '--leave-dirty', action="store_true",
             dest='leave_dirty', default=False,
             help="Do not delete files from each compilation phase.")

p.add_option('-c', '--compile-only', action="store_true",
             dest='compile_only', default=False,
             help="Compile only do not link or optimize.")

p.add_option('-v', '--verbose', action="store_true",
             dest='verbose', default=False,
             help="Print out commands and outputs for each phase.")

p.add_option('-D', '--preprocessor-define', 
             type="string", action="append", metavar='string',
             dest="defines", default=[],
             help="Passed to gcc.")

p.add_option('-I', '--include-directory', 
             type="string", action="append", metavar='directory',
             dest="include_dirs", default=[],
             help="Passed to gcc.")

p.add_option('-L', '--library-directory', 
             type="string", action="append", metavar='directory',
             dest="lib_dirs", default=[],
             help="Passed to gcc.")

p.add_option('-l', '--library-link', 
             type="string", action="append", metavar='libname',
             dest="libs", default=[],
             help="Converted to static link command. i.e. -lpthread  => /llvm-install/tce-llvm/lib/libpthread.a")

p.add_option('-W', '--warning', 
             type="string", action="append", metavar='type',
             dest="warnings", default=[],
             help="Ignored.")

p.add_option('--plugin-cache-dir',
             type="string", action="store", metavar='directory',
             dest="plugin_cache_dir",
             default=os.path.expanduser("~/.tce/tcecc/cache"),
             help="Directory for cached llvm target plugins.")

p.add_option('--no-plugin-cache', action="store_false",
             dest="cache_backend_plugin", default=True,
             help="Do not cache generated llvm target plugins.")

p.add_option('--no-schedule', action="store_true",
             dest="no_schedule", default=False,
             help="Do not call scheduler.")

p.add_option('--disable-llvmaa', action="store_true",
             dest="disable_llvmaa", default=False,
             help="Disable use of LLVM Alias Analysis.")

p.add_option('--clear-plugin-cache', action="store_true",
             dest="clear_cache", default=False,
             help="Clear plugin cache completely.")

p.add_option('--disable-inlining', action="store_true",
             dest="noinline", default=False,
             help="Disable function inlining.")

p.add_option('--swfp', action="store_true",
             dest="soft_float", default=False,
             help="Link in software floating point emulation libraries.")

p.add_option('--conservative-pre-ra-scheduler', action="store_true",
             dest="conservative_pre_ra_scheduler", default=False,
             help="Use pre-regalloc-scheduler which tries to minimize"
             + " register usage instead of maximizing ILP."
             + " Should improve performance with machines with"
             + " low amount of registers, decrease peformance with machines"
             + " which have big number of registers.")

p.add_option('--unroll-threshold',
             type="int", action="store", metavar='LLVM_INSTRUCTION_COUNT',
             dest='unroll_threshold', default=100,
             help="Unroll loops in case the unrolled loop body size will be less " + \
             "than the given number of LLVM instructions. Use 0 to disable " + \
             "loop unrolling.")

p.add_option('--inline-threshold',
             type="int", action="store",
             dest='inline_threshold', default=200,
             help="Control the amount of inlining.")

p.add_option('--bypass-distance',
             type="int", action="store", dest='bypass_distance', default=-1,
             help="From how far to bypass results, if dead result elimination "\
                 "can be applied.");

p.add_option('--bypass-distance-nodre',
             type="int", action="store", dest='bypass_distance_nodre',
             default=-1,
             help="From how far to bypass results, if the results cannot be "\
                 "eliminated.")

p.add_option('--sequential-schedule', action="store_true",
             dest="sequential_schedule", default=False,
             help="Runs sequential scheduler for compiled code.")

p.add_option('--debug', action="store_true",
             dest="debug", default=False,
             help="Print LLVM debug data.")

p.add_option('--isystem', 
             type="string", action="append", metavar='directory',
             dest="isystem_cc_switches", default=[],
             help="Passed to gcc as -system switch. Also -isystem is supported.")

p.add_option('-B', 
             type="string", action="append", metavar='directory',
             dest="B_cc_switches", default=[],
             help="Passed to gcc.")

p.add_option('-f', 
             type="string", action="append", metavar='opt_var',
             dest="f_cc_switches", default=[],
             help="Passed to gcc.")

p.add_option('-g', 
             action="store_true",
             dest="g_cc_switch", default=False,
             help="Passed to gcc.")

# Use the default greedy allocator only with LLVM 3.0.
if "@LLVM_VERSION@" == "2.9":
    p.add_option('--default-regalloc',
                 action='store_true', dest='default_regalloc', default=False,
                 help=\
                     """Use the default register allocator of LLVM instead of the register allocator
that aims to maximize the instruction level parallelism available for
the post-pass scheduler.""")
else:
    p.add_option('--experimental-regalloc',
                 action='store_false', dest='default_regalloc', default=True,
                 help=\
                     """Use the customized experimental register allocator of TCE
that aims to maximize the instruction level parallelism available for
the post-pass scheduler instead of the default LLVM register allocator (deprecated).
""")

p.add_option('--extra-llvm-opts',
             type="string", action="store",
             metavar='opt1,opt2,opt3', dest='extra_llvm_opts', default="",
             help="List of additional LLVM passes to run after the regular ones.")

p.add_option('--frontend-optlevel',
             type="int", action="store", dest="frontend_optlevel",
             default=None,
             help=\
"""The level of optimization done by the frontend compiler,
if applicable. The -O switch controls the optimizations applied to the
whole linked program.""")             

if @CLANG_AS_DEFAULT@:
    p.add_option('--llvm-gcc', action='store_false', dest='use_clang', default=True,
                 help=\
"Use llvm-gcc for C compilation instead of Clang.")
else:
    p.add_option('--clang', action='store_true', dest='use_clang', default=False,
                 help=\
"Use Clang for C compilation instead of llvm-gcc.")

p.add_option('-x', type='string', action='store', metavar='language',
             dest="language", default='', help=\
"""Bypass language detection and use the given language for compilation.""")             

p.add_option('--supported-languages', action='store_true', 
             dest="list_langs", default=False, help=\
"""List the supported languages and exit.""")

p.add_option('--version', action='store_true',
             dest='print_version', default=False, help=\
"""Print the tcecc version info and exit.""")

p.add_option('--dump-ddgs-dot', action='store_true', dest='dump_ddgs_dot', default=False,
             help=\
"""Dumps DDGs in dot format before and after scheduling.""")

p.add_option('--dump-ddgs-xml', action='store_true', dest='dump_ddgs_xml', default=False,
             help=\
"""Dumps DDGs in XML format before and after scheduling.""")

p.add_option('--dump-ddgs', action='store_true', dest='dump_ddgs', default=False,
             help=\
"""Equivalent to --dump-ddgs-dot --dump-ddgs-xml.""")

p.add_option('--no-kill-dead-results', action='store_false',
             dest='kill_dead_results', default=True, help=\
"""Disable dead result elimination during bypassing.""");

p.add_option('--no-rename-registers', action='store_false', dest='rename_registers', default=True,
             help=\
"""Disable register renaming, which renames registers during scheduling, after the actual register allocation.""")

p.add_option('--print-resource-constraints', action='store_true',
             dest='print_resource_constraints', default=False,
             help=\
             "Print (to stderr) the resources that potentially constraint " +
             "the schedule.")

p.add_option('--emit-llvm', action='store_true', dest='emit_llvm', default=False,
             help=\
"Output LLVM bitcode. Does not pass the linked bitcode to the "\
"code generator to produce target specific TTA code.")

if @OPENCL_ENABLED@:
    p.add_option('--opencl-max-parallel-wi-count',
             type="int", action="store",
             dest='opencl_max_parallel_wi_count', default=8,
             help=\
   """The maximum number of work items that are compiled (unrolled) to 
be executed in parallel.""")

p.add_option('--old-builder', action='store_true', dest='pom_builder', 
             default=False,
             help=\
"Use the old LLVM-TCE builder code to get code to TCE scheduler (deprecated).")

p.add_option('--bottom-up-scheduler', action='store_true', dest='bu_scheduler', 
             default=False,
             help=\
"Use an experiment Bottom Up scheduler.")

# Commandline argument parsing

# fix gcc switches, which cannot be represented in OptionParser format by adding extra "-" before switch
args = []
for opt in sys.argv[1:]:
    if opt.startswith("-isystem") or opt.startswith("-emit-llvm"): opt = "-" + opt
    args.append(opt)

# parse valid args
options, inFiles = p.parse_args(args)

if options.frontend_optlevel is None:
    options.frontend_optlevel = options.optimization_level

# create temp dir
tempDir = mkdtemp("","tcecc-")

# assign signal handlers to exit cleanly
try:
    signal.signal(signal.SIGHUP, handler)
    signal.signal(signal.SIGTSTP, handler)
except:
    # The signals do not work in MinGW/Windows
    pass

# clear plugin cache and do nothing else if the --clear-plugin-cache
# option is given
if options.clear_cache:
    pluginFiles = glob.glob(options.plugin_cache_dir + '/*.so')
    for fName in pluginFiles:
        tryRemove(fName)

    sys.stdout.write("Cleared plugin cache.\n")
    cleanup(tempDir)
    sys.exit(0)

if options.list_langs:
    supported_languages = ["ISO C99 (c)", "C++ (c++)"]
    if @OPENCL_ENABLED@:
        supported_languages.append("OpenCL C (cl)")
    print "\n".join(supported_languages)
    sys.exit(0)

if options.print_version:
    print "tcecc - TCE retargetable compiler %s" % "@PACKAGE_VERSION@"
    sys.exit(0)

if len(inFiles) == 0:
    p.print_help()
    cleanup(tempDir)
    sys.exit(1)

if options.output_name == "":
    # configure checks sometimes check if a.out is created by default..
    # (pth lib at least)
    outputName = "a.out"
else:
    outputName = options.output_name

### llvm-gcc install prefix
(exitCode1, output) = runCommandBuffered("dirname `which tce-llvm-gcc`", False)
(exitCode2, output) = runCommandBuffered("dirname `which clang`", False)
if exitCode1 != 0 and exitCode2 != 0:
    sys.stderr.write("Could not find 'tce-llvm-gcc' nor 'clang'. Have you installed one of them in PATH?\n")
    exitWithError(1, output)

### tce install prefix
(exitCode, output) = runCommandBuffered("tce-config --prefix", False)
if exitCode != 0:
    tceInstalled = False
else:
    tceInstalled = True
    tceprefix = output
    
## check if we are running from the TCE source tree in which case use only
## source tree libraries and binaries
scriptDir = os.path.abspath(os.path.dirname(sys.argv[0]))
runningInstalled = 'src/bintools/Compiler' not in scriptDir

if runningInstalled:
    lowerintrinsicsplugin = os.path.join(tceprefix,"lib/tce/LowerIntrinsics.so")
    newlib_libdir = os.path.join(tceprefix,"tce-llvm/lib")
    newlib_includes = "-isystem " + os.path.join(tceprefix,"tce-llvm/include") + " "
    bclib_includes = "" # same as newlib_includes
    bclib_libdirs = [newlib_libdir] # all libs should be in the same newlib_libdir
    opencl_includes = "" # same as newlib_includes
    srcRoot = None
    tceSAOpenCLBinDir = tceprefix + "/bin"
    tceSAOpenCLIncDir = os.path.join(tceprefix, "tce-llvm", "include")
    tceOclExtGenDir = os.path.join(tceprefix, "bin")
    tceOclBitcodeLibDir = os.path.join(tceprefix, "lib/llvmopencl")

else:
    srcRoot = "@abs_top_srcdir@"
    lowerintrinsicsplugin = os.path.join("@abs_top_builddir@", "src/applibs/LLVMBackend/passes/.libs/LowerIntrinsics.so")
    newlib_libdir = os.path.join("@abs_top_builddir@","newlib-1.17.0/tce-llvm/newlib")
    newlib_includes = ("-isystem " + os.path.join("@abs_top_srcdir@","newlib-1.17.0/tce-llvm/newlib/targ-include") +
                       " -isystem " + os.path.join("@abs_top_srcdir@","newlib-1.17.0/newlib/libc/include") +
                       " -isystem " + os.path.join("@abs_top_srcdir@","newlib-1.17.0/newlib/libm/include") + " ")
    bclib_includes = ("-isystem " + os.path.join("@abs_top_srcdir@", "bclib/include"))
    lwpr_libdir = os.path.join("@abs_top_srcdir@", "bclib/lwpr")

    # The standalone OpenCL paths.
    tceSAOpenCLDir = os.path.join(srcRoot, "bclib/saocl")
    tceSAOpenCLBitcodeLibDir = os.path.join("@abs_top_builddir@", "bclib/saocl")
    tceSAOpenCLIncDir = os.path.join("@abs_top_srcdir@", "bclib/include")
    tceOclExtGenDir = os.path.join("@abs_top_builddir@", "src/bintools/Compiler/tceopgen")

    bclib_libdirs = [newlib_libdir, lwpr_libdir, tceSAOpenCLBitcodeLibDir]

if options.verbose:
    if runningInstalled:
        print "Running installed TCE from PATH."    
    else:
        print "Running from a TCE build tree rooted at '%s'." % "@abs_top_builddir@"
    
    
namePrefix = tempDir + "/" + os.path.basename(outputName)

if options.compile_only and options.output_name != "" and len(inFiles) > 1:
    sys.stdout.write("Cannot specify -o  with -c and multiple input files.\n")
    cleanup(tempDir)
    sys.exit(1)

elif len(inFiles) == 1 and inFiles[0][-3:] == ".bc":
    # Only one .bc inputfile given. No need to compile, link or optimize anything.
    # Note: Already linked bytecode can't be linked or optimized
    # with -lowermissing again anyway!
    optimizedFileName = inFiles[0]
else:
    # Compile, link and optimize input files.
    
    # generate tceops.h
    if runningInstalled:
        tceopgen = "tceopgen"
    else:
        tceopgen = "@abs_top_builddir@" + "/src/bintools/Compiler/tceopgen/tceopgen"
        
    (exitCode, output) = runCommandBuffered(
        tceopgen + " -o " + tempDir + "/tceops.h" , options.verbose)
    
    if exitCode != 0:
        sys.stderr.write("Error while generating custom operation macros:\n")
        exitWithError(1, output)
    
    linkList = processInputFiles(inFiles, tempDir, options.verbose)

    if options.compile_only:
        if options.output_name != "":
            (exitCode, output) = runCommandBuffered(
                "mv " + linkList[0] + " " + options.output_name,
                options.verbose)

        else:
            cmd = "mv "
            for fName in linkList:
                cmd += fName + " "
            cmd += "."
            (exitCode, output) = runCommandBuffered(cmd, options.verbose)

        cleanup(tempDir)
        sys.exit(0)

    # convert -l switches to direct references to static library files
    library_search_paths = bclib_libdirs

    for i in options.lib_dirs:
        library_search_paths.append(i)
         
    for i in options.libs:
        lib_found = False
        for p in library_search_paths:
            lib_path = os.path.join(p, "lib%s.a" % i)
            if os.path.exists(lib_path):
                linkList.append(lib_path)
                lib_found = True
                break 
        if not lib_found:
            exitWithError(1, "Could not find lib%s.a in library search paths %s" % \
                              (i, library_search_paths))
    
    linkedFileName = linkBytecode(linkList, namePrefix, options.verbose)

    # optimize the fully linked program also
    optimizedFileName = optimizeBytecode(linkedFileName, namePrefix)

    if options.adf_file == "" or options.emit_llvm:
        (exitCode, output) = runCommandBuffered(
            "mv " +  optimizedFileName + " " + outputName,
            options.verbose)
        cleanup(tempDir)
        sys.exit(0)
        
#### Schedule compiled sequential code for machines
if options.adf_file != "":

    outFile = outputName
    seqFile = tempDir + "/" + os.path.basename(outFile) + ".seq"

    # optimize and lower floatingpoint
    if options.soft_float:
        emulationLinkedFileName = linkEmulationFuncs(optimizedFileName, namePrefix)
    else:
        emulationLinkedFileName = optimizedFileName

    toCodeGenFname = emulationLinkedFileName + ".intrinsics_lowered"

    runCommand(lowerMemIntrinsicCommand(emulationLinkedFileName, toCodeGenFname),
               options.verbose, True)

    if options.pom_builder and (options.sequential_schedule or options.optimization_level == 0):
        scheduler_config_file_name = "sequential_tcecc_scheduler.conf"
        if options.dump_ddgs or options.dump_ddgs_dot or options.dump_ddgs_xml:
            exitWithError(1, 
            "Error: Conflicting options. Dumping of DDGs is enabled only at optimization levels > 0.\n")
    else:
        scheduler_config_file_name = "default_scheduler.conf"        
        
    if not options.no_schedule and options.pom_builder and options.scheduler_config is None:
        if runningInstalled:
            options.scheduler_config = (tceprefix +
                                        "/share/tce/scheduler/passes/" +
                                        scheduler_config_file_name)
        else:
            options.scheduler_config = os.path.normpath("@abs_top_srcdir@" +
                                                        "/scheduler/passes/" +
                                                        scheduler_config_file_name)

    #### Compile to unscheduled mixed code for the target architecture
    if not runningInstalled:
        command = "@abs_top_builddir@" + "/src/bintools/Compiler/llvm-tce/llvm-tce"
    else:
        command = "llvm-tce"

    if options.verbose:
        command += " -v"
        
    if options.debug:
        command += " --debug"

    if options.conservative_pre_ra_scheduler:
        command += " --conservative-pre-ra-scheduler"
     
    if options.print_resource_constraints:
        command += " --print-resource-constraints"

    if not options.default_regalloc:
        command += " --experimental-ra"

    if options.leave_dirty:
        command += " -d"

    if options.disable_llvmaa:
        command += " --disable-llvmaa"

    if not options.cache_backend_plugin:
        command += " --no-save-backend-plugin "
        
    if options.dump_ddgs:
        command += " --dump-ddgs-dot --dump-ddgs-xml"
    else:
        if options.dump_ddgs_dot:
            command += " --dump-ddgs-dot"

        if options.dump_ddgs_xml:
            command += " --dump-ddgs-xml"

    if options.rename_registers:
        command += " --rename-registers"
    else:
        command += " --no-rename-registers"

    if options.kill_dead_results:
        command += " --kill-dead-results"
    else:
        command += " --no-kill-dead-results"

    if not options.no_schedule and options.pom_builder:
        # The new builder does not use scheduler configs,
        # it calls the scheduler directly after getting
        # the input from LLVM.
        command += " -c " + options.scheduler_config

    if options.pom_builder:
        command += " --pom-builder"

    if options.bu_scheduler:
        command += " --bottom-up-scheduler"
        
    if options.pom_builder or options.scheduler_config is not None:
        print >> sys.stderr, "Deprecation warning: The old builder is going to be removed from TCE soon. Please use the default builder and report the possible bugs found in it."

    stdEmulationLib = os.path.join(newlib_libdir, "standard_emulation.o ")

    command += " --bypass-distance=%d" % options.bypass_distance
    command += " --bypass-distance-nodre=%d" % options.bypass_distance_nodre

    command += (" -a " + options.adf_file +
                " -o " + outFile +
                " -O" + str(options.optimization_level) +
                " -e" + stdEmulationLib +
                " " + toCodeGenFname)
       
    exitCode = runCommand(command, options.verbose, True)
    if exitCode != 0:
        if options.verbose:
            exitWithError(exitCode, "Error while compiling " + command + "\n")
        else:
            sys.exit(exitCode)

#### Cleanup trashes
cleanup(tempDir)
