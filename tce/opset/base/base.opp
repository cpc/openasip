<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<osal version="0.1">

  <operation>
    <name>ADDSUB</name>
    <description>Add and sub the inputs and store results to 3 and 4, respectively.</description>
    <inputs>2</inputs>
    <outputs>2</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <out element-count="1" element-width="32" id="4" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(add, IO(1), IO(2), IO(3));
      EXEC_OPERATION(sub, IO(1), IO(2), IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL1ADD</name>
    <description>Array indexing for 16-bit data types</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      SimValue shifted;
      EXEC_OPERATION(shl, IO(1), 1, shifted);
      EXEC_OPERATION(add, shifted, IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL2ADD</name>
    <description>Array indexing for 32-bit data types</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      SimValue shifted;
      EXEC_OPERATION(shl, IO(1), 2, shifted);
      EXEC_OPERATION(add, shifted, IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ADD</name>
    <description>Integer addition. Output 3 is sum of inputs 1 and 2.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(add, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SUB</name>
    <description>Integer subtraction. Input 1 is minuend,  input 2 is subtrahend and output 3 is difference.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sub, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDW</name>
    <description>Loads 32 bits. Input 1 is address and output 2 read data.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldw, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>STW</name>
    <description>Stores 32 bits. Input 1 is address and output 2 is write data.</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>
      EXEC_OPERATION(stw, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>EQ</name>
    <description>Equality comparison. Output 3 returns '1' if inputs 1 and 2 are equal and otherwise returns '0'.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(eq, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GT</name>
    <description>Greater-than signed integer comparison. 
Output returns '1' if input 1 is greater than input 2 and otherwise returns '0'.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gt, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GTU</name>
    <description>Greater-than unsigned integer comparison. Output returns '1' if input 1 is greater than input 2 and otherwise returns '0'.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gtu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LT</name>
    <description>Less-than signed integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gt, IO(2), IO(1), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LTU</name>
    <description>Less-than unsigned integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gtu, IO(2), IO(1), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NE</name>
    <description>Not equal signed integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics> 
      SimValue t1;
      EXEC_OPERATION(eq, IO(1), IO(2), t1);
      EXEC_OPERATION(xor, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(gt, IO(1), IO(2), t1);
      EXEC_OPERATION(gt, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GE</name>
    <description>Greater or equal signed integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics> 
      SimValue t1;
      EXEC_OPERATION(gt, IO(2), IO(1), t1);
      EXEC_OPERATION(xor, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(gt, IO(1), IO(2), t1);
      EXEC_OPERATION(eq, IO(1), IO(2), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GEU</name>
    <description>Greater or equal unsigned integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(gtu, IO(2),IO(1), t1);
      EXEC_OPERATION(xor, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(gtu, IO(1), IO(2), t1);
      EXEC_OPERATION(eq, IO(1), IO(2), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LE</name>
    <description>Less or equal signed integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(gt, IO(1),IO(2), t1);
      EXEC_OPERATION(xor, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(eq, IO(1), IO(2), t1);
      EXEC_OPERATION(gt, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LEU</name>
    <description>Less or equal unsigned integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(gtu, IO(1),IO(2), t1);
      EXEC_OPERATION(xor, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(eq, IO(1), IO(2), t1);
      EXEC_OPERATION(gtu, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL</name>
    <description>Left logical shift. Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shl, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHR</name>
    <description>Arithmetic shift right (sign bit duplicated). Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shr, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHRU</name>
    <description>Logical shift right (most siginificant bits zeroed). Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
  </operation>

  <operation>
    <name>AND</name>
    <description>Bitwise AND. Operands 1 and 2 are inputs and 3 is output result.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(and, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>IOR</name>
    <description>Inclusive OR. Operands 1 and 2 are inputs and 3 is output result.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(ior, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>XOR</name>
    <description>Exclusive OR. Operands 1 and 2 are inputs and 3 is output result.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(xor, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>JUMP</name>
    <description>Absolute jump to the given instruction address.</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(jump, IO(1));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CALL</name>
    <description>Calls a function at the given absolute instruction address. The return address is saved in the return address register (RA).</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-call/>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(call, IO(1));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MIN</name>
    <description>Returns the smaller of the two signed integer values. Operands 1 and 2 are inputs and 3 is output result.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(min, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MAX</name>
    <description>Returns the larger of the two signed input values. Operands 1 and 2 are inputs and 3 is output result.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(max, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MINU</name>
    <description>Returns the smaller of the two unsigned input values.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(minu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MAXU</name>
    <description>Returns the larger of the two unsigned input values.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(maxu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDQ</name>
    <description>Reads quarter word from memory with sign extension.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="SIntWord">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldq, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDH</name>
    <description>Reads half word from memory with sign extension.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="SIntWord">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldh, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDD</name>
    <description>Reads double word from memory.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="64" id="2" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldd, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>STQ</name>
    <description>Stores quarter word to memory</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="8" id="2" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>
      EXEC_OPERATION(stq, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>STH</name>
    <description>Stores half word to memory.</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="16" id="2" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>
      EXEC_OPERATION(sth, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>STD</name>
    <description>Store double word to memory.</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="64" id="2" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>
      EXEC_OPERATION(std, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SXBW</name>
    <description>sign extend from 1 bit to 32 bits</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <out id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sxbw, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SXQW</name>
    <description>Sign extend from 8 bits of the input 1 to 32 bits into output 2.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sxqw, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SXHW</name>
    <description>Sign extend from 16 bits of of the input 1 to 32 bits into output 2.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sxhw, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>TRUNCWH</name>
    <description>truncate 32 bit int to 16 bit int</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <out id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(truncwh, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEG</name>
    <description>Arithmetic negation, signed integer.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(neg, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEGF</name>
    <description>Arithmetic negation, floating-point.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <out element-count="1" element-width="32" id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(negf, IO(1), IO(2));
    </trigger-semantics>
    <trigger-semantics>
      SimValue tmp;
      EXEC_OPERATION(subf, IO(1), IO(1), tmp);
      EXEC_OPERATION(subf, tmp, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEGH</name>
    <description>Arithmetic negation, half floating-point.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(negf, t1, t2);
      EXEC_OPERATION(cfh, t2, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(negh, IO(1), IO(2));
    </trigger-semantics>
    <trigger-semantics>
      SimValue tmp;
      EXEC_OPERATION(subh, IO(1), IO(1), tmp);
      EXEC_OPERATION(subh, tmp, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MAXF</name>
    <description>Returns the larger of the two floating-point input values.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="FloatWord"/>
  </operation>

  <operation>
    <name>MINF</name>
    <description>Returns the smaller of the two floating-point input values.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="FloatWord"/>
  </operation>

  <operation>
    <name>MAXH</name>
    <description>Returns the larger of the two half floating-point input values.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(maxf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MINH</name>
    <description>Returns the smaller of the two half floating-point input values.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(minf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MUL</name>
    <description>32-bit integer multiplication of the inputs 1 and 2 with lower result bits in the output 3.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(mul, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>DIV</name>
    <description>Integer division.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(div, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>DIVU</name>
    <description>Unsigned integer division.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(divu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ADDF</name>
    <description>Floating-point addition. Output 3 is sum of inputs 1 and 2.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(addf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SUBF</name>
    <description>Floating-point substraction.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(subf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MULF</name>
    <description>32-bit floating-point multiplication</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(mulf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>DIVF</name>
    <description>Floating-point division.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(divf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>EQF</name>
    <description>Floating-point compare equal (ordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(eqf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEF</name>
    <description>Not equal floating-point comparison (ordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(nef, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(gtf, IO(1), IO(2), t1);
      EXEC_OPERATION(gtf, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GTF</name>
    <description>Greater-than floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gtf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GEF</name>
    <description>Greater or equal floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gef, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(gtf, IO(1), IO(2), t1);
      EXEC_OPERATION(eqf, IO(1), IO(2), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LTF</name>
    <description>Less-than floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(ltf, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(gtf, IO(2), IO(1), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LEF</name>
    <description>Less or equal floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(lef, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(eqf, IO(1), IO(2), t1);
      EXEC_OPERATION(gtf, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>EQUF</name>
    <description>Floating-point compare equal (unordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>EXEC_OPERATION(eqf, IO(1), IO(2), IO(3));



</trigger-semantics>
  </operation>

  <operation>
    <name>NEUF</name>
    <description>Not equal floating-point comparison (unordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1;
EXEC_OPERATION(eqf, IO(1), IO(2), temp1);
EXEC_OPERATION(xor, temp1, 1, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>GTUF</name>
    <description>Greater-than floating-point comparison (unordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>EXEC_OPERATION(gtf, IO(1), IO(2), IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>GEUF</name>
    <description>Greater or equal floating-point comparison (unordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1, temp2;
EXEC_OPERATION(gtf, IO(1), IO(2), temp1);
EXEC_OPERATION(eqf, IO(1), IO(2), temp2);
EXEC_OPERATION(ior, temp1, temp2, IO(3));


</trigger-semantics>
  </operation>

  <operation>
    <name>LTUF</name>
    <description>Less-than floating-point comparison (unordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1, temp2, temp3;
EXEC_OPERATION(gtf, IO(1), IO(2), temp1);
EXEC_OPERATION(eqf, IO(1), IO(2), temp2);
EXEC_OPERATION(ior, temp1, temp2, temp3);
EXEC_OPERATION(xor, temp3, 1, IO(3));



</trigger-semantics>
  </operation>

  <operation>
    <name>LEUF</name>
    <description>Less or equal floating-point comparison (unordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1;
EXEC_OPERATION(gtf, IO(1), IO(2), temp1);
EXEC_OPERATION(xor,temp1,1, IO(3));

</trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(eqf, IO(1), IO(2), t1);
      EXEC_OPERATION(gtf, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ADDH</name>
    <description>Half precision floating-point addition. Output 3 is sum of inputs 1 and 2.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="16" id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(addf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SUBH</name>
    <description>Half floating-point substraction.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(subf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(subh, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MULH</name>
    <description>16-bit floating-point multiplication.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="16" id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(mulf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(mulh, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>DIVH</name>
    <description>Half float division.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(divf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(divh, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MACH</name>
    <description>Multiply and accumulate (half floating-point).</description>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="16" id="3" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="16" id="4" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mulh, IO(2), IO(3), t1);
      EXEC_OPERATION(addh, IO(1), t1, IO(4));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2, t3, t4, t5;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(chf, IO(3), t3);
      EXEC_OPERATION(mulf, t2, t3, t4);
      EXEC_OPERATION(addf, t1, t4, t5);
      EXEC_OPERATION(cfh, t5, IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MSUH</name>
    <description>Multiply and substract (half floating-point).</description>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="16" id="3" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="16" id="4" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mulh, IO(2), IO(3), t1);
      EXEC_OPERATION(subh, IO(1), t1, IO(4));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2, t3, t4, t5;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(chf, IO(3), t3);
      EXEC_OPERATION(mulf, t2, t3, t4);
      EXEC_OPERATION(subf, t1, t4, t5);
      EXEC_OPERATION(cfh, t5, IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MACF</name>
    <description>Multiply and accumulate (floating-point).</description>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="3" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="4" type="FloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mulf, IO(2), IO(3), t1);
      EXEC_OPERATION(addf, IO(1), t1, IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MSUF</name>
    <description>Multiply and substract (floating-point).</description>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="3" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="4" type="FloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mulf, IO(2), IO(3), t1);
      EXEC_OPERATION(subf, IO(1), t1, IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MAC</name>
    <description>Multiply and accumulate (signed integer).</description>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="3" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="4" type="SIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mul, IO(2), IO(3), t1);
      EXEC_OPERATION(add, t1, IO(1), IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>EQH</name>
    <description>Half floating-point compare equal.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(eqf, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(eqh, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEH</name>
    <description>Not equal half floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(nef, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(neh, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(gth, IO(1), IO(2), t1);
      EXEC_OPERATION(gth, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEUH</name>
    <description>Not equal half floating-point comparison (unordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(neuf, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GTH</name>
    <description>Greater-than half floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(gtf, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(gth, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GEH</name>
    <description>Greater or equal half floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(gef, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(geh, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(gth, IO(1), IO(2), t1);
      EXEC_OPERATION(eqh, IO(1), IO(2), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LTH</name>
    <description>Less-than half floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(ltf, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(lth, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(gth, IO(2), IO(1), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LEH</name>
    <description>Less or equal half floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(lef, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(leh, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(eqh, IO(1), IO(2), t1);
      EXEC_OPERATION(gth, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CFI</name>
    <description>Converts floating-point to integer.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cfi, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CFIU</name>
    <description>Converts floating-point to unsigned integer.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cfiu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CIF</name>
    <description>Converts integer to float.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cif, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CIFU</name>
    <description>Converts unsigned integer to floating-point.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cifu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CFD</name>
    <description>Converts single precision floating-point to double.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <out element-count="1" element-width="64" id="2" type="DoubleWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cfd, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CDF</name>
    <description>Converts double precision floating-point to single precision.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="DoubleWord"/>
    <out element-count="1" element-width="32" id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cdf, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CHI</name>
    <description>Converts half floating-point to signed integer.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(cfi, t1, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(chi, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CHIU</name>
    <description>Converts half floating-point to unsigned integer.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(cfiu, t1, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(chiu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CIH</name>
    <description>Converts integer to half floating-point.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(cif, IO(1), t1);
      EXEC_OPERATION(cfh, t1, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(cih, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CIHU</name>
    <description>Converts unsigned integer to half floating-point.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(cifu, IO(1), t1);
      EXEC_OPERATION(cfh, t1, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(cihu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CHF</name>
    <description>Converts half precision floating-point to single precision.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="32" id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(chf, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CFH</name>
    <description>Converts single precision floating-point to half.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cfh, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ROTL</name>
    <description>Rotate left.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
  </operation>

  <operation>
    <name>ROTR</name>
    <description>Rotate right.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(rotr, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ABS</name>
    <description>Absolute value.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
  </operation>

  <operation>
    <name>ABSF</name>
    <description>Floating-point absolute value.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <out element-count="1" element-width="32" id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(absf, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ABSH</name>
    <description>Half precision floating-point absolute value.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(absf, t1, t2);
      EXEC_OPERATION(cfh, t2, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(absh, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDQU</name>
    <description>Reads quarter word from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="8" id="2" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldqu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDHU</name>
    <description>Reads half word from memory with zero extension.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="16" id="2" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldhu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MOD</name>
    <description>Integer modulo.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(mod, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MODU</name>
    <description>Integer modulo (unsigned)</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(modu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>STDOUT</name>
    <description>Writes a single 8bit char to "standard output" which is platform dependent. In simulator outputs the character to simulator console. Used for debugging. printf() uses this by default.</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <side-effects/>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(stdout, IO(1));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NOT</name>
    <description>Bitwise negation.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>ANDN</name>
    <description>Does a bitwise negation (NOT) on the 2nd input followed by AND of the 1st input and the negated 2nd output. Special instruction in TI C64X.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>	SimValue negResult, mulin;
	EXEC_OPERATION(not, IO(2), negResult);
	EXEC_OPERATION(and, negResult, IO(1), IO(3));










</trigger-semantics>
  </operation>

  <operation>
    <name>LMBD</name>
    <description>Leftmost Bit Detection (from TI C64X). Counts the number of 0's or 1's in the bit representation of operand 1 before the first 1 or 0. 2nd operand is used to tell whether to search for a 0 or 1.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
  </operation>

  <operation>
    <name>STREAM_IN</name>
    <description>The "default streaming" operation for input.
Reads one sample of input from the data stream. The width of the sample is defined by the function unit output port width. 
When triggered with 0 writes a new sample to the output, if there are one ore more samples to be read in the buffer, otherwise causes a global lock.
The IN file can be set using TTASIM_STREAM_IN_FILE environment variable.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <affects>
      <operation name="STREAM_IN_STATUS"/>
    </affects>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="RawData"/>
  </operation>

  <operation>
    <name>STREAM_OUT</name>
    <description>The "default streaming" operation for output.
Writes one sample to the output data stream. The width of the sample is
defined by the function unit input port width.
In case no room is available in the output buffer, causes a global lock.
The OUT file can be set using TTASIM_STREAM_OUT_FILE environment variable.</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <side-effects/>
    <affects>
      <operation name="STREAM_OUT_STATUS"/>
    </affects>
    <in element-count="1" element-width="32" id="1" type="RawData"/>
  </operation>

  <operation>
    <name>STREAM_IN_STATUS</name>
    <description>The "default streaming" operation for querying input buffer status.

Trigger with 0.

Return an integer with the following meanings:

0 = buffer empty
1 = not empty nor full (implies a buffer size &gt; 1 sample and that there is at least one sample in the buffer)
2 = buffer full

This operation allows handling stream buffer underflow without a global lock, thus allows doing something useful (run another thread, for example) while the buffer is empty.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <affected-by>
      <operation name="STREAM_IN"/>
    </affected-by>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>STREAM_OUT_STATUS</name>
    <description>The "default streaming" operation for querying output buffer status.

Trigger with 0.

Return an integer with the following meanings:

0 = buffer empty
1 = not empty nor full (implies a buffer size &gt; 1 sample and that there is at least one sample in the buffer)
2 = buffer full

This operation allows handling stream buffer overflow without a global lock, thus allows doing something useful (run another thread, for example) while the
buffer is full.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <affected-by>
      <operation name="STREAM_OUT"/>
    </affected-by>
    <in element-count="1" element-width="32" id="1" type="RawData"/>
    <out element-count="1" element-width="32" id="2" type="RawData"/>
  </operation>

  <operation>
    <name>RTIMER</name>
    <description>Real time timer. 

Counts time (given in microseconds) down from the given value until reaches zero.

When triggered with 0, returns the current timer value, when triggered with a value greater than 0, sets the timer value.

The simulation behavior definition assumes 100MHz clock frequency, which can be modified using the environment variable TCE_RTIMER_CLOCK=MHZ.

</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>RTC</name>
    <description>Real time clock.

Counts time (microseconds) up from zero.

When triggered with 0, resets the timer value to zero, when triggered with a value greater than 0, returns the timer value.

The simulation behavior definition assumes 100MHz clock frequency, which can be modified using the environment variable TCE_RTIMER_CLOCK=MHZ.

</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>ORDF</name>
    <description>Returns 1 if floating point input operands are ordered. i.e. neither of the input operands is NaN.

</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1, temp2;
EXEC_OPERATION(eqf, IO(1), IO(1), temp1);
EXEC_OPERATION(eqf, IO(2), IO(2), temp2);
EXEC_OPERATION(and, temp1, temp2, IO(3));



</trigger-semantics>
  </operation>

  <operation>
    <name>UORDF</name>
    <description>Returns 1 if the two floating point operands are unordered. i.e. isNaN(io1) || isNan(io2).

</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1, temp2, temp3;
EXEC_OPERATION(eqf, IO(1), IO(1), temp1);
EXEC_OPERATION(eqf, IO(2), IO(2), temp2);
EXEC_OPERATION(and, temp1, temp2, temp3);
EXEC_OPERATION(xor, temp3, 1, IO(3));



</trigger-semantics>
  </operation>

  <operation>
    <name>SQRTF</name>
    <description>Performs a square root of a single precision floating point. For example, the MIPS R4000 FPU implements it.
</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <out element-count="1" element-width="32" id="2" type="FloatWord"/>
  </operation>

  <operation>
    <name>SQRTH</name>
    <description>Performs a square root of a half precision floating point.
    </description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(sqrtf, t1, t2);
      EXEC_OPERATION(cfh, t2, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>INVSQRTH</name>
    <description>Performs a inverse square root of a half-precision floating point.
</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
  </operation>

  <operation>
    <name>SQUAREH</name>
    <description>Computes the square of a half-precision floating point.
</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(mulf, t1, t1, t2);
      EXEC_OPERATION(cfh, t2, IO(2));
    </trigger-semantics>
    <trigger-semantics>
EXEC_OPERATION(mulh, IO(1), IO(1), IO(2));
</trigger-semantics>
  </operation>

  <operation>
    <name>LEDS</name>
    <description>Control leds by writing a bit pattern. Bit 1 switches a led on and 0 switches off.</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
  </operation>

  <operation>
    <name>LDW4</name>
    <description>Loads vector of 4 words from memory.</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(3));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(4));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>STW4</name>
    <description>Stores 4 words to memory consecutively.</description>
    <inputs>5</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(stw, tmp, IO(3));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(4));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(5));



</trigger-semantics>
  </operation>

  <operation>
    <name>LDW2</name>
    <description>Loads two words from memory.</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>STW2</name>
    <description>Stores two words to memory.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(stw, tmp, IO(3));




</trigger-semantics>
  </operation>

  <operation>
    <name>STW8</name>
    <description>Writes 8 words to memory</description>
    <inputs>9</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(stw, tmp, IO(3));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(4));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(5));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(6));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(7));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(8));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(9));




</trigger-semantics>
  </operation>

  <operation>
    <name>LDW8</name>
    <description>Loads 8 words from memory.</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(3));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(4));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(5));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(6));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(7));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(8));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>BCAST2</name>
    <description>Copies data to two outputs</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <in element-count="1" element-width="32" id="1" type="RawData"/>
    <out element-count="1" element-width="32" id="2" type="RawData"/>
    <out element-count="1" element-width="32" id="3" type="RawData"/>
  </operation>

  <operation>
    <name>BCAST4</name>
    <description>Copies data to four outputs.</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <in element-count="1" element-width="32" id="1" type="RawData"/>
    <out element-count="1" element-width="32" id="2" type="RawData"/>
    <out element-count="1" element-width="32" id="3" type="RawData"/>
    <out element-count="1" element-width="32" id="4" type="RawData"/>
    <out element-count="1" element-width="32" id="5" type="RawData"/>
  </operation>

  <operation>
    <name>BCAST8</name>
    <description>Copies data to eight outputs.</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <in element-count="1" element-width="32" id="1" type="RawData"/>
    <out element-count="1" element-width="32" id="2" type="RawData"/>
    <out element-count="1" element-width="32" id="3" type="RawData"/>
    <out element-count="1" element-width="32" id="4" type="RawData"/>
    <out element-count="1" element-width="32" id="5" type="RawData"/>
    <out element-count="1" element-width="32" id="6" type="RawData"/>
    <out element-count="1" element-width="32" id="7" type="RawData"/>
    <out element-count="1" element-width="32" id="8" type="RawData"/>
    <out element-count="1" element-width="32" id="9" type="RawData"/>
  </operation>

  <operation>
    <name>LDH2</name>
    <description>Reads two half words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldh, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>LDHU2</name>
    <description>Reads two half words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldhu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>LDH4</name>
    <description>Reads four half words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldh, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDHU4</name>
    <description>Reads four half words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldhu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDH8</name>
    <description>Reads eight half words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldh, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(5));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(6));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(7));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(8));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDHU8</name>
    <description>Reads eight half words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldhu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(5));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(6));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(7));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(8));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDQ2</name>
    <description>Reads two quarter words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>LDQU2</name>
    <description>Reads two quarter words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldqu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>LDQ4</name>
    <description>Reads four quarter words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDQU4</name>
    <description>Reads four quarter words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldqu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDQ8</name>
    <description>Reads eight quarter words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(5));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(6));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(7));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(8));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDQU8</name>
    <description>Reads eight quarter words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldqu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(5));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(6));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(7));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(8));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>STH2</name>
    <description>Stores two half words to memory</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(sth, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(sth, tmp, IO(3));
</trigger-semantics>
  </operation>

  <operation>
    <name>STH4</name>
    <description>Stores four half words to memory</description>
    <inputs>5</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(sth, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(sth, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>STH8</name>
    <description>Stores eight half words to memory</description>
    <inputs>9</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(sth, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(sth, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(5));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(6));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(7));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(8));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>STQ2</name>
    <description>Stores two quarter words to memory</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(stq, tmp, IO(3));
</trigger-semantics>
  </operation>

  <operation>
    <name>STQ4</name>
    <description>Stores four quarter words to memory</description>
    <inputs>5</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(stq, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>STQ8</name>
    <description>Stores eight quarter words to memory</description>
    <inputs>9</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(stq, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(5));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(6));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(7));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(8));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>ECC</name>
    <description>Execution cycle counter. Free running counter that counts execution cycles i.e. cycles when reset and global lock are not active. Handy for profiling hardware execution.
ISS behavior will return the current cycle count.
Input operand is discarded.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>LCC</name>
    <description>Lock cycle counter. Free running counter that count global lock cycles. On hardware, reset most probably zeroes the counter. ISS behavior will always return zero. Handy for profiling hardware execution.
Input operand is discarded.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>SELECT</name>
    <description>Select one of two values</description>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="RawData"/>
    <in element-count="1" element-width="32" id="2" type="RawData"/>
    <in element-count="1" element-width="32" id="3" type="UIntWord"/>
    <out element-count="1" element-width="32" id="4" type="RawData"/>
    <trigger-semantics>
    </trigger-semantics></operation>

  <operation>
    <name>CHS</name>
    <description>Convert half to short</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
  </operation>

  <operation>
    <name>CHSU</name>
    <description>Convert half to short unsigned</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>CSH</name>
    <description>Convert short to half</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
  </operation>

  <operation>
    <name>CSHU</name>
    <description>Convert short to half unsigned</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
  </operation>

  <operation>
    <name>SLEEP</name>
    <description>Puts the core to sleep (global lock) until an external signal wakes it up. The simulation model waits for a POSIX signal SIGUSR1.</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <side-effects/>
    <in element-count="1" element-width="1" id="1" type="RawData"/>
  </operation>

</osal>
