#!/usr/bin/python
import getopt, sys, os, time, signal, tempfile, subprocess
        
def runWithTimeout(command, timeoutSecs, inputStream = None, verbose = False):
    """
    Runs the given process until it exits or the given time out is reached.

    Returns a triplet of which first value tells whether exited without timeout,
    second gives the process' output from stdout as a string, third the stderr
    """
    
    timePassed = 0.0
    increment = 0.01
    
    stderrFD, errFile = tempfile.mkstemp()
    stdoutFD, outFile = tempfile.mkstemp()

    # runs command in new shell, returned process is the created shell, not pid of the
    # command that is ran in the new shell.
    process =  subprocess.Popen(command, shell=True, stdin=subprocess.PIPE,
                                stdout=stdoutFD, stderr=stderrFD, close_fds=False)
    
    if verbose:
        print "Process.pid " + str(process.pid)
                
    if process == None:
        print "Could not create process"
        sys.exit(1)

    try:
        if inputStream is not None:
            for line in inputStream:
                process.stdin.write(line)
                process.stdin.flush()

        while True:
            status = process.poll()
            if status != None:
                # Process terminated succesfully.            
                stdoutSize = os.lseek(stdoutFD, 0, 2)
                stderrSize = os.lseek(stderrFD, 0, 2)

                os.lseek(stdoutFD, 0, 0)
                os.lseek(stderrFD, 0, 0)

                stdoutContents = os.read(stdoutFD, stdoutSize)
                stderrContents = os.read(stderrFD, stderrSize)

                os.close(stdoutFD)
                os.remove(outFile)
                os.close(stderrFD)
                os.remove(errFile)

                if verbose:
                    print "Command was executed successfully."
                                               
                return (True, stdoutContents, stderrContents)

            if verbose:
                print ("Running command: " + command +
                       " timePassed: " + str(timePassed) +
                       " limit: " + str(timeoutSecs))
        
            if timePassed < timeoutSecs:
                time.sleep(increment)
                timePassed = timePassed + increment

            else:
                # Simulation time out, kill the simulated process.
                stdoutSize = os.lseek(stdoutFD, 0, 2)
                stderrSize = os.lseek(stderrFD, 0, 2)

                os.lseek(stdoutFD, 0, 0)
                os.lseek(stderrFD, 0, 0)

                stdoutContents = os.read(stdoutFD, stdoutSize)
                stderrContents = os.read(stderrFD, stderrSize)

                os.close(stdoutFD)
                os.remove(outFile)
                os.close(stderrFD)
                os.remove(errFile)
            
                os.kill(process.pid, signal.SIGTSTP)
                if verbose:
                    print "Timeout occured."
                           
                return (False, stdoutContents, stderrContents)
            
    except:
        try:
            # Simulation time out, kill the simulated process.
            stdoutSize = os.lseek(stdoutFD, 0, 2)
            stderrSize = os.lseek(stderrFD, 0, 2)

            os.lseek(stdoutFD, 0, 0)
            os.lseek(stderrFD, 0, 0)

            stdoutContents = os.read(stdoutFD, stdoutSize)
            stderrContents = os.read(stderrFD, stderrSize)

            os.close(stdoutFD)
            os.remove(outFile)
            os.close(stderrFD)
            os.remove(errFile)
        except:
            pass
        
        # We give SIGSTPT instead SIGKILL to child process, because SIGKILL only kills given PID.
        # Popen command actually opens new shell and runs requested command in there so SIGKILL would
        # kill only the shell and leaves child command running background.
        os.kill(process.pid, signal.SIGTSTP)

        if verbose:
            print "Interrupted by user."
            
        return (False, stdoutContents, stderrContents)
            

def main():
    opts, args = getopt.getopt(sys.argv[1:], "v")

    if len(args) < 2:
        print 'Usage: exec_max_time [-v] <time> <command>'
        print "e.g. exec_max_time -v 10 'ls -la'"                
        exit(0)

    verbose = False
    if ('-v','') in opts:
        verbose = True
    
    exitStatus,output,error = runWithTimeout(args[1], float(args[0]), verbose = verbose)

    sys.stdout.write(output)
    sys.stderr.write(error)
    if exitStatus == False:
        sys.exit(1)
    else:
        sys.exit(0)

if __name__ == "__main__":
    main()
