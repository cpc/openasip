\documentclass[a4paper,twoside]{tce}

\usepackage{pslatex}

\begin{document}
\author{Andrea Cilio}
\title{TTA Instruction Scheduler}
\ver{0.16.1}
\firstday{12.07.2005}
\lastday{23.02.2006}
% id number in S- sequence
\docnum{024}
% draft/complete/committed
\state{draft}

\maketitle



\chapter*{Document History}

\begin{HistoryTable}

  0.1 & 12.07.2005 & A. Cilio &
  Very incomplete draft.\\
  0.2 & 14.07.2005 & A. Cilio &
  Added information on resource manager, node states.\\
  0.2.1 & 19.07.2005 & A. Cilio &
  Minor corrections. Added Operation Generator.\\
  0.3 & 21.07.2005 & A. Cilio &
  Revised module architecture. Other additions.\\
  0.4 & 22.07.2005 & A. Cilio &
  Completed module architecture revision, details on core modules.\\
  0.5 & 25.07.2005 & A. Cilio &
  Partial revision of resource manager module.\\
  0.6 & 28.07.2005 & A. Cilio &
  Completed chapter ``System Overview''. Additions to program
  representation. \\
  0.7 & 01.08.2005 & A. Cilio &
  Completed several chapters on module architectures. Partial reorganisation
  of text.\\
  0.8 & 03.08.2005 & A. Cilio &
  More on modules: scope, selector, scheduling algorithm. Added pending
  issues. Corrections.\\
  0.8.1 & 04.08.2005 & A. Cilio &
  Rewritten graph edge specification and pending issues.\\
  0.8.2 & 18.08.2005 & A. Cilio &
  Various clarifications on passes. Spelling corrections.\\
  0.8.3 & 19.08.2005 & A. Cilio &
  Clarified registration mechanism. Minor changes.\\
  0.9   & 25.08.2005 & A. Cilio &
  Moved interface details to design document. Added: framework helper
  objects, resource builder.\\
  0.10  & 05.09.2005 & A. Cilio &
  Reorganisation, parts moved to design document. Revised chapters 3, 4, 5.
  Added: role of node as assignment request, resource brokers.\\
  0.11  & 17.09.2005 & A. Cilio &
  Complete redesign of resource construction.\\
  0.11.1 & 20.09.2005 & A. Cilio &
  Added diagram. Spelling correction and minor changes.\\
  0.12   & 02.10.2005 & A. Cilio &
  Rejected idea of separate module for plug-in services.\\
  0.13   & 12.10.2005 & A. Cilio &
  Revised responsibilities of front-end and user interfaces.\\
  0.13.1 & 18.10.2005 & A. Cilio &
  Clarified and refined role of logging facility.\\
  0.14   & 14.11.2005 & A. Cilio &
  Reintroduced plug-in abstraction layer. Minor changes.\\
  0.15   & 01.12.2005 & A. Cilio &
  Maintenance: how to add multi-module passes.\\
  0.15.1 & 30.12.2005 & A. Cilio &
  Moved edge pending issue to design document.\\
  0.16   & 23.02.2006 & V. Guzma &
  Added information on bottom-up scheduling.\\
  0.16.1 & 23.02.2006 & A. Cilio &
  Minor corrections.\\
\end{HistoryTable}


\tableofcontents



\chapter{INTRODUCTION}

\section{Purpose and Scope}

This document describes the software architecture of the retargetable TTA
instruction scheduler of the TCE toolset (Scheduler). The focus of this
document is on the high-level design of the Scheduler: its modular structure
and the functional specifications of each module. Only \emph{core} modules,
which contribute directly and are necessary to scheduling activity are
described in this document. Other modules, which carry out useful code
analysis and transformation passes, and are tightly integrated to the
Scheduler, are briefly mentioned. The reader is referred to ``Backend Code
Transformation Passes'' design document [[to define]] for these modules. For
each core module, dependencies and communication with other core modules are
described.

\section{Definitions}

\begin{description}
\item[Move]%
  Programmed data transport on a transport triggered architecture.
\item[Node]%
  The minimum program element in the program representation (a move, in case
  of a bus-programed TTA) that the Scheduler handles as an atomic unit.
\item[Resource]%
  A hardware component of the target TTA processor that can be used to carry
  out part of the program's activity.
\item[Resource Allocation]%
  Determining whether a resource can be assigned to a program element.
\item[Resource Assignment]%
  Reserving a resource to a program element (move, variable, operation,
  \ldots) for a given number of cycles.
\item[Result Move]%
  Move that reads the result of an operation from a port of a function unit.
\item[Scheduler]%
  The retargetable TTA instruction scheduler of the TTA templated
  architecture.
\item[Scheduling (general)]%
  The overall process of mapping a program to a given target architecture.
\item[Scheduling (proper)]%
  Placing instruction elements (in a bus-programmed TTA, moves) into
  instruction slots.
\item[(scheduling) Scope]%
  A part of the program whose moves are evaluated, processed and scheduled
  in the same phase. During scheduling, moves are not moved across scope
  boundaries.
\item[Trigger Move]%
  Move that writes a port of a function unit and thereby initiates a
  new operation on that unit.
\end{description}

\section{Acronyms and Abbreviations}

\begin{tabular}{p{0.15\textwidth}p{0.85\textwidth}}
API   & Application Programming Interface.\\
CLI   & Command Line Interface.\\
FU    & Function Unit.\\
GUI   & Graphical User Interface.\\
IU    & Immediate Unit.\\
MAU   & Minimum Addressable Unit (of a memory address space).\\
MOM   & Machine Object Model.\\
OSAL  & Operation Set Abstraction Layer.\\
POM   & Program Object Model.\\
RF    & Register File.\\
TCE   & TTA Codesign Environment. \\
TPEF  & TTA Program Exchange Format.\\
TTA   & Transport Triggered Architectures. \\
\end{tabular}



\chapter{SYSTEM OVERVIEW}

This chapter gives an in-depth overview of the Scheduler modular
architecture.

\section{``Philosophy of Design''}

The Scheduler is not a monolithic program, but rather a sort of ``skeleton''
on which different cooperating modules can be attached at run time.
%
\begin{figure}[tb]
\centerline{\psfig{figure=eps/SchedulingChain.eps,width=0.75\textwidth}}
\caption{Scheduling chain and dependencies between scheduler front-end and
  the modules that implement passes.}
  \label{fig:sched-overview}
\end{figure}
%
Figure~\ref{fig:sched-overview} depicts the high-level organisation of the
Scheduler application.
%
The top-level component of the Scheduler is the scheduler front-end module.
Its main task is to load and launch modules that implement the passes of the
scheduling and code transformation chain.

A pass may be implemented as a group of modules that cooperate together or
as a single module. In this first case, the scheduler front-end loads all the
modules that form the pass and launches the main module.

Modules can be divided in two groups: \emph{core} modules, which directly
contribute to the scheduling process proper (mapping unscheduled code to a
target processor architecture) as defined, in its broad lines, by the
framework, and \emph{generic} modules, which usually implement code analysis
and transformation passes.
%
There are no restrictions on the activity performed by modules that
implement generic passes. Usually, the activity is reflected in
modifications of the target program (for example, assignment of processor
resources of scheduling of the instructions), but a module could just, for
example, carry out a code analysis pass and then report to an output file
the results.
%
There are no restriction in the scheduling pass proper either, but the
Scheduler provides a scheduling framework as basis for developers who wish
to take advantage of it. The framework defines a number of core modules.
%
Each type of core module has a well-defined interface and can be replaced by
other modules that implement the same interface. See
Section~\ref{sec:core-modules} for details.

All modules that cooperate to carry out a pass (be it core modules or
modules of a generic pass) are dynamically linked together and communicate
via a C or C++ function call API.
%
Modules from different passes communicate via domain or Scheduler-specific
object models (typically, the object models of the target program).
%
See Section~\ref{sec:mod-comm} for more information on module communication
and module ordering constraints.

In addition to a set of interfaces for core modules and the overall modular,
dynamic architecture, the scheduling framework defines a number of object
hierarchies: the program representation (described in
Chapter~\ref{ch:ProgramRepresentation}), the resource model and the resource
manager (described, respectively, in Chapter~\ref{ch:ResourceModel} and
Chapter~\ref{ch:ResourceManager}).

Finally, the framework provides generally useful services that can be used
by any client module of the Scheduler. Chapter~\ref{ch:Services} describes
the available services.

\section{Core Modules of Scheduling Framework}
\label{sec:core-modules}

\begin{figure}[tb]
  \centerline{\psfig{figure=eps/SchedulingOverview.eps,scale=0.4}}
  \caption{Scheduling pass inputs and outputs.}
  \label{fig:scheduling-io}
\end{figure}
%
The core modules implement the part of the scheduling framework that
performs mapping of unscheduled code to a target architecture (scheduling
and resource assignment, in practice). Figure~\ref{fig:scheduling-io}
depicts a simplified diagram of the main interactions of the scheduling pass
its input/output object models. The program graph, a standard program
representation, is optional: a scheduling pass can work directly on the input
program object model.

The developers of a scheduling pass are not obliged to follow the modular
architecture and the API defined by this the scheduling framework. They may
partially or completely ignore this architecture and define their own.
%
For example, a developer could integrate the scope selector and the node
selector into a single module, or implement a scheduling pass as an
internally managed hierarchy of modules (see
Section~\ref{sec:structured-modules}).

The scheduling framework defines the following types of core modules:
\begin{enumerate}
\item %
  Scheduler controller (main module).
\item %
  Scope selector.
\item %
  Selector.
\item %
  Resource manager.
\item %
  Scheduling algorithm.
\end{enumerate}

One of the motivations for the scheduling framework is that scheduling
algorithms can often be at least partly orthogonal to the scheduling scope.
The software framework is designed for list-based scheduling
algorithms\footnote{Two alternatives are possible, Top-Down scheduling -- all
sources of operation scheduled before operation, Bottom-Up scheduling -- all
destinations of operation scheduled before operation}.
Other algorithms are possible, but require an almost complete redesign of
the scheduling pass. However, most code analysis and transformation passes
should be reusable even if the scheduling pass is built completely ignoring
the scheduling framework.

\subsection{Scheduler controller}
The scheduler controller is the main module of the Scheduling pass proper.
It manages all the helper modules that make up the pass. The pass itself is
the core of the Scheduler application and, being a collection of plug-in
modules, can be also deployed as a component of other applications (for
example, Explorer).

\subsection{Scope Selector}
The scope selector is responsible for providing the next scheduling scope
(program region) to schedule. The program is segmented into scopes by a
helper class, the scope builder.

A scope represents a region the program that is handled by the scheduling
algorithm (in particular, by selector) as a single data dependency graph.
Within a scope, the scheduling order of moves is constrained only by
dependencies (mostly data dependencies and, to a much smaller extent,
control dependencies).

In some implementations, scope selector and (node) selector can be
integrated into one module.

\subsection{Selector}
The selector determines which node (or group of nodes) is the next candidate
to be scheduled. The candidates are given to client, usually the scheduling
algorithm. The candidate selection is based on data-flow constraints and,
possibly, heuristics.
%
The first time the selector is asked for a candidate, it will first get hold
on a scheduling scope and rearrange its nodes into a prioritised list. The
selector delegates scope selection to the scope selector.

\subsection{Resource Manager}
The resource manager is responsible for allocating and (possibly) assigning
processor resources to program elements. In its simplest use, the resource
manager answers questions like ``can move \emph{x}, with given resources
assigned to it, be scheduled in cycle \emph{y}?''.
%
The resource manager can and usually has a hierarchical structure, whereby
different specialised managers are responsible for a single class of
resources (for example, registers or transport-related resources), and a
top-level resource manager provides a unique access point for allocation
services.

\subsection{Scheduling Algorithm}
The scheduling algorithm is the module that controls the scheduling process
proper. Its main responsibility is to assign cycles to moves. Its
responsibility is to assign instruction slots (cycles) to program elements
and make sure that appropriate resources are assigned to each element. The
resource assignment task is mostly delegated to the resource manager.
However, the scheduler module can reject the assignments made by the
resource manager, or try its own resource assignments, and ask the manager
to validate (verify) them. Similarly, selection of scheduling candidates is
usually delegated to the selector, but the scheduler module can reject and
choose another (data-ready) candidate, if more than one is available.

\paragraph{Hierarchies of scheduling algorithms.}
A scheduling algorithm module may invoke other scheduling algorithms to
carry out (part of) instruction scheduling.
%
Interaction between scheduling algorithms invoked by a top-level
(structured) algorithm module occurs by reading and modifying the scheduling
state (context), which includes, for example, the operation selection pool,
dataflow information, resource allocation state.
Section~\ref{ssec:structured-modules-comm} describes this type of
inter-module communication in detail.

\subsection{Discussion}

The responsibility distribution between core modules, unfortunately, is not
so clear-cut.
%
\note{DISCUSS}

The scheduling algorithm module has the following potential capabilities:
\begin{enumerate}
\item %
  To reject a candidate node/ask another node. The danger is that some of
  the selector responsibility ``leaks'' into the scheduling algorithm:
  selection is not completely encapsulated in selector core module. At the
  extreme, the scheduling algorithm could use a selector just as an object
  to compute ready sets, and then take complete control of actual selection.
\item %
  To reject the earliest (or the latest in case of bottom-up scheduling)
  cycle in which the resource manager determines that the given node can be
  scheduled without resource conflicts (this may be an optimisation).
\item %
  To decide what to do when the resource manager earliest (latest) cycle
  exceeds the basic block length. One possibility is to enlarge the basic
  block to accommodate for the move; another is to try to move down (up) the
  move to successor basic blocks. This is an issue only for multi-block
  scheduling scopes, of course.
\item %
  To manage importing of moves. Importing could be delegated to a
  sophisticated selector, which looks for data-ready candidate outside the
  basic block boundaries. Even so, it is unlikely that the scheduler can
  completely ignore whether a candidate node it is trying to schedule in a
  given block belongs to it originally or has been imported. Importing moves
  implies several responsibilities:
  \begin{enumerate}
  \item %
    Checking for necessary duplication points.
  \item %
    Checking off-liveness.
  \item %
    When an imported definition is live in one of the alternative control
    paths, computing predicates to not break live variables.
  \item %
    Checking single-copy-on-a-path constraint.
  \end{enumerate}
\item %
  To handle additional code ``optimisation'' attempts that cannot be
  modelled as resource constraints. Operand sharing could be one such
  attempt, software bypassing another one.
%
  \note{DISCUSS PENDING \ref{ch:pending:operand-sharing}}
%
  The danger is that these optimisations become a very \emph{ad hoc} part of
  the algorithm.
\end{enumerate}

The resource manager module has rather clear-cut responsibilities. However,
allocation of resources can in some cases require a local code rewrite (for
example, splitting a constant move into a long immediate write template and
a move reading a long immediate register, or generating spill and restore
code on the fly). The resource manager can either inform the client that a
code rewrite may be required , or can delegate code rewriting to a helper
under its direct control. In either case (more so in the second one), the
resource manager becomes partly (indirectly) responsible for code
generation.

\section{Generic Pass Modules}

Generic modules implement code analysis and transformation passes that
improve, or sometimes enable, instruction scheduling. They form an
open-ended set that can be freely extended by the user-developer of the
Scheduler framework.

Generic modules are linked into the Scheduler at run time just like the core
modules. Mostly, generic modules are run before scheduling (pre-passes), but
certain passes may also run after scheduling (post-scheduling optimising
code transformations).

The generic modules provided with the base distribution of the toolset are
described in a separate document [[to define]]. See also the Scheduler
Functional Requirement Document~\cite{SchedulerSpecs} for a brief
description of the main external modules.

\section{Multi-module Passes}
\label{sec:multi-module}

A pass of the code transformation and scheduling chain may be implemented by
several cooperating plug-in modules. In this case, the modules form a
``team'' and are of two types: startable and helper.

If a module is startable, it means it is either a standalone module (it
implements a pass without any helper module) or is the main module of a
team.

Helper modules, on the other hand, can only be loaded as elements of a team
of cooperating modules. Helper modules cannot run on their own, but provide
a specific interface and a set of services for the other modules of the team
(including the main module). A helper module must be registered to a
startable (main) module or to a higher-level helper module to work.

The interface implemented by a helper module is unrestricted and
pass-specific; it needs to be known only to its main module and, possibly,
other helper modules in the team. This leaves complete design freedom to the
pass developers.

The standard scheduling pass provided with the toolset distribution is an
example of multi-module pass. The scheduler controller is the main module,
and all other core modules (resource manager, scope selector, selector,
scheduling algorithm) are helper modules.

\section{Structured Pass Modules}
\label{sec:structured-modules}

Certain pass modules may, internally, invoke other modules and let them
carry out (part of) the job. In order to invoke another module, a module
must first find it in the plug-in database, then load and link it into the
running executable. All this is possible using the services provided by the
plug-in services of the scheduler framework.

The number and type of modules internally invoked by another module is
completely unrestricted.\footnote{
%
  They could even be not part of the plug-in database, but this not very
  convenient, since it requires to develop a custom mechanism for loading
  and linking the modules.}
%
Unlike the modules of a multi-module pass, the modules invoked by a
structured module (be it a main module or a helper module) are not declared
in the configuration file and usually are hard-coded.
%
An example of structured module could be a scheduling algorithm module.

Structured modules can define two types of module hierarchies:
\begin{enumerate}
\item %
  Sequential hierarchy, where the top-level module invokes different
  sub-modules sequentially.
\item %
  Parallel hierarchy, where the top-level module runs two or more
  sub-modules concurrently (it spawns new processes).
\end{enumerate}

Inter-module communication in structured pass modules is potentially more
complicated than for other modules. See Section~\ref{sec:mod-comm} for
details.

\section{Standard Object Models of the Framework}

The framework provides few object models that ease design of new scheduling
passes. These are just ``default'' representations of the processor
resources and the target program (described, respectively, in
Chapter~\ref{ch:ResourceModel} and Chapter~\ref{ch:ProgramRepresentation}).
Properly speaking, these object models offer application-specific
``toolkit'' services rather than part of the software framework.

Any module implementing (part of) a pass can ignore these object models and
construct and maintain any structure necessary to support its work (for
example, the interference graph could be a suitable internal structure of a
register allocation algorithm based on graph coloring).

\section{External Modules}

External modules are not part of the Scheduler framework, but are
nevertheless linked into it and provide necessary but generic services.
There are two main types of external modules: domain modules and toolkit
modules.

\subsection{Domain Modules}

Most of Scheduler modules depend on one or more of the main domain object
hierarchies:
\begin{enumerate}
\item Machine Object Model.
\item Program Object Model.
\item Memory Model.
\item Operation Set Abstraction Layer.
\end{enumerate}

Although specific dependencies may vary widely from module to module,
typical modules that implement a pass of the code transformation and
scheduling chain depend at least from POM and, usually, on MOM. Also memory
model and OSAL may be required domain components, the former in order to
carry out memory access and dependency analysis, the latter in order to
carry out activity that depend on operation properties.

\subsection{Toolkit Modules}

A number of services provided by the Scheduler are implemented on top of
certain packages of the toolkit library, described in Toolkit Design
Document~\cite{ToolkitDesign}:
\begin{enumerate}
\item %
  The text-based User Interface module depends on the toolkit interpreter
  module.
\item %
  The plug-in toolkit module is used to load and link the pass modules at
  run time. This toolkit facility is not used directly. A wrapper provides a
  higher abstraction layer for clients of the scheduler framework that need
  to load modules.
\item %
  The graphical User Interface module of the Scheduler depends on the
  graphical library of TCE.
\item %
  The user interface modules that accept options from the standalone
  application command line need the toolkit option system.\footnote{
%
    Alternatively, a user interface may allow interactive setting of
    scheduling parameters.}
\item %
  The scheduler front-end needs the XML parser module of the toolkit library
  in order to read the scheduler configuration file.
\item %
  The tracking system needs the Toolkit filesystem and logging facilities to
  generate log output streams. The clients code responsible for generating
  the log messages should use the Toolkit text generation facility.
\end{enumerate}

\subsection{User Interface Modules}

The whole scheduler framework needs to be driven by a main module. This
module, if the Scheduler is deployed as standalone application, is the user
interface module. There can be different types of user interface modules.
This module is necessary in order to:
\begin{enumerate}
\item %
  Start the application, parse the command line options (if present), and
  pass settings to the scheduler front-end.
\item %
  Handle user interaction (either graphically or by means of console
  commands), including parameter setting before starting the scheduling
  process.
\end{enumerate}

The user interface module may be completely replaced by a non-interactive
driver. This is useful when the entire Scheduler is run as a part of a
larger system (for example, design space exploration or an integrated
graphical environment for co-design).

\section{Architecture of Databases}

In addition to the main domain object hierarchies, the Program Object
Model~\cite{POM-design}, the Machine Object Model~\cite{MOM-design}, and the
Program Dependency Graph~\cite{GraphDesign}, the Scheduler produces the
following data bases:

\begin{enumerate}
\item\label{itm:sched-config-db}%
  Scheduler configuration file.
\item\label{itm:sched-log-db}%
  Scheduler log file.
\item\label{itm:sched-hw-db}%
  Processor resource database.
\end{enumerate}

Only items (\ref{itm:sched-config-db}--\ref{itm:sched-log-db}) have a
required external (persistent) representation. The processor resources are
usually implemented as internal objects. Some implementations may have a
persistent form, but this is not a requirement.

For the information contents of databases with required persistent
representation, the reader is referred to~\cite{SchedulerSpecs}, Chapter~5
``Databases''.

\subsection{Scheduler Configuration File}

The scheduler configuration file controls which passes are loaded and run
during the scheduling process. It consists of a list of entries, each
declaring one pass of the code transformation and scheduling chain.
%
The format of this file is specified in the Scheduler Functional Requirement
Document~\cite{SchedulerSpecs}.

Internally, the configuration file data is converted into an object
hierarchy called scheduling plan.

\subsection{Scheduler Log File}

The scheduler log file describes the scheduling process at varying levels of
detail. By means of this log file, it should be possible to precisely track
the scheduling process.
%
The format of the log file is specified in the Scheduler Functional
Requirement Document~\cite{SchedulerSpecs}.

\section{Input and Output}
\label{sec:scheduler-io}

\begin{figure}[tb]
\centerline{\psfig{figure=eps/MainInputOutput.eps,%
    angle=-90,clip,trim=40 0 150 0,scale=0.50}}
    \caption{Main inputs and outputs of Scheduler.}
  \label{fig:scheduler-io}
\end{figure}

At a high level of abstraction, the entire scheduler framework can be seen
as a ``black box'' that reads and writes data files.
%
Figure~\ref{fig:scheduler-io} depicts this point of view and shows the main
input and output files involved in the scheduling process. Most files are
read by the scheduler front-end module, which is responsible for setting up
the framework environment and the object models used by the modules of the
scheduling chain.

The main input data files are: TPEF and ADF (handled by domain library), and
Scheduler configuration (handled directly by the scheduler front-end module).
Another important input is the database of plug-in modules, which is searched
for the modules specified in the configuration file.

The main output data file is TPEF itself. TPEF output is under direct
control of the modules of the scheduling chain. A pass can write out a
(usually modified) TPEF of the target TTA program or it can simply leave the
modified internal data structures (POM, program representation and even the
resource model) for the following passes.

Finally, an important source of input and output is user interaction. This
is handled by a user interface module. Any pass module can (and sometimes is
forced to) request user interaction through the user interface module.

\section{Module Communication}
\label{sec:mod-comm}

\begin{figure}[tb]
\centerline{\psfig{figure=eps/CommunicationOverview.eps,%
    scale=0.50,clip,trim=40 0 100 0,angle=-90}}
    \caption{Dependencies between modules of the Scheduler.}
  \label{fig:module-comm}
\end{figure}

Figure~\ref{fig:module-comm} depicts the dependencies and the interaction
between the main modules that make up the standalone Scheduler application
and other domain modules. The scheduler framework is controlled by a user
interface module. Other organisations, like a scheduler framework embedded
in the design space explorer [[add ref]], are possible.

\begin{table}
  \begin{tabular*}{1.00\textwidth}{|l|
      p{0.20\textwidth}|@{\extracolsep{\fill}}p{0.60\textwidth}|}
    \hline
    \emph{module type} & \emph{interaction type} &
      \emph{inter-module communication} \\
    \hline

    core & internal &
    Predefined standard API of Scheduler Framework, specific for the type of
    core module. This is inter-module communication only.\\
    \hline

    any & inter-pass &
    Domain object model (POM) and object models of Scheduler Framework
    (Program Representation, Resource Model).\\
    \hline

    generic & intra-pass &
    User-defined, pass-specific API of other modules that cooperate to
    implement the same pass.\\
    \hline

    structured & hierarchical &
    Domain object model (POM) and object models of Scheduler Framework
    (Program Representation, Resource Model). Other internal objects of the
    structured module.\\
    \hline

    structured & concurrent &
    (Copies of) domain object model (POM) and object models of Scheduler
    Framework (Program Representation, Resource Model). Possibly one of the
    copies is copied back or merged with the structured (top-level)
    module.\\
    \hline

    \hline
  \end{tabular*}
  \caption{Models of module communication.}
  \label{tab:module-comm}
\end{table}

Depending on the type of module considered, the mechanism to communicate
with other modules differs. Table~\ref{tab:module-comm} summarises the
various types of module communication and their properties.

\subsection{Intra-pass Communication between Generic Modules}
Within a single multi-module pass the developer is completely free to define
API and communication of the cooperating modules. The type-specific
interface of these modules is local to the pass implementation and hidden
from the rest of the Scheduler.

\subsection{Inter-pass Communication}
All modules may communicate by reading and modifying a number of object
models. Certain object models (MOM, POM) are defined in the domain library,
others (program representation, resource model) are scheduler-specific.

\subsection{Inter-module Communication between Core Modules}

\begin{figure}[tb]
\centerline{\psfig{figure=eps/CoreModuleOverview.eps,%
    clip,trim=0 380 0 40,scale=0.50}}
    \caption{Relations between core modules of the Scheduler framework.}
  \label{fig:core-comm}
\end{figure}
%
Figure~\ref{fig:core-comm} depicts the dependencies and the interactions
among the core modules and between them and the scheduler front-end. The core
modules communicate through class-specific interfaces.

This organisation is just a default setting. Other possibilities, like an
integrated scope and node selector, or a resource manager split in two
object hierarchies, or a scheduling algorithm split in two parts (local and
global, for example), are possible. Any custom organisation may more or less
depart from the standard interfaces set for the base framework.

\subsection{Inter-module Communication in Structured Modules}
\label{ssec:structured-modules-comm}

Communication between modules that are internally invoked by a structured
module (described in Section~\ref{sec:structured-modules}) has its own
special challenges.
%
Each invoked module performs part of the task for which the structured
module was chosen, and may modify the object models (POM or program
representation, resource model).

If the top-level module selects the best results from two or more ``slave''
modules, then there should be at least three copies of all the objects that
can be potentially modified by the slave submodules: one copy to preserve
original (pre-invocation) state, one copy with the current best result among
all the modules previously invoked, and one working copy for the slave
module currently invoked.

In case of concurrent invocation, the situation may be more complicated,
because there may be necessary one copy of all objects for each slave module
that is invoked in parallel with other modules.

A concrete example is a scheduling algorithm implemented as a structure
module.
\begin{enumerate}
\item %
  In case of sequential invocation, the top-level algorithm could delegate
  scheduling of one region to one of the ``slave'' algorithm. The top-level
  algorithm must pass all schedule context data that might be possibly
  affected to the slave algorithm. In case of scheduling algorithms that
  perform some amount of inter-procedure analysis, the context data must
  include the schedule state of the entire program.
\item %
  In case of concurrent invocation, the top-level algorithm ``fires''
  several scheduling algorithms at the same time. Each slave algorithm must
  have a copy of any context data it might possibly modify. Those parts of
  the context that are not going to be changed (for example, the resource
  allocation state of a completely scheduled and ``frozen'' region of the
  program) could be shared among all concurrent scheduling algorithms. After
  all algorithms have finished, the top-level algorithm chooses the best
  schedule and copy back the schedule context associated with it.
\end{enumerate}

\subsection{Implicit Ordering Constraints between Modules}

There are no explicit declarations of ordering or dependency constraints
between modules.

Any dependence between modules of different passes should be tested
internally by the module that depends on other modules. For example, a pass
that reorders data memory accesses in order to optimise performance of the
memory system could require data generated by a memory analysis pass. This
does not guarantee that a poorly designed module will crash (or worse,
malfunction but run to completion) because part of the data or the code
transformations it assumes have not been created or performed by previous
passes.

Similarly, dependencies between modules in the same multi-module pass are not
enforced by any formal mechanism of the Scheduler. Developers are bound to
defined a specialised API for helper modules to communicate with each other
and with the main module of a multi-module pass. This API implies an amount
of static type checking (a helper module loaded at run time must comply with
a predefined specialised interface), but other than that, even the pass
developer cannot ensure that a helper module specified in the Scheduler
configuration file and implementing the expected API also complies with the
expected behaviour.\footnote{
%
  This is a consequence of the framework flexibility: any developer can
  replace an existing helper module with a new implementation, as long as
  the specialised interface is correctly implemented.}



\chapter{PROGRAM REPRESENTATION}
\label{ch:ProgramRepresentation}

Instruction scheduling and powerful code transformations require a suitable
representation of the target program. The standard Program Object Model is
not convenient. The sequential ordering of operations is largely an artifact
and must be eliminated, whereas data and control flow dependencies, which in
a program are implied, should be represented explicitly.

This chapter describes the module of the Scheduler that implements the
program representation.

\section{Overview}

The program representation is a standard and fully implemented component of
the scheduler framework. The program representation is not just an
interface, so it is not part of the software framework proper, but rather a
domain-specific utility. Its main purpose is to provide a generally useful
object model of the target program. In addition, conversions between Program
Object Model and Program Representation are provided, for any clients that
need to build and work on the Program Representation, or need to ``commit''
modifications on the graph into the target POM.

The program representation is a graph and consists of three main objects:
nodes, [[supernodes]]
%
\note{DISCUSS: supernode?}
%
and edges. Other objects provide additional information: the program
operation (which represents a complete operation as originally found in
unscheduled code), the scheduling scope.

Even if the Scheduler framework provides a standard program representation,
the developers of Scheduler passes are not obliged to use it. It merely is a
convenient object model to ease development of scheduling algorithms that do
not depart too much from operation-driven, list-based scheduling approaches.

\section{Interfaces}

\subsection{Program Graph}

Main class of the program representation. It permits access to the building blocks of the graph: nodes, edges, [[supernodes]],
%
\note{DISCUSS: supernode?}
%
program operations.

In the simplest implementations, the program graph is not a graph at all,
but rather an ordered sequence of nodes. Thus, the most basic method offered
by a program graph is lookup of the node corresponding to a given move.

\subsection{Node}
\label{ssec:node}

The node is the smallest element of the program that can be
scheduled/processed in one step.\footnote{%
  Though often the minimal work step of a scheduling algorithm encompasses
  multiple tightly related nodes (for example, nodes corresponding to the
  moves of an operation).}
%
In the Scheduler framework, the node represents a move and its data
dependencies with other moves of the target program.

\paragraph{Node states.}

\begin{figure}[tb]
  \centerline{\psfig{figure=eps/NodeStates.eps,%
      scale=0.50,clip,trim=0 480 0 0}}
  \caption{Possible states of a node of the program representation.}
  \label{fig:NodeStates}
\end{figure}

A node has a rather complex state model, shown in
Figure~\ref{fig:NodeStates}. Initially, a node is usually assigned to an
unscheduled move. Such a node is minimally ordered (the only ordering
constraints are given by the incoming dependency edges in its graph) and has
no cycle assigned. A partially assigned node has some of its parts already
assigned to required processor resources, but has no cycle assigned to it.
This state is common during global scheduling, because often scheduling a
node will automatically determine (force) assignment of resources in other
unscheduled nodes. A fully assigned node is completely assigned to the
required resources, but still unordered (still no cycle assigned to it).
This state is rare and might even be impossible. A placed node has no
resources assigned to it, but it is already given a cycle within the
scheduling scope. In other words, it is already placed in a TTA
instructions, but no resource has been assigned to it. This state should be
rare and only temporary or required by very specific scheduling
optimisations. A partially scheduled node is a node assigned to a cycle and
with some of its parts already assigned to processor resources. (Assignment,
however, is not complete.) Finally, a scheduled node is placed in a TTA
instruction (it has been assigned a cycle) and has all required resources
assigned to it.

The node states for which a cycle and at least one resource is assigned can
be further split in two groups: valid and invalid. A node is in a valid
state if all its assigned resources are available in given cycle or are
already assigned to the node itself. A node has invalid state if at least
one of the processor resources that are assigned to it is not available
(already reserved to other program elements) in the given cycle.

\paragraph{Node as assignment request.}

The node class is not only necessary for the graph-based program
representation. Nodes are also the object that represents and carries basic
information about resource assignment requests. In other words, for a
resource manager, the node is interpreted as a set of interdependent
assignment requests:
\begin{enumerate}
\item %
  The node as a whole represents a bus request (activity: transport).
\item %
  The node source represents one of the following assignment requests:
  \begin{enumerate}
  \item %
    Operation Output: function unit and port (activity: reading an operation
    result).
  \item %
    Variable: register file and port (activity: reading a GPR).
  \item %
    Constant: either an in-line immediate slot or an immediate unit and port
    (activity: reading a constant).
  \end{enumerate}
\item %
  The node destination represents one of the following assignment requests:
  \begin{enumerate}
  \item %
    Operation Input: function unit and port (activity: defining an operation
    operand).
  \item %
    Variable: register file and port (activity: writing a GPR).
  \end{enumerate}
\end{enumerate}

Once assigned, the node terminals change type:
\begin{enumerate}
\item %
  Operation outputs become function unit output ports.
\item %
  Operation inputs become function unit input ports.
\item %
  Variables become RF read ports or RF write ports.
\item %
  Constants become in-line immediates (basically remain the same, just
  assigned to a bus slot) or IU read ports (plus a separate template-based
  immediate write action).
\end{enumerate}

\subsection{Edge}

Graph edges model any kind of dependency (ordering constraint) between nodes
of the program representation.

The following types of dependency edges are expected for the program
representation:
\begin{enumerate}
\item %
  Data dependence. Dependence due to definition-use of the same program
  variable.
\item %
  Control dependence. Dependence due to a control transfer between the
  transfer operation and all the instructions that follow the target
  instruction.
\item %
  Memory dependence. Dependence due to a store-load of the same memory
  location.
\item %
  Scheduling barrier dependence. A generic dependence to prevent reordering
  between two nodes.
%
  \note{DISCUSS: this type of catch-all could be problematic}
\item %
  Data anti-dependence. Dependence due to use-definition of the same program
  variable.
\item %
  Data output dependence. Dependence due to two definitions of the same
  program variable.
\end{enumerate}

\subsection{Scope}

A scope is an abstraction on top of the program graph that represents a
piece of the target program. Usually, the nodes in a scope have some common
properties (for example, are in the same procedure, belong to the same
natural loop body, or have the same control flow dependencies.

The interface of scope class allows to navigate through the nodes and edges
it contains, in particular:
\begin{enumerate}
\item %
  To navigate through boundary nodes, that is, nodes that have a dependency
  with nodes that are outside the scope.
\item %
  To navigate through all the input and output edges of the scope. An input
  edge is an edge coming from a node outside the scope; an output edge is an
  edge with a destination that lies outside the scope.
\item %
  {[[more services]]}
\end{enumerate}

\subsection{Scope Builder}

The scope builder takes an input program representation and subdivides its
nodes into groups called scopes. The scopes thus constructed are accessible
by means of a simple navigation interface.

\subsection{Program Operation}

% FROM MOVE MANUAL
% This class is mainly used as a place to store information about an
% operation as a whole. In addition to the data members, this class carries
% a set of flags that convey additional information about the operation
% (sometimes related to a specific node of the operation). All this
% information is needed by the scheduler to guide instruction selection and
% the scheduling process.


Instances of this class represent the operation carried out as result of
executing a group of related moves. Unlike the OSAL operation class,
instances of this class represent instances of operations in the target
program, not the ``idea'' or the general properties of an operation.

\begin{figure}[tb]
  \centerline{\psfig{figure=eps/ProgramOperationA.eps,scale=0.50}\hfill
    \psfig{figure=eps/ProgramOperationB.eps,scale=0.50}}
  \caption{Example of relation between program operation and its defining
    moves in sequential code (left) and parallel code(right). Thicker and
    thinner edges represent, respectively links between nodes and program
    operations and intra-operation dependencies.}
  \label{fig:program-op}
\end{figure}

Every property that is shared and independent of the specific move related
to the operation is encapsulated in this class. Because of TTA-specific
scheduling optimisations, an operation may be shared by many more than the
mere original moves that defined it in the unscheduled code. As
Figure~\ref{fig:program-op} shows, the moves of an operation, when globally
scheduled, may be spread and duplicated across several basic blocks.
Furthermore, due to software bypassing, a single node may be connected to
two different program operations.

\subsection{Operation Generator}

The operation generator is a factory. It generates fundamental operations
(see~\cite{SchedulerSpecs} for a list of fundamental operations and their
definition, and encapsulates details like how to create different operations
(or operation patterns) depending on the target architecture. For example,
the call operation may be emulated by a jump and explicit saving of the
return address. The factory takes care of generating the correct operation
pattern depending on the supported operation set.

Operations can be generated at two levels: as simple POM objects, or as node
sub-graph. In the latter case, moves do not have to be attached to the input
POM.

\section{Error Handling}



\chapter{RESOURCE MODEL}
\label{ch:ResourceModel}

This chapter describes a set of interfaces and guidelines for an object
hierarchy that models scheduling resources. An implementation of the
resource model, in combination with a resource manager (for which see
Chapter~\ref{ch:ResourceManager}), implements the resource assignment
function of a scheduling algorithm.


\section{Overview}

A scheduling resource is an abstraction that models scheduling constraints
independent of their origin (actual processor resource or other abstract
constraint). The advantage of this abstraction is that the clients of
resources (primarily the resource manager) can be designed with minimal
(that is, as little as possible) built-in knowledge of the specifics of each
type of resource. Each resource encapsulates any specific information
concerning a constraint under a common interface.

A resource model, unlike the machine object model, does not need to
exhaustively describe every aspect of the target machine. Instead, it must
represents the scheduling constraints in a form suitable for instruction
scheduling.
%
For example, a resource model could ignore unit ports: given their simple
many-to-one relation with sockets, it is sufficient to model socket usage.

The resource model is a hybrid component of the scheduler framework. It is
partially a software framework in the proper sense, because it defines
interfaces and general guidelines for modelling scheduling resources, but it
provides also implemented services (basic services shared by all resource
objects and common operations that can be performed on them).

\subsection{Types of Scheduling Constraints}

Not all scheduling constraints are, properly speaking, due to contention of
processor resources, but this, from the point of view of software
implementation, is irrelevant. The scheduling constraints can be grouped
into three types:
\begin{enumerate}
\item %
  Real hardware resource constraints (contention of limited available
  resources).
\item %
  Instruction encoding constraints.
\item %
  Scheduling-specific constraints (due to limitations of the algorithm or to
  conditions that must be satisfied in order to apply certain scheduling
  optimisations).
\end{enumerate}

For example, the socket of a TTA processor is a hardware resource of the
first type and, in normal conditions, can be assigned to no more than one
use per cycle.

Limitation or lack of multicasts (moves that write multiple destinations at
once) is an example of constraint of the second type.\footnote{
%
  Simple resource allocation and assignment algorithms could proceed in such
  a way that the possibility of multicasts is not even considered.}
%
Nothing fundamental in the processor hardware forbids a bus to fan out to
multiple input sockets, but the number of destinations is usually restricted
to one by the way buses are programmed: normally, a move can specify only
one destination port per cycle.

The constraints that must be satisfied in order to apply operand sharing are
an example of the third type. Operand sharing depends on a combination of
constraints related to processor resources and dataflow:
\begin{enumerate}
\item %
  Use (sharing) of the same  destination port of the same function unit.
\item %
  Equivalent\footnote{
%
    The source must represent the same value (with the same set of possible
    definitions).}
%
  source of the moves to share.
\item %
  At least one of the unshared inputs of the operation is
  triggering.\footnote{%
    Otherwise, the move considered for sharing would have to be the only one
    writing a triggering port. This means that sharing would prevent
    triggering of an operation, and would corrupt the program behaviour.}
\end{enumerate}
%
These constraints are not resources in the common sense of the word. The
dataflow-related condition in this example (equivalent source) should not be
modelled as a processor resource at all. The third condition might be
modelled by a rather abstract resource, a resource that represents the
condition ``at least one of the other inputs of this operation (not the
input to be shared) triggers''.

In conclusion,
%
\note{need to define clear separation of responsibilities and cooperation
  scheme between the core modules to address non-resource scheduling
  constraints}
%
a resource manager based on objects that model processor resource and
constraints is probably insufficient, alone, to cover the subtleties related
to instruction scheduling, especially if TTA-specific optimisations are
wanted.

\subsection{Construction of the Resource Model}

\begin{figure}[tb]
\centerline{\psfig{figure=eps/ResourceBuilder.eps,%
    scale=0.6,clip,trim=0 650 0 40}}
\caption{Construction of resource model.}
  \label{fig:resource-builder}
\end{figure}
%
The resource model package does not provide a predefined, complete mechanism
for resource building. It defines just an interface and few general
properties of resources (dependent and related resources). The properties of
concrete resource types, necessary for construction, depend on the machine
parts or scheduling constraints that the resource represent, and,
ultimately, on the implementation of the resource manager.

Concrete resource types should never initialise themselves with MOM objects
as input arguments, because the resource model should have no direct
dependence with MOM, as depicted in Figure~\ref{fig:resource-builder}.

The resource base class offers methods for initialising resource instances.
Any client of the resource model that is responsible for resource
construction (usually the resource manager or its helper classes) can use
these methods to initialise the static properties of a resource instance.

\section{Interfaces}

All resource objects share a common base interface. The specific behaviour
of a resource type is determined by the properties of the resource and its
implementation.

A single resource object models the state of a resource in all cycles of the
scheduling scope.
%
\note{PENDING: \ref{ch:pending:global-resource-manager}}
%
Clients can ask a resource whether it is available in a given cycle for an
assignment. The state of scheduling resources in any given cycle is
described by the following properties:
\begin{description}
\item %
  [inUse] This property tells whether this resource, in the given cycle, is
  in use. When a resource is in use, it may still be available for other
  assignments.
\item %
  [busy] This property tells that the resource is in use and completely
  unavailable for any other assignment in the given cycle. This property is
  a kind of shortcut; it means that the resource cannot be reused at all in
  given cycle, independent of which request of assignment is being tested.
  Conversely, when a resource is not busy, either it is free for any
  assignment or it could be reusable for certain assignment requests.
\end{description}

When a resource is not in use, it is always possible to assign it to any
compatible request. Whether a request is compatible or not with a given
resource is a test that is demanded to a higher level object, the resource
broker (see Section~\ref{ssec:ResourceBroker}).

In addition to state properties, resources have also static properties that
describe their relation with other resources of the target processor:
\begin{description}
\item %
  [dependent] Set of resources directly related to this resource by a
  dependency association. Dependent resources are grouped in subsets, by
  resource type. For every subset, at most one resource object is assigned
  whenever this resource is assigned. Dependencies are deterministic: given
  an assignment request, one and only one resource in each subset can be
  used.
%
  For example, depending on the input index of an operation assigned to a
  function unit, one and only one port is assigned to the operation input.

  A resource may depend on several other resources. Thus, if a dependent
  resource is in use, it does not follow that a given resource it depends
  from is in use too. For example, a given socket can be assigned as
  dependent resource of several unit ports (possibly from different units).

  A dependent resource is unassigned whenever the resource it depends from
  is unassigned. However, dependent resources may be reused like any other
  resource. Thus, a dependent resource is not necessarily freed when the
  resource it depends from is unassigned.

\item %
  [related] Set of resources directly related to this resource by a
  one-to-many association. Related resources are grouped in subsets of the
  same type. Whenever this resource is assigned to a request, at least one
  resource object in each subset must be assigned to the same request. If no
  related resource of a given type can be assigned it means that, even if
  this resource is available, it is not possible find a complete set of
  resources that can be assigned to the node. (Other assignments, not
  including this node, may be possible.)

  Only related resources resources need to be tested for assignment whenever
  this resource is in use. If a resource \emph{A} does not appear in the set
  of related resources of another resource \emph{B}, it means that it is not
  compatible (it is unrelated) with \emph{B}, so it should never be
  considered for allocation when \emph{B} is assigned.

  A resource usually has a restricted set of related resources for any given
  resource types. Clients of the resource object model can profit from the
  reduction of the set of possible resource candidates and speedup the
  search for an assignment.
%
  For example, the related set of a socket resource includes only the buses
  (or segments) that are connected to it.

  The ``related'' association is usually bidirectional (unless an
  implementation of the resource model seeks to trade off flexibility for
  speed). Several resources of the same or different type may be related to
  the same resource. If a resource can be reused, it is possible for it to
  be simultaneously assigned in combination with several resources, all
  related to it.
\end{description}

The resource interface provides operations for testing the properties
described above and navigate through the dependent and related subsets and
elements. In addition, the resource interface provides also operations for
clients that want to modify the resource state. It is possible to assign or
free the resource to a specific part of a node in a given cycle, or to
test whether the resource can be assigned (possibly reused).



\chapter{GENERIC MODULES}
\label{ch:GenericModules}

All plug-in modules of the scheduler framework share a common set of
properties and a base interface. This chapter describes these properties.

\section{Overview}

Plug-in modules implement passes of the code transformation and scheduling
chain. All modules are linked at run time before starting the scheduling
process.

The basic interface of a plug-in module does very little: it allows to
register and return references to the object models of the target program,
and to register helper modules.

If a plug-in module needs it, it can request a reference to the target
program object model (POM, program graph, or both). If the module is a
helper, its request will go to its parent module (which may be another
helper module, in case of nested hierarchy, or, more often, the main
module of the pass).

\subsection{Registration of Modules in Multi-module Passes}

When several modules are declared for a single pass, it means that the pass
is implemented by a \emph{team} of hierarchically organised modules. The
scheduler front-end must register all modules of the pass appropriately.
This is made possible by a simple and general mechanism that works as
follows: the scheduler front-end first finds which of the modules is the
main module; then, it registers all other (helper) modules into it.
Registration may work recursively: if the main module does not recognise one
of the helper modules, it just tries to forward the registration request to
each of the recognised helper modules it already has. If this fails, the
main module keep the pending module. Whenever a new module is successfully
registered to it, the main module tries to forward the registration request
to the new module for all pending modules. This process can in theory work
with a multi-level hierarchy. Only when the main module is started a
condition of pending module can produce an error condition.\footnote{DISCUSS:
For completeness, also removal and replacement of modules could be implemented.}

\section{Interfaces}

The most basic interface of a generic plug-in module allows to perform the
following operations:
\begin{enumerate}
\item %
  Request the scheduler front-end a reference to the target program (program
  object model or program representation).
\item %
  Provide a reference to the target program obtained by the scheduler
  front-end.
\item %
  Register another module as a helper controlled by this module.
\end{enumerate}

In addition, startable modules provide an operation for starting them up.
Internally, a startable module that controls helper modules will use their
specific interface to carry out part of its work. Helper modules, instead,
do not provide such interface.

The interface for registering helper modules needs to be (re)implemented
only by modules that implement (part of) a multi-module pass. For all other
modules, the default interface will be simply to report an error message.

\section{Error Handling}

\subsection{Incomplete Team of Plug-In Modules}

A main module should abort with error message if not all its expected helper
modules have been registered. Such situation is unlikely to be recoverable.
On the other hand, the scheduler frontend could simply skip the pass
implemented by an incomplete team of modules.

\subsection{Missing Plug-In Module}

The system can abort with error or simply ignore the case in which one of
the plug-in modules declared in the configuration file is not found. This
behaviour is controlled by a command line option of the Scheduler.

\subsection{Unknown Plug-In Module in Team}

A main module should abort with error message if one of the modules that is
expected to work in the team is not recognised by it nor by all other helper
modules registered to it. This error condition, however, is not confirmed
until all declared modules of the pass have been registered to the main
module.



\chapter{SCHEDULER FRONT-END}
\label{ch:SchedulerFront-end}

This chapter describes the top-level fixed component of the Scheduler.

\section{Overview}

The scheduler front-end is the top-level component of the Scheduler. It
provides the following services:
\begin{enumerate}
\item %
  Input and output (configuration file, input data files).
\item %
  Interfacing with the user (via a separate module, see
  Chapter~\ref{ch:ui-modules}).
\item %
  Setup of the domain and scheduler-specific object models.
\item %
  Setup of the scheduling plan and control of the code transformation and
  scheduling chain.
\end{enumerate}

The scheduler front-end is a fixed component of the scheduler.

\section{Interfaces}

The scheduler front-end provides the following interface:
\begin{enumerate}
\item %
  Return the program object model (POM) of the target program.
\item %
  Return the scheduler-specific representation (see
  Section~\ref{ch:ProgramRepresentation}) of the target program.
\item %
  Load a plug-in module with a given name.\note{Remove or replace a plug-in
module}
\end{enumerate}




\chapter{SCHEDULER CONTROLLER}
\label{ch:SchedulerController}

This chapter describes the general architecture of the top-level plug-in
modules that control a specific instruction scheduling algorithm.

\section{Overview}

The scheduler controller is the main module of a team of plug-in modules
that implement the main pass of the Scheduler, that is, instruction
scheduling proper.

The scheduler controller is one of the core modules of the instruction
scheduling pass. The other modules are helpers, briefly described in
Section~\ref{sec:core-modules}, are loaded by the scheduler front-end from
the configuration file and registered into the scheduler controller.

In fact, the scheduler controller does not have to work with a fixed group
of helper modules. There may be several implementations of each type of core
module, and some of these implementations may be compatible (in the sense
that they are interchangeable) without the scheduler controller even
noticing it.

So in a sense, a single scheduler controller is not for a specific
scheduling pass, but for all passes that can be defined by replacing
compatible helper modules for each type of core module.

The scheduler controller has the following responsibilities:
\begin{enumerate}
\item%
  Make sure that scheduling scope objects are created from the program
  representation by using the construction services provided by the Scope
  Selector module.
\item%
  Hand over scheduling scopes to the scope selector class (or just let the
  scope builder do it).
\item%
  Put selector and scope selector in communication.
\item%
  Put scheduling algorithm and resource manager in communication.
\end{enumerate}

The scheduling pass delivered with the toolset implements a simple
list-based algorithm with a dataflow-based priority heuristic for selection
of operation, but its helper modules could be replaced without affecting the
scheduler controller.

\section{Interfaces}

The interface of the scheduler controller, as seen by the scheduler
front-end, is just the base interface of startable plug-in modules.

In addition to the standard interface, a specific scheduler controller may
provide additional operations to let it communicate with the scheduling
algorithm modules of its class. This interface is completely unrestricted
and left to developers of specific scheduling passes.



\chapter{RESOURCE MANAGER}
\label{ch:ResourceManager}

The resource manager keeps track of which resources are available for
scheduling, assigns and helps assigning resources to program elements.

The concept of processor resource is just one possible way for modelling
scheduling constraints that do not depend on data and control flow. This
chapter describes the general features of a resource manager module which
uses the processor resource abstraction.

\section{Overview}

The primary purpose of the resource manager is to verify when processor
resources are available for a given program element (a move or part of a
move). In order to accomplish this task, the resource manager must keep
track of processor resource utilisation in each cycle of the program.

The resource manager, in addition, can assign available resources, but this
is not necessary; assignment can be carried out by other components of the
Scheduler (for example, the scheduling algorithm). When clients perform
resource assignments, the resource state under resource manager control
needs to be kept up to date.
%
If resources are assigned by a client, the resource manager can verify that
the resource assignments to the nodes are valid.

The standard resource manager delivered with the toolset is based on a
general abstraction of the resource concept (see
Chapter~\ref{ch:ResourceModel}), but any implementation that complies with
the interface of the resource manager is a valid replacement that should
work with other core modules compatible with the scheduling framework.

\subsection{Scopes and Resource Management}

The resource manager should manage at least the scope currently handled by
the selector, if not the entire scheduling unit.

In a scope that encompasses
control flow dependencies, the resource manager should span multiple basic
blocks. For example, if a client requests the minimum or maximum cycle in which
a given
candidate node can be assigned, the manager could return a cycle that
belongs to a basic block different from the basic block of the minimum or
 maximum cycle given by the client.
%
\note{PENDING: \ref{ch:pending:global-resource-manager}}

\subsection{Assignment Requests}

Assignment and allocation requests sent to the resource manager use the node
(see Section~\ref{ssec:node}) as primary abstraction.
%
The node, however, is not specific enough to encapsulate certain details of
requests for allocation or assignment of a specific resource. For example, a
node is not univocally associated with an operation (there may be two
operations related to a node), or with one variable (both source and
destination may be variables). The solution to this problem is described in
the Scheduler Design Document~\cite{SchedulerDesign}.

\subsection{Resource Brokers}
\label{ssec:ResourceBroker}

Resource brokers are higher-level entities responsible for managing groups
of resource objects of the same type. There is a broker for each type of
resource that may be directly allocated or assigned to part of a node and
for each type of assignment. For example, there should be a broker for
managing reading of GPR's and another for managing writing of GPR's.

A broker refactors the properties shared by all resources of the same type
and provides a common access point for clients that need to allocate or
assign a specific type of resources. Finally, a broker maintains the
necessary links between the resource objects and (when applicable) the
components of the machine object model.

\section{Interfaces}

\subsection{Resource Manager}

The basic set of services provided by the resource manager module
communicate with clients by means of nodes of the program representation and
all types of components of the Machine Object Model (which ultimately are
what the resource manager must assign to nodes).
\begin{enumerate}
\item %
  Can given node be assigned without resource conflicts in given cycle?
\item %
  Assign resources for a given node in given cycle.
\item %
  Free all resource assignments of a given node.
\item %
  What is the earliest or latest cycle, for given node and, optionally, a
  given start cycle, where all required resources can be assigned to it? (If
  no start cycle is given, beginning (or end) of scope is taken.)
\end{enumerate}

In addition to these primary operations, the resource manager may provide a
method to support external, direct assignment of processor components. In
this case, the client that performs the assignments must ask the resource
manager to update its state with the externally forced assignments.

The resource manager may provide more sophisticated services for clients
that want finer control of the resource assignment process. See ``Additional
services of resource manager'' in Chapter~\ref{ch:extensions}.

\section{Error Handling}

\subsection{Reuse of Free Resources}
It doesn't make sense to ask a resource for reuse when the resource is not
in use. In this case, an error condition should be signalled by an
exception.

\subsection{Assignment Failure}
If a request for resource assignment fails, the resource manager should
signal an error condition by means of an exception.



\chapter{SCOPE SELECTOR}
\label{ch:ScopeSelector}

This chapter describes the architecture of the core module of the scheduling
framework that defines the scheduling scopes of the target program and
returns them in a specific order.

\section{Overview}

The scope selector has the following responsibilities:
\begin{enumerate}
\item %
  Construct the scheduling scopes of the target program (from either one of
  the two given object models). A standard scope builder is provided as
  utility in the program representation module.
\item %
  Return, upon request, the next scope that should be scheduled. The order
  in which scopes are returned is influenced by optional parameters, and
  should go from ``most critical'' to ``less critical'' in terms of
  scheduling priority.
\item %
  {[[either explicitly mark a scope as ``done'' or automatically update the
  scope selector]]}
\end{enumerate}

[[to do: clarify status of the procedure. Could be a super-structure above
scope? or generalise the procedure concept as a super-boundary of scheduling
where also live ranges and other multi-cycle spanning assignments are
summarised]]

\section{Interfaces}

The scope selector provides the following interface:
\begin{enumerate}
\item %
  Build the scheduling scopes of given target program.
\item %
  Return the next scope to schedule.
\end{enumerate}



\chapter{SELECTOR}
\label{ch:Selector}

This chapter describes the architecture of the core module of the scheduling
framework that selects nodes that are valid candidates for a scheduling
attempt from a given scheduling scope.
\section{Overview}

The selector is a plug-in module that takes as input a scheduling scope and
outputs, on request, groups of nodes that are valid candidates for
scheduling.

The selector looks among all nodes that have not been placed for candidates.
If a node is placed, no matter whether some of its resources are not yet
assigned, then it is considered ``scheduled'' from selector's point of view.

Internally, the selector cooperates with the scope selector: when it runs
out of nodes (that is, the current scope is entirely scheduled) it asks the
scope selector for another scope and then returns the first group of
candidates from the new scope.

Clients can modify (assign, schedule) nodes of the target program
representation without having obtained the nodes from the selector. The
selector must keep its internal state up to date with the current scheduling
state of the scope it controls.

\subsection{Group of Candidates}
The selector communicates its choice for node candidates by means of a
structure called (candidate) group. A group consists of one or more nodes
that have no cycle assigned. Each node candidate is associated (not
assigned!) with a cycle. This is the minimum (or maximum cycle in which,
given the dependencies defined in the program representation, the node could
be scheduled.

Nodes may be grouped according to assumptions that the selector does about
the scheduling algorithm. For example, if the scheduling algorithm requires
to schedule all moves of the same operation in one step, then the groups
should include all nodes corresponding to such moves.

\section{Interfaces}

The main operation provided by the interface is very simple: request the
next group of candidates for scheduling. The selector always recomputes any
necessary state information about the controlled scope in order to return
candidates that are based on up to date state.

In addition to the main operation, the selector provides an interface to
fine-tune and control more accurately its work:
\begin{enumerate}
\item %
  Ask what is the current inter-scope mode and whether the other mode is
  supported. When in inter-scope mode, the selector automatically asks the
  scope selector for a new scope. In this way, the client scheduling
  algorithms can be totally unaware of scope boundaries. If not in
  inter-scope mode, the selector responds to a new request with an empty
  group. In this case, it is client's responsibility to register another
  scope into the selector.
\item %
  Set or reset inter-scope mode.
\item %
  Register a new scope into selector. Usually, this operation is direct
  responsibility of the selector, which obtains the scope from the scope
  selector, but a client (notably, the scheduling algorithm) can take over
  this responsibility.
\item %
  Forget current scope (even if only partially scheduled). This operation,
  in combination with registration of a new scope (described above) gives
  complete control on the working scope.
\item %
  Tell whether this selector can compute complete prioritised lists of
  candidates.
\item %
  Obtain a list of all possible groups of candidates for current scheduling
  step in a priority order. This way, the client is able to try different
  choices of candidates (possibly in parallel). Optionally, the client could
  give the maximum number of candidates wanted in the list. This could, in
  some implementations, speed up the work of the selector.
\end{enumerate}

\section{Error Handling}

\subsection{Unavailable Capability}
The selector should signal an error condition with an exception if a client
requests an action that is not supported by the given implementation of
selector:
\begin{enumerate}
\item %
  Request to change inter-scope mode to an unsupported mode.
\item %
  Request a prioritised list of candidates.
\end{enumerate}



\chapter{SCHEDULING ALGORITHM}
\label{ch:SchedulingAlgorithm}

This chapter describes the architecture of the core module of the scheduling
framework that implements the core of a scheduling algorithm.

\section{Overview}

The scheduling algorithm module is the part of a scheduling pass that takes
the high level decisions and directs the scheduling process as a whole.
Usually (but not necessarily) the scheduling algorithm delegates to selector
and resource manager a significant part of the work. What is left to
scheduler is: trying different cycles for given candidate nodes, decide
which cycle is most profitable or reject and try another candidate node,
decide whether a set of resource assignments is acceptable or should be
somehow modified.

\section{Interfaces}

The scheduling algorithm module provides a simple operations: Perform
instruction scheduling till completion. The entire program (or all the part
selected for scheduling) is processed.



\chapter{TRACKING SYSTEM}
\label{ch:trace-log}

The Tracking System of the Scheduler implements optional logging of the
scheduling process by means of invocations of specific methods. The level of
verbosity of the logging activity is configurable.
%
See the Scheduler functional specification document~\cite{SchedulerSpecs}.

\section{Overview}

Scheduler logging is a user service, not to be confused with the lower level
debugging messages. Scheduling logging must be maintainable, customisable
and easy to localise. For these reasons, logging must work on top of the
project-wide text formatting service.

The logging system consists of a single class object (log handler) that
provides a generic interface for clients (scheduling modules or passes) that
request to log a step of their activity. New modules defined by users of the
toolset should make use of the log handler to store log messages.

The log handler is responsible for storing the data given by its clients to
permanent storage in a shared output stream or in multiple independent
output streams.
%
\note{for initial version a single stream is sufficient}

The scheduler front-end is responsible for creating and initializing the log
handler when logging is enabled.



\chapter{SCHEDULER USER INTERFACES}
\label{ch:ui-modules}

The user interfaces control the scheduling process via the scheduler
front-end. Normally, the scheduler proceeds as a batch process without any
interaction, and the user interface needs to do little more than
initialisation. Optionally, the scheduler can run in interactive mode. In
this case, the user interface handles user interaction. Only one interface
will be provided initially. This interface is purely textual and
interpreter-based.
%
\note{A graphical interface is a non-critical optional component for future
  development.}

\section{Interaction Model}

The scheduler text-based interaction is based on selection of finite choices
or entering directly data (numbers or strings denoting processor resources).

\section{Command Line Option Parsing}

If the Scheduler is deployed as standalone terminal-based application, then
the user interface must perform parsing of the command line options and pass
the resulting setting parameters to the scheduler front-end. The parameters
are represented by an instance of a specialised command line options class,
based on the toolkit option system~\cite{ToolkitDesign}.



\chapter{STANDARD SERVICES}
\label{ch:Services}

This chapter describes standard services provided by the Scheduler
framework.

\section{Plug-in Abstraction Layer}

The toolkit services for loading and linking modules at run time are not
used directly by the scheduler clients.
%
Instead, the services are wrapped around a scheduler-specific abstraction
layer implemented as a separate sub-module.

The primary advantage of a separate layer is that direct communication from
plug-in modules to scheduler front-end is avoided (both use the layer
instead).
%
Another advantage is that the layer hides certain nontrivial details related
and specific to pass modules, such as construction and destruction, name and
file matching.



\chapter{REJECTED ALTERNATIVES}

% Rejected alternatives for (parts of) the design should be listed here with
% the reasoning and date the alternative was dumped. For future reference.

\begin{description}
\item[01.07.2005 --- Conversion Passes] %
  Conversion passes that perform conversions between different program
  representations are implemented as generic modules. When necessary,
  conversions include code analyses.

  In normal scheduler configurations, at least the following conversion
  passes are necessary for a complete working Scheduler:
  \begin{enumerate}
  \item%
    Program input (constructs the Program Representation and performs
    necessary code analyses).
  \item %
    Program output (generates an output Program Object Model from the
    Program Representation used by the Scheduler).
  \end{enumerate}

  This solution has been rejected. The framework provides conversion between
  domain object models (POM, MOM) and Scheduler-specific representations
  (resource model, program graph). This choice is motivated by the fact that
  such object models are invariant aspects of the framework.

  This solution does not impact flexibility. The developer of new scheduling
  algorithms can define new object models and conversion modules for program
  and resources (or other aspects of the scheduling process currently not
  modelled). These custom conversion passes must be defined explicitly in
  the configuration file. See possible extension ``Support for custom
  conversion modules'' in Chapter~\ref{ch:extensions}.
\item[02.08.2005 --- Candidate selector with more state] %
  The selector provides interface for clients to communicate whether current
  selection is accepted or rejected. The selector keeps track of rejections
  and, if asked again for a candidate, returns another selection if
  available.

  This solution seems to complicate the common case (just obtain next
  candidate and try to schedule it) and introduces more state inside the
  selector, that must remember when clients have rejected one of the
  selections. Another shortcoming is that, unless the implementation is
  further complicated, the selector is not able to tell which client
  rejected which selection.
\item[14.11.2005] --- Frontend as \emph{Faade} for plug-in loading.

  The facility for loading a pass module is so simple that can be
  implemented directly inside the scheduler front-end module, as one method.
  This alternative (chosen on 01.10.2005) was later rejected.
\end{description}



\chapter{IDEAS FOR FURTHER DEVELOPMENT}
\label{ch:extensions}

% Ideas that are not part of the design yet but that might be added in the
% future are listed here. This is to have ideas written down somewhere.
% This list should contain the date of addition, the idea described briefly
% and the inventor of the idea.

\begin{description}
\item[22.07.2005 --- Support for custom conversion modules]%
  Currently the framework provides full conversion facilities only for
  domain and framework-specific object models. Developers of new modules can
  define their own custom object models and conversion modules, but the
  modules can only be ``fired'' explicitly by means of declarations in the
  Scheduler configuration file.

  A possible extension is to provide a special declaration for conversion
  passes, so that a module that uses a custom object model can be given the
  converter loaded from the conversion module as a generic service to be
  called whenever necessary (like POM to graph conversion is, for example).
%
  --- A.~Cilio
\item[24.07.2005 --- Additional services of resource manager]%
  In addition to the basic services provided by the resource manager, which
  communicate with clients through nodes of the program representation, the
  manager provides much finer control on the resource allocation process.

  Two more groups of methods provide finer control:
  \begin{enumerate}
  \item %
    Return information concerning assignment and availability of resources
    of a specific type for a specific element of the program (the transport,
    the operation carried out as side effect of the transport, the source or
    destination unit, and so on).

    The top-level resource manager object or type-specific resource managers
    should implement the interface for this type of services.
  \item %
    Return information concerning the state of single resources and their
    availability (in general or with respect to a given node).

    This type of services is implemented by single resource object, but is
    only accessible through a type-specific resource manager, which shields
    clients from the details of the interface used to request assignment and
    allocation to a resource.
  \end{enumerate}
%
  --- A.~Cilio
\end{description}



\chapter{PENDING ISSUES}

% Pending issues concerning this design, a sort of TODO list.
% This chapter should be empty when implementation of this module/subsystem
% is completed.

\section{Operand Sharing}
\label{ch:pending:operand-sharing}

Operand sharing is an example of how the core modules cannot handle certain
aspects of scheduling on their own, and responsibilities are mixed.

The selector could take the possibility of sharing into account when
computing the minimum (or maximum) cycle of a candidate node, but since it
should not look at the resource constraints (it must work with any
framework-compliant resource manager), it can only find potential operand
sharing opportunities, to be verified by other modules.

The resource manager could try to model operand sharing as a resource, but
this is unlikely to work well, since operand sharing depends also on data
dependency information that the resource manager must not know about.
Furthermore, delegating resource manager works only if the client
(scheduling algorithm) remembers to ask it to verify and possibly extend the
minimum (or maximum) cycle with potential sharing opportunities. If the
scheduling
algorithm takes too much control on the assignment decisions (rejecting
assignments or even trying assignments cycle by cycle), and forgets to ask
for minimum (maximum) cycle verification, then the resource manager will not be
able to exploit operand sharing.

The scheduling algorithm could take over operand sharing, but then operand
sharing becomes more monolithic and more \emph{ad hoc}. Moreover, every new
scheduling algorithm should re-implement the same (or similar) operand
sharing functionality.

The following is a proposal of cooperation between modules to implement
operand sharing in a general way:
\begin{enumerate}
\item %
  The selector module takes the data dependency aspect of operand sharing
  requirements into account, computes a tentative minimum (maximum) cycle and
  determines potential sharing opportunities.
\item %
  Resource manager can finalise the operand sharing checks in current basic
  block and validate or reject the potential sharing opportunities found by
  the selector module.
\item %
  The scheduler algorithm can try to extend sharing across basic block
  boundaries.
\end{enumerate}

\section{Abstraction Layers for Toolkit Services}
\label{ch:pending:layers}

The toolkit service for language interpreters, necessary for user
interaction, could be wrapped around framework-specific interface
implemented in a separate adapter module.

This may make sense if the interpreter functionality is complex and specific
to the scheduling environment (for example, sensitivity to certain command
line options).

\section{Resource Manager and Scopes That Cross Basic Blocks}
\label{ch:pending:global-resource-manager}

If the code region managed by the resource manager (for example, the
scheduling scope) spans multiple basic blocks, resource management becomes
significantly more complex. For example, if a client asks for the minimum
cycle in which a node can be scheduled, then the cycle returned could belong
to a block different from the block that contains the initial minimum cycle
given as argument. Resource managers are not required to look across control
(or even practical) boundaries when looking for minimum cycles or allocation
of a resource that must precede a given cycle.

There are problems with crossing basic blocks during a search for resources.
In particular, if the block is past a branch point, resource assignment
requires:
\begin{enumerate}
\item\label{itm:liveness} %
  Verification of data dependencies: the node being assigned could override
  another definition of the same register, or could read a register that is
  redefined by a node already scheduled in the destination block.
\item\label{itm:duplication} %
  Duplication of the node and independent assignment in each destination
  block of the branch point.
\end{enumerate}

The first problem can be solved only by means of data dependence analysis,
thus outside the resource manager. The selector could return a maximum cycle
in addition to the minimum cycle, where the maximum cycle takes into account
dependencies with already scheduled nodes. In fact, there could be several
maximum cycles, one for each independent control path that can be reached
from the initial basic block.

The second problem requires a complex structure for passing arguments of
assignment requests: variable numbers of (potential) duplicate nodes with
their minimum cycle.

The simple alternative, of course, is for the resource manager to give up
allocation and signal this situation to the scheduling algorithm, which
could take further action (node duplication, retry with higher minimum cycle
in basic blocks past the branch point). However, a general problem of this
solution is that the result of a request should be always checked for the
case when assignment for nodes past branch points is required.

Another problem related with resource managers working with several basic
blocks is that bookkeeping of resource usage must take into account merging
control paths. If a resource, when assigned, remains in use for multiple
cycles (for example, a function unit), its in-use state may cross the basic
block boundary. If the destination block is a merge points, the first cycles
of the basic block must take into account resource usage from two or more
paths.
%
Without considering guarded moves [[to do: sketch a solution in this case]],
the resource usage from different paths can simply be combined with a union
operation. This is known as a ``joint state'' of resource utilisation. The
only peculiarity is that, unlike in resource assignment in straight lines of
code, a non-reusable resource may be marked as assigned to multiple nodes
from different paths at the same time. In this case, multiple assignments
are legal because they are mutually exclusive. Still, there must be a
mechanism to let the manager take into account assignments coming from
merging paths and unassign a resource from only one or the other path.

\section{Software Pipelining}
\label{ch:pending:sw-pipelining}


Software pipelining (or perhaps more generally, cyclic scheduling
algorithms) seems to affect several aspects of the scheduler.
\begin{enumerate}
\item%
  The scheduling algorithm is affected: it must know when the resource
  manager ``didn't get it right'' because it exceeded the modulo limit, and
  then ``wrap around'' and request another resource check starting from
  cycle zero. Furthermore, the scheduling algorithm must handle the case
  when resource manager finds a cycle that is free of resource conflicts,
  but that cycle is too late because one of the nodes that depend on the
  result of the node to be scheduled has been scheduler in an earlier cycle.

  This problem could be solved in a general way if the selector computes
  also the maximum allowed cycle, not only the minimum cycle, as hinted in
  Section~\ref{ch:pending:global-resource-manager}. The maximum cycle is
  computed on basis of \emph{users} of definitions that are scheduled before
  the definitions (this is an essential peculiarity of cyclic scheduling).
\item%
  The Selector doesn't need necessarily to return the maximum cycle in which
  a node could be scheduled; this can be tested by the scheduling algorithm
  instead. It is quite simple to track the data dependencies from the
  definition to all its consumers and verify if any of them has been already
  placed.
\item%
  It seems that the resource manager does not need to know the size of the
  initiation interval or check for resource availability using the modulo of
  the initiation interval size. It should work as if the node being tested
  were scheduled in a linear scheduling scope. [[I doubt this statement.
  there must be a test of the resource usages that span multiple cycles and
  ``wrap around'' a loop branch]].
\item%
  Who is responsible for computing the II?
\item%
  Who is responsible for ensuring that the scheduling cycle does not exceed
  the cycle of earliest consumer? Selector works with data dependencies, so
  it could be an appropriate choice. The maximum cycle could be returned
  just as an additional piece of information. Acyclic algorithms do not care
  about maximum cycle if not, perhaps, in special cases such as node
  duplication past branch point (see
  Section~\ref{ch:pending:global-resource-manager}).
\end{enumerate}



\chapter{MAINTENANCE}

This chapter describes how to extend the design with new capabilities that
fit in the predefined Scheduler framework.

\section{Adding a New Resource Manager}

Every module that complies with the constraints and the specifications
described in Chapter~\ref{ch:ResourceManager} and with the further API
defined in the Scheduler Design Document~\cite{SchedulerDesign} will be a
plug-in replacement for the standard resource manager provided with the
Scheduler application.

\section{Adding a Multi-module Pass}

The helper modules of multi-module passes, described in
Section~\ref{sec:multi-module}, should be completely replaceable with
implementations that conform to a predefined, helper-specific interface. To
ensure this, the specific interface of a given type of helper must be fixed
and known by all its client modules (main module of the pass or higher-level
helper modules).

Every helper module should be an implementation of a pure interface. The
definition of such interface must contain any pass-specific operations
provided by the helper to client modules, and must be included into the
source code of the client modules.

It is \emph{not} advisable to define a concrete base implementation of a
helper module, because this would force developers of a replacement helper
module to inherit a concrete class.

\subsection{Registration}

Internally, when a client module of a helper module tries to register a
given module to itself, it must refer (\emph{cast}, in practice), to the
base interface of the expected helper module. Client modules are completely
unaware of the concrete class of the given helper modules.


% ------------------------------------------------------------------------

%  References are generated with BibTeX from a bibtex file.
\bibliographystyle{alpha}\cleardoublepage
%% Equivalent to a chapter in the table of contents
\addcontentsline{toc}{chapter}{BIBLIOGRAPHY}
\bibliography{Bibliography}


\end{document}

%%% Local Variables: 
%%% mode: latex
%%% mode: auto-fill
%%% TeX-master: t
%%% End: 
