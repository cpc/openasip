\documentclass[twoside]{tce}
\usepackage{pslatex}

\begin{document}
\author{Lasse Laasonen}
\title{Universal Machine}
\ver{0.4.1}
\firstday{21.12.2004}
\lastday{28.04.2006}
% id number in S- sequence
\docnum{031}
% draft/complete/committed
\state{draft}

\maketitle



\chapter*{Document History}

\begin{HistoryTable}

 0.1    & 21.12.2004 & L. Laasonen     & 
 Added initial versions of chapters 1, 2 and 3\\
 0.2    & 29.12.2004 & L. Laasonen     &
 Updated to current actual implementation. Removed unnecessary sections.\\
 0.3    & 07.01.2005 & L. Laasonen     &
 Removed the other ``universal FU''. Derived \emph{SmartHWOperation} and
 \emph{UniversalFUPort} classes.\\
 0.3.1  & 30.12.2005 & A. Cilio        &
 Standard formatting; minor review, 2,3 (part).\\
 0.4    & 02.01.2006 & A. Cilio        &
 Updated to specifications: UFU, universal RF, UM class.\\
 0.4.1  & 28.04.2006 & A. Cilio        &
 Minor cleanup.\\

\end{HistoryTable}


\tableofcontents



\chapter{INTRODUCTION}

\section{Purpose and Scope}

This document describes the detailed software design of UniversalMachine
(UM) module. The purpose of the module is to provide an object model of a
TTA processor which can execute any kind of sequential code. The object
model is based on the machine object model (MOM) described
in~\cite{MOM-design}. This document describes the classes which are
specialized from the classes in MOM and tells what kind of components the
UniversalMachine has.

\section{Definitions}

% Uncomment this to enable the ``term explanation box''
%\begin{description}
%\item[term]%
%  term definition
%\end{description}


\section{Acronyms and Abbreviations}

\begin{table}[htb]
\begin{center}
\begin{tabular}{p{0.15\textwidth}p{0.85\textwidth}}
FU & Function Unit \\
MOM & Machine Object Model \\
OSAL & Operation Set Abstraction Layer \\
RF & Register File \\
TTA & Transport Triggered Architecture \\
UFU & Universal Function Unit \\
UM & UniversalMachine module \\
\end{tabular}
\end{center}
\end{table}



\chapter{OVERVIEW}

\section{``Philosophy of Design''}

% Describe the principles behind this design and give an overview of
% it. Motivate briefly the design if necessary.

%% No description of the module purpose and motivation, that belongs to the
%% functional specification document.

The ``Universal Machine'' (UM) is an ideal type of TTA processor which can
execute any kind of sequential code. In addition, the UM is the simplest
processor which can satisfy this fundamental requirement. These two
properties dictate which components make up the UM. The design of these
components is based on MOM. However, some components of the UM cannot be
modeled by the existing classes of MOM, because MOM is capable of
representing only machines with finite resources. By contrast, the universal
machine must contain unlimited resources of certain types to be able to
execute any kind of sequential code. That is why some classes of UM are
specialisations of MOM's components.


\section{External Modules}

% Overview of module from an external perspective:
% - dependencies with external modules-subsystems
% - IFs of external modules that are used
% - external (file) data formats used

% Do not put here the interfaces provided to other modules.

The UniversalMachine module is used at least in TTA Processor Simulator (see
\cite{SimulatorSpecs}) and in TTA Instruction Scheduler (see
\cite{SchedulerSpecs}). The module itself uses the Operation Set Abstration
Layer~\cite{OSAL-specs} to lookup operation properties. Obviously,
the UM depends on the MOM since it is a specialization of that module.



\chapter{Module Design}

%% This chapter is repeated for each module in case this design document
%% describes a multi-module larger module (or application).

\section{Overview}

% Overview of the module design in concrete terms.

%% Remove this section (redundant) if the design document describes a single
%% module (or an application consisting of a single module).

\begin{figure}[tb]
\centerline{\psfig{figure=eps/classdiagram.eps,width=0.85\textwidth}}
\caption{Simplified class diagram of UniversalMachine module.}
\label{fig:classdiagram}
\end{figure}

UniversalMachine module is a processor represented by a specialized
machine object model with the following components:

\begin{enumerate}
\item%
  A single 64-bit wide bus which supports zero-extended 32-bit in-line
  immediates and two (Boolean register) guard expressions: one inverted, one
  non-inverted.
\item%
  A Boolean register file with one register, one input and one output port.
\item%
  A register file containing an unlimited number of 32-bit general purpose
  registers, with one input and one output port.
\item%
  A register file containing an unlimited number of 64-bit registers, with
  one input and one output port. Typically, this register file is used for
  double-precision floating-point numbers.
\item%
  A register file containing one 32-bit special register for subroutine
  return value, with one input and one output port.
\item%
  A control unit which supports JUMP and CALL operations of the base
  operation set and one transport stage.
\item%
  A ``universal'' FU with support for any operation. Operations are added on
  demand.
\item%
  One input socket which is connected to all the input ports of the UM
  units.
\item%
  One output socket which is connected to all the output ports of the UM
  units.
\item%
  An address space 0x000000--0xFFFFFF for data, with 8-bit MAU's (16MB of
  memory in total).
\item%
  An address space 0x000000--0xFFFFFF for program instructions, with MAU's
  as wide as an instruction word. In total, the memory can contain 16
  million instructions.
\end{enumerate}

The components that need to be specialized from MOM are the register file
which has unlimited number of registers and the universal FU with operations
added on demand. The universal FU is different enough from normal FU's as to
require also \emph{SmartHWOperation} and \emph{UniversalFUPort} classes to
be derived. The main class in MOM, \emph{Machine}, is specialized in
\emph{UniversalMachine}, too. The class diagram of \emph{UniversalMachine}
is depicted in Figure~\ref{fig:classdiagram}. It is a simplified version of
\emph{Machine}, and does not contain all the classes of MOM, only the ones
that make sense in the context of \emph{UniversalMachine}.

\section{UniversalMachine Class}

\emph{UniversalMachine} is a specialised \emph{Machine} class and is at the
root of the universal machine object model. Its interface is similar to that
of \emph{Machine}, but its constructor creates the model by adding the
necessary components.

\subsection{Interface}

The methods of \emph{Machine} class which are redefined in
\emph{UniversalMachine} are given below.

\begin{description}
\item[UniversalMachine(opPool : OperationPool\&)] Constructor. Create a
  complete universal machine with all the suitable components. The universal
  FU (UFU) loads the operations from the given operation pool.
\item[addBus(bus : Bus\&)]
  Add the given bus if construction is not finished. Otherwise abort the 
  program.
\item[addSocket(socket : Socket\&)]
  Add the given socket if construction is not finished. Otherwise abort
  the program.
\item[addFunctionUnit(unit : FunctionUnit\&)]
  Add the given FU if construction is not finished. Otherwise abort the 
  program.
\item[addImmediateUnit(unit : ImmediateUnit\&)]
  Abort the program.
\item[addRegisterFile(unit : RegisterFile\&)]
  Add the given RF if construction is not finished. Otherwise abort the
  program.
\item[addAddressSpace(as : AddressSpace\&)]
  Add the given address space if the construction is not finished. Otherwise
  abort the program.
\item[addBridge(bridge : Bridge\&)]
  Abort the program.
\item[addInstructionTemplate(iTemp : InstructionTemplate\&)]
  Abort the program.
\item[setGlobalControl(unit : ControlUnit\&)]
  Set the given control unit if construction is not finished. Otherwise
  abort the program.
\item[removeBus(bus : Bus\&)]
  Abort the program.
\item[removeSocket(socket : Socket\&)]
  Abort the program.
\item[removeFunctionUnit(unit : FunctionUnit\&)]
  Abort the program.
\item[removeRegisterfile(unit : RegisterFile\&)]
  Abort the program.
\item[deleteAddressSpace(as : AddressSpace\&)]
  Abort the program.
\item[unsetGlobalControl()]
  Abort the program.
\item[loadState(state : const ObjectState*)]
  Abort the program.
\end{description}

\subsection{Implementation}

\emph{UniversalMachine} redefines almost all of the non-\emph{const} methods
of \emph{Machine} class. It writes to error log and aborts if some of these
methods are called after the initial construction has been finished. This
can be done by making a private member flag which determines if components
can be added normally. At construction, the value of the flag allows adding
components. After the construction is done, the flag is switched to forbid
adding more components. Of course, the non-\emph{const} methods must check
the state of the flag and act based on its value. For example, the
\emph{addBus} method would look something like this:

\begin{verbatim}
void UniversalMachine::addBus(Bus& bus) {
  if (built_) {
    Application::abortWithError("addBus method of UniversalMachine called!");
  } else {
    Machine::addBus(bus);
  }
}
\end{verbatim}

\section{UnboundedRegisterFile Class}

\emph{UnboundedRegisterFile} class represents a register file which has an
unlimited number of registers. It is derived from \emph{RegisterFile} class.

\subsection{Interface}

\emph{UnboundedRegisterFile} redefines some methods of \emph{RegisterFile}
class. Its constructor takes only name, bit width and type as parameters.
The size is missing, naturally. The interface of
\emph{UnboundedRegisterFile} is the following:

\begin{description}
\item[UnboundedRegisterFile(name : string, width : int, type : RegisterFile::Type)]
  Constructor. Name, bit width and type of the register file are given
  as parameters.
\item[maxReads() : int]
  Always return the number of read ports in the register file.
\item[maxWrites() : int] 
  Return the maximum possible number of simultaneous writes of a register file.
\item[numberOfRegisters()]
  Abort with error message.
\item[setMaxReads(reads : int)]
  Abort with error message.
\item[setMaxWrites(maxWrites : int)]
  Abort with error message.
\item[setNumberOfRegisters(int)]
  Abort with error message.
\item[setWidth(width : int)]
  Abort with error message.
\item[setName(name : const string\&)]
  Abort with error message.
\item[setType(type : RegisterFile::Type)]
  Abort with error message.
\item[loadState(state : ObjectState*)]
  Abort with error message.
\end{description}

\subsection{Implementation}

\emph{UnboundedRegisterFile} models a register file that contains an
``unlimited'' number of registers. The number of registers is limited only
by the implementation (typically, the maximum value that can be represented
by a C++ integer type on the host platform).

\section{UniversalFunctionUnit Class}

\emph{UniversalFunctionUnit} class is a specialisation of
\emph{FunctionUnit} and models an ideal FU that can perform any operation
found in a TTA program. The operations of UFU are instances of
\emph{SmartHWOperation} class, and create operand bindings automatically as
required. Ports of UFU are instances of \emph{UniversalFUPort} class because
UFU accepts two operation code setting ports instead of the normal one.

\subsection{Interface}

\emph{UniversalFunctionUnit} redefines a few methods of its base class
\emph{FunctionUnit} and provides a few additional methods. The interface is
the following:

\begin{description}
\item[UniversalFunctionUnit(name : string, opPool : OperationPool\&)]
  Constructor. Name and operation pool from which the operations are
  loaded are given as parameters.
\item[operation(name : const string\&) : SmartHWOperation*]
  Add the requested operation into the FU and return it. Throw an
  exception if the operation is not found in the operation pool.
\item[addPipelineElement(element : PipelineElement\&)]
  Abort with error message. There should be no need to add pipeline elements.
\item[loadState(ObjectState*)]
  Abort with error message.
\item[portCount(int width) : int]%
  Helper method. Return the number of ports that have exactly the given bit
  width.
\item[port(index : int, width : int) : FUPort\&]%
  Helper method. Return the port of the given bit width identified by the
  given index.
\item[static is32BitOperation(opName : const string\&) : bool]%
  Helper method. Tell whether the given operation has operands of 32 bits.
\end{description}

\subsection{Implementation}

To model an unrestricted operation set efficiently,
\emph{UniversalFunctionUnit} loads operations from its operation pool ``on
demand'', that is, only when required by \emph{operation} method.

The \emph{operation} method may have to modify the class even though it is
declared \emph{const} in the base \emph{FunctionUnit} class. The solution is
to use \emph{const\_cast} when a non-\emph{const} method is called. The
operations to be added are picked from the operation pool.

Ports are added to the FU on demand. When an operation is added, input and
output ports may have to be added, too. There must be at least as many input
ports of correct bit width as the operation has input operands and as many
output ports of correct bit width as the operation has outputs. Bit width of
the ports to be added depends on the operation which uses them.
Floating-point and user-defined operations have 64-bit wide ports; integer
operations have 32-bit ports.

\begin{quote}
  \emph{Warning.} The information whether an operation is integer or
  floating-point operation is hard-coded in \emph{UniversalFunctionUnit}
  class, making it an unflexible aspect of this design.
\end{quote}

The UFU has two triggering ports, which are also opcode setting ports.

\section{UniversalFUPort Class}

The \emph{UniversalFUPort} class is derived from \emph{FUPort} class. The
\emph{UniversalFUPort} instances are exactly similar. The only difference is
that there can be several operation code setting ports in the parent FU.

\subsection{Interface}

The interface of this class is identical to that of the base class
\emph{FUPort}. All non-constant methods are redefined and abort the program
if called.

\subsection{Implementation}

The check that prevents two operation code setting ports in the same unit is
implemented in the constructor of \emph{FUPort}. Another constructor must be
created to the \emph{FUPort} which does not do the check. This is a
protected constuctor which can be used by the constructor of
\emph{UniversalFUPort} class.

\section{SmartHWOperation Class}

The \emph{SmartHWOperation} class is derived from \emph{HWOperation} class.
It is smart because it binds operands to ports automatically on demand. The
operands are bound on demand, in the order they are requested by \emph{port}
method. The last input operand requested is bound to the operation code
setting port.

\subsection{Interface}

The \emph{SmartHWOperation} class has the following interface:

\begin{description}
\item[SmartHWOperation(operation : const Operation\&,
  parent : UniversalFunctionUnit\&)]%
  Constructor. The operation augmented by the \emph{SmartHWOperation}
  instance and the parent UFU are given as parameters.
\item[setName(name : const string\&)]
  Abort the program.
\item[port(operand : int) : FUPort*]
  Return the port bound to the given operand. Binds the port
  automatically if it is not bound yet.
\item[bindPort(operand : int, port : const FUPort\&)]
  Abort the program.
\item[unbindPort(port : const FUPort\&)]
  Abort the program.
\item[loadState(state : const ObjectState*)]
  Abort the program.
\end{description}

\subsection{Implementation}

SmartHWOperation creates its pipeline in the constructor. The pipeline to be
created contains all the port reads and writes at cycle zero, that is, at
the end of the same cycle in which the operation is triggered. This ensures
that the operation has a latency of 1 cycle.



\chapter{REJECTED ALTERNATIVES}

% Rejected alternatives for (parts of) the design should be listed here with
% the reasoning and date the alternative was dumped. For future reference.
%
%18.11.2003 . . .



\chapter{IDEAS FOR FURTHER DEVELOPMENT}

% Ideas that are not part of the design yet but that might be added in the
% future are listed here. This is to have ideas written down somewhere.
% This list should contain the date of addition, the idea described briefly
% and the inventor of the idea.

% Example:
%
% 18.11.2003 . . . -P.J‰‰skel‰inen



\chapter{PENDING ISSUES}

% Pending issues concerning this design, a sort of TODO list.
% This chapter should be empty when implementation of this module/subsystem
% is completed.



\chapter{MAINTENANCE}

% This chapter treats the problem of extending the design with new
% capabilities that fit in a predefined framework.

% For example, in case of the TPEF module, this chapter could describe the
% steps that must be taken in order to add a new Section subclass and/or a
% SectionReader subclass.

% Remove this chapter no obvious and standardised way to extend the design
% with new capabilities exists.


% ------------------------------------------------------------------------

%% Uncomment this part if there are references.  Usually there will be at
%% least a reference to the functional specifications of the same module.

%  References are generated with BibTeX from a bibtex file.
\bibliographystyle{alpha}
\cleardoublepage
%% Equivalent to a chapter in the table of contents
\addcontentsline{toc}{chapter}{BIBLIOGRAPHY}
\bibliography{Bibliography}



\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
