\documentclass[twoside]{tce}
\usepackage{pslatex}
\begin{document}
\author{Tommi Rantanen}
\title{TTA Processor Estimator}
\ver{0.10}
\firstday{12.08.2004}
\lastday{25.10.2005}
% id number in S- sequence
\docnum{019}
% draft/complete/committed
\state{draft}
\maketitle

% highlighted style for parameters/variables or otherwise non-fixed parts
% of a command syntax or of lines of text displayed by the application
\newcommand{\parm}[1]{\textsl{#1\/}}
% command to print the type of data fields of data bases
\newcommand{\ftyp}[1]{(\emph{#1\/})}
% standard item vertical separation; temporarily overridden in some lists
\newlength{\stditemsep}
\setlength{\stditemsep}{\itemsep}
% standard paragraph vertical separation; temporarily overridden in some lists
\newlength{\stdparskip}
\setlength{\stdparskip}{\parskip}

\chapter*{Version History}

\begin{HistoryTable}

 0.1   & 12.08.2004 & T. Rantanen     &
 First draft.\\

 0.2   & 13.08.2004 & T. Rantanen     &
 Modifed according to review of T. Rantanen:) Only minor changes and
 reorganization of the document.\\

 0.3   & 25.08.2004 & T. Rantanen     &
 Modified according to Andrea's comments.\\

 0.4   & 31.08.2004 & T. Rantanen     &
 Modified according to conclusions of meeting with Andrea, Teemu and
 Jarmo.\\

 0.4.1 & 21.10.2004 & L. Laasonen     &
 Changed name of MDF to ADF.\\

 0.5   & 10.11.2004 & T. Rantanen     &
 Added usage issues with IDF.  Minor changes from Andrea's proofread.\\

 0.6   & 10.01.2005 & T. Rantanen     &
 Updated search paths of cost database. Added socket bit width to database.
 Updated the table about the fields of each database entry. Updated
 architectural properties of FU's. Moved item about latency 0 and 1 FU's
 from further development to rejected ideas. Added idea about bus estimation
 to rejected ideas.\\

 0.7   & 17.01.2005 & T. Rantanen     &
 Updated database contents.  Added one item to future development section.\\

 0.7.1 & 19.01.2005 & T. Rantanen     &
 Minor fix to database contents. Added items to rejected ideas.\\

 0.8   & 16.05.2005 & A. Cilio        &
 Added estimation/selection use cases. \\

 0.8.1 & 16.05.2005 & A. Cilio        &
 Corrected missing use case. \\

 0.9   & 22.09.2005 & P. Jääskeläinen &
 Applied changes due to HDB and the new flexible estimator
 (all algorithms delegated to plugins) idea.
 Removed the command line app to browse/edit HDB. SQL will do for now,
 later we'll implement a GUI for browsing/editing the HDB, if have time. \\

 0.9.1 & 25.09.2005 & T. Rantanen     &
 Minor cosmetic fixes.\\

 0.10  & 25.10.2005 & T. Rantanen     &
 Document number added. RF energy changed into model where
 simultaneous reads and writes are taken into account. Fixed old text
 which refers to the model when bus area and energy was multiplied by
 its bit width, which has been an architectural parameter for a while.\\
\end{HistoryTable}


% Table of contents
\tableofcontents

% Document text
\chapter{INTRODUCTION}

\section{Purpose}

This document describes the target architecture estimator of the TCE
toolset. This document contains the functional specification of the
estimator.

\section{Product Idea}

The target architecture estimator enables the user to estimate the
cost of a target processor and the performance when it runs a given
TTA application. The estimation process produces cost and performance
data in terms of chip area taken by the target processor, energy
consumption taken by the target processor to run a given application,
and the maximum clock speed of the target processor.

The Estimator is an essential part of the TCE toolset. It is required
for guiding the process of finding an optimal target processor for a
given cost-performance trade-off. In addition, it is used as an
independent application to obtain an idea of the cost and performance
of a target processor.

\section{Product Overview}

The Estimator is a command line application, but a GUI-based Estimator
may be implemented. Nevertheless, this document only describes the
properties of the command line version of the Estimator.

The estimation process is based on a cost model, which indicates how
the costs of the target processor are estimated.

The Estimator reads several input files:
\begin{description}
\item[TTA Target Processor Architecture] %
    Complete description of the target processor architecture to be estimated.

\item[TTA Target Processor Implementation] %
    A description of the target processor implementation to be
    estimated. This is not required to be complete, i.e., not all
    parts of machine need to be connected to an implementation (needed
    during exploration).

\item[Hardware Database] %
    Database that includes access point to external cost estimation
    plugins and the data the plugins need to estimate the costs of TTA
    processor building blocks for different architectural properties.

\item[Cost Estimation Plugins] %
    Cost estimation algorithms are externalized to plugin
    modules. User can define new cost estimation algorithms by
    implementing a cost estimation plugin. Plugins can be defined for
    estimating FU, RF, IC/decoder, and decompressor block
    costs. Plugins can use arbitrary data stored in HDB.

\item[TTA Program Exchange Format] %
    Complete description of the target application for which the
    processor costs are estimated.

\item[Simulation Trace Database] %
    Database containing statistics from a simulation run of the target
    application for the processor to estimate. Estimation algorithms
    need at least to know the instructions executed in each clock
    cycle, which moves were actually executed (not squashed), and
    which data was transported in each move (to calculate energy
    consumption).

\end{description}

\section{Definitions}

\begin{description}
\item[Application] %
    A standalone executable program that provides services for users
    of the TCE toolset. It may be controlled by a command-line
    interface or by a graphical user interface, or via a driver
    application that integrates a group of related applications.

\item[Hardware Database] %
    Database of TTA processor building blocks for different
    architectural properties. Includes an access point to cost
    estimation algorithms.

\item[Cost Model] %
    The way which is used to estimate the costs of the target processor.

\item[Estimator] %
    The target architecture estimator of the TTA processors.

\item[Match Type] %
    The condition applied to a field of cost database entries to
    determine whether it matches a given key value.

\item[Simulation Trace Database] %
    Database containing statistics from a simulation run of the target
    application for the processor to estimate.
\end{description}


\section{Acronyms and Abbreviations}

\begin{table}[htb]
\begin{center}
\begin{tabular}{p{0.15\textwidth}p{0.85\textwidth}}
ADF   & Architecture Definition File. \\
FU    & Function Unit. \\
GCU   & Global Control Unit. \\
GUI   & Graphical User Interface. \\
HDB   & Hardware Database. \\
IDF   & Implementation Description File. \\
IU    & Immediate Unit. \\
RF    & Register File. \\
TCE   & TTA Codesign Environment. \\
TPEF  & TTA Program Exchange Format. \\
TTA   & Transport Triggered Architecture. \\
\end{tabular}
\end{center}
\end{table}

\chapter{USER DESCRIPTION}

\section{User Profile}

The typical users of the Estimator are \emph{application developers},
\emph{architecture designers} and \emph{researchers of TTA
concept}.

Application developers are concerned with verifying the correctness of
the application, pinpointing its critical spots and ultimately
fine-tuning the code so that it runs as fast as possible on the target
processor.

Architecture designers are concerned with estimating the costs of the
target processor architecture to obtain information about the
efficiency and effectiveness of the architecture. Architecture
designers remove resources which are not giving any extra performance.

Researchers are interested not only in estimating cost and performance
of a target processor, but also in researching alternative cost
models. This type of user may need to modify the Estimator code and
extend its capabilities.

\section{Key User Needs}

The Estimator is used for obtaining the cost and performance of a
target processor. In addition to the human users, the Estimator
provides feedback for the \emph{design space
explorer}~\cite{ExplorerSpecs}, which is the main client of the
Estimator.


\chapter{PRODUCT OVERVIEW}

\section{Product Perspective}
\label{sec:perspective}

The Estimator reads four important input files:
\begin{enumerate}
\item TTA target processor architecture in
      ADF file (specified in~\cite{ADF-specs})
\item TTA target processor implementation in
      IDF file (specified in~\cite{ProGeSpecs})
\item Hardware Database (specified in~\cite{HDBDesign})
\item TTA application in TPEF file (specified in~\cite{TPEF-specs})
\item Simulation Trace Database (specified in~\cite{SimulatorSpecs})
\end{enumerate}

The Estimator provides cost and performance estimation services for
the users as well as for the design space explorer.

\section{Product Position Statement}

To provide estimation in terms of chip area, energy consumption and
maximum clock cycle speed for the target TTA processors that can be
designed with TCE toolset.

\section{Use Cases}

\begin{quote}
  \textbf{Note!} The use cases defined here are of two kinds: cost
  estimation proper, based on pre-selected block implementations, and
  \emph{selection} of block implementations suitable for given
  criteria. These functionalities are separated in two independent
  standalone applications.
\end{quote}

\subsection{Estimator: Producing Cost and Performance Estimates of a Processor
  Architecture Given Precise Reference to Block Implementations}
\label{sec:uc-estimation-proper}

Purpose: To generate a user-readable report describing what are the expected
cost and performance of a given target processor architecture.

\begin{flushleft}
\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}lp{0.88\textwidth}}
Inputs:  &
architecture description, cost and performance data for block
implementations, reference to implementations to choose for the estimation\\
Outputs: &
a user-readable report of cost and performance estimates of the target
processor\\
\end{tabular*}
\end{flushleft}

\begin{enumerate}
\item %
  The user specifies an input architecture and references to implementations
  of processor building blocks to be chosen for the estimation.

\item%
  The user specifies a base of cost and performance data for available block
  implementations.

\item%
  \emph{Optional variant:} The user specifies data (execution profile or
  execution trace) obtained from running a set of applications on the target
  architecture.

\item\label{itm:estim-lookup} %
  The estimator looks up cost and performance data from the base of data
  given by user for the requested block implementations.

  \emph{Error Variant}: If the cost and performance data set given by user
  does not cover one of the requested block implementations, the estimator
  aborts with error message.

\item\label{itm:estim-combine} %
  The estimator combines information from architecture description and found
  cost/performance data of block implementations and computes a complete
  estimate of the processor characteristics (die area, cycle period).

  \emph{Variant:} If the user has specified execution-related data, then
  estimator combines execution counts with cost data to estimate also the
  energy consumed by the processor to run the applications.

\item %
  The estimator outputs processor cost and performance data in
  human-readable form.
\end{enumerate}


\subsection{Implementation Selector: Selecting Block Implementations for a
  Processor Architecture Given Cost and Performance Criteria}
\label{sec:uc-constrained-selection}

Purpose: To select a complete set of block implementations suitable for a
processor given its target architecture definition and criteria to guide
selection where multiple implementation choices are available.

\begin{flushleft}
\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}lp{0.88\textwidth}}
Inputs:  &
architecture description, cost and performance data for block
implementations, criteria for selecting the best block implementations\\
Outputs: &
reference to block implementations\\
\end{tabular*}
\end{flushleft}

\begin{enumerate}
\item%
  The user specifies an input architecture.

\item%
  The user specifies a base of cost and performance data for available block
  implementations.

\item%
  The user specifies one or more criteria (based on cost and performance
  objectives) to guide selection of block implementations for the given
  target architecture.

\item\label{itm:selection-criteria}%
  For each processor building block that is individually estimated, the
  selector looks for cost and performance data that characterises one of its
  possible implementations. The characterised block has the same
  architecture of the block given by the architecture description. If
  several block implementations are available, then the selector chooses the
  implementation that best satisfies the selection criteria given by the
  user.

  \emph{Variant:} If the selector does not find cost/performance data for a
  block with exactly the same architecture of the requested building block,
  then it tries to look for block implementations with similar (compatible)
  architecture.

  \emph{Error Variant:} If the selector finds no cost/performance data for a
  block with architecture compatible with that specified, the selector
  aborts with error message.

\item\label{itm:output-generation}%
  The generator creates references to every processor building blocks that
  must have a pre-designed implementation. The references point to the block
  implementations that have been chosen to compute the cost and performance
  estimate.
\end{enumerate}

\paragraph{Selection Criteria}
The criteria to choose a block implementation between all implementations
with same (or compatible) architecture are in the form of conditions on
processor cost and performance. These conditions apply to the processor
globally, and affect the selection of each of its building blocks.
\begin{enumerate}
\item %
  Find out the fastest possible block implementations (regardless of area or
  energy consumption).  This gives information about the highest possible
  clock frequency and the bottleneck block.\footnote{%
    With this information, the user (or client application) may try to
    change the architecture description in order to remove the bottleneck
    (for example, increase the latency of the slowest function unit).}

\item %
  Find out minimum area implementations fullfilling a given clock frequency
  constraint.  Here the primary criteria is delay, which is a hard
  constraint: if it is not met, the selection process ends with failure.

\item %
  Find out minimum energy implementations fullfilling a given clock
  frequency constraint.  Here the primary criteria is delay, which is a hard
  constraint: if it is not met, the selection process ends with failure.

\item %
  Find out minimum energy implementations without clock frequency
  constraint.  Here the goal is to know the lower bound of energy.
%
  \note{probably won't be implemented}

\item %
  Find out minimum area implementations without clock frequency
  constraint. Here the goal is to know whether the processor will fit into a
  certain area.\footnote{For example, useful for an FPGA implementation.}
%
  \note{probably won't be implemented}
\end{enumerate}

\subsection{Selecting Block Implementations for a Processor Architecture
  without Explicit Selection Criteria}
\label{sec:uc-free-selection}

Purpose: To select a complete set of block implementations suitable for a
processor given its target architecture definition.

\begin{flushleft}
\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}lp{0.88\textwidth}}
Inputs:  &
architecture description, cost and performance data for block
implementations\\
Outputs: &
reference to block implementations\\
\end{tabular*}
\end{flushleft}

This use case is a variant of the case described in
Section~\ref{sec:uc-constrained-selection} where no selection criteria
whatsoever is given by the user.  Selection proceeds with every building
block with three possible outcomes:
\begin{enumerate}
\item %
  Only one block implementation is found in the base of cost and performance
  data with architecture matching the block being searched.  In this case, a
  reference to the only implementation is chosen.

\item %
  Several block implementations are found in the base of cost and
  performance data with architecture matching the block being searched.  In
  this case, two possibilities exist:
  \begin{enumerate}
  \item %
    The selector prompts the user for a choice.
  \item %
    The selector chooses one of the implementations using a criterion not
    under user control.  The criterion couls be: choose a pre-defined
    ``default'' implementation, or choose a random implementation.
  \end{enumerate}

\item %
  No block impementation is found in the base of cost and performance
  data with architecture matching the block being searched.  In this case,
  the selection process fails, and the selector aborts with error message.
\end{enumerate}

\section{Summary of Capabilities}

\begin{center}
\begin{longtable}{p{0.45\textwidth}p{0.55\textwidth}}
User Benefit & Supporting Feature \\ \hline processor cost analysis & area
and energy estimation statistics, processing of simulation results\\

processor performance analysis & clock speed estimation\\

decent accuracy in estimation  & cost model based on actual data from
                                 HW synthesis of processor building blocks\\
\end{longtable}
\end{center}


\chapter{PRODUCT FEATURES}

This chapter describes the functionality of the Estimator.

\section{Cost Model}
\label{sec:cost_model}

The Estimator estimates the cost and the performance of the target TTA
processor. Hence it requires a \emph{cost model}, which defines the
way in which the cost and performance of target TTA processors are
estimated. The Estimator requires information about the technology
with which the target processor is going to be implemented. The cost
model is based on \emph{a priori} information on area, energy, and
timing statistics of the processor building blocks (here also termed
hardware resources). This information is structured as a database,
henceforth to be called \emph{cost database}. It contains hard data
from real implementations at level of granularity such that simple
formulas for combining different blocks are accurate enough. Using the
data in cost database, the area, energy and timing of a target
processor are estimated.

In this Section, the default cost model provided by the TCE toolset is
introduced. Formulas for the area, energy and timing estimation are
represented in Sections~\ref{sec:area},~\ref{sec:energy}
and~\ref{sec:timing}, respectively. Section~\ref{sec:characteristics}
describes the implementation characteristics that are defined for each
resource in the cost database if not otherwise mentioned.
Sections~\ref{sec:first_resource_model} to
\ref{sec:last_resource_model} present the cost model for each hardware
resource type of the ADF (see~\cite{ADF-specs}). The following issues
are described for each resource type:
\begin{itemize}
\item architectural properties that uniquely identify a resource entry
      in the cost database;
\item implementation characteristics that determine the costs of the
      resource;
\item model for the area estimation;
\item model for the energy estimation.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Area Estimation}
\label{sec:area}

The total area of the processor configuration is obtained by adding up
the area of each hardware resource as follows:
\begin{equation}
A = 
\sum A_{FU} +
\sum A_{RF} +
\sum A_{IU} +
A_{GCU} +
\sum A_{bus} +
\sum A_{insock} +
\sum A_{outsock} +
\sum A_{bridge} +
\sum A_{AS}
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Energy Estimation}
\label{sec:energy}

The total energy consumed by the processor configuration to run a
given application (on given set of input data) is obtained by adding
up the energy of each hardware resource as follows:
\begin{equation}
E = 
\sum E_{FU} +
\sum E_{RF} +
\sum E_{IU} +
E_{GCU} +
\sum E_{bus} +
\sum E_{insock} +
\sum E_{outsock} +
\sum E_{bridge} +
\sum E_{AS}
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Timing}
\label{sec:timing}

The timing of the target processor can be estimated by the Estimator
or given by the user as an input. The Estimator can automatically
calculate the minimum cycle time of the processor, that is, the time
taken for the data to flow through the longest path. However, the user
may give as an input the cycle time on which the processor should
operate.

An FU may not contain registers in the input, that is, only the output
ports contain registers. Then, the delay of the paths containing the
input sockets connected to such an FU is the delay of the chain
``output socket -> bus -> input socket -> FU''. Register cannot be
missing from both the input and the output ports.

The longest path of the processor is the maximum of the delay of any
unit, or the longest path found in the interconnection
network. Interconnection network paths include all ``output socket ->
bus -> input socket'' chains as well as ``output socket ->
bus -> input socket -> FU'' chains.

\subsection{Implementation Characteristics}
\label{sec:characteristics}

The cost database contains multiple entries for each hardware resource
type of the ADF~\cite{ADF-specs}. Each entry has the following fields
(if not otherwise mentioned) representing the implementation characteristics:
\begin{description}
\item[area]%
  Area of an entry. The area unit (mm$^{2}$, equivalent gates) can be
  freely chosen, on condition that the same unit is used throughout
  the database.
\item[delay]%
  Critical path of an entry. The critical path is defined as the
  maximum delay inside an entry.
\item[active energy]%
  Total energy consumption of an entry in a cycle when the entry is used.
\item[idle energy]%
  Total energy consumption of an entry in a cycle when the entry is not used.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Function Units}
\label{sec:first_resource_model}

\emph{TODO HW guys: Check what is the cost difference between operand
and trigger ports. If it is huge then it should be taken into account
by separating the port into an own entry which would have boolean
property ``trigger'' and bit width. However, the variation with the
bit width would not explode the database if the port would be in
separate entry to model sets-opcode/trigger. Output ports should be
considered, whether to separate them also.}

\subsubsection{Architectural Properties}

FUs are defined by the following properties:
\begin{description}
\item[ports]%
  The ports. A list of integers defining their bit widths.

\item[operations]%
  Set of operations the function unit can perform. For each operation,
  the following properties are defined:
  \begin{description}
  \item[name]%
    The name of the operation.
  \item[operands]
    The operands used in the operation. A list of integers defining
    the indices to the \emph{ports} the operation uses.
  \item[pipeline]%
    The pipeline model of the operation. The syntax is described
    in~\cite{ProGeSpecs}.
  \end{description}

\end{description}

\subsubsection{Implementation Characteristics}

Energy characteristics of the FUs differ from other hardware
resources. Idle energy is defined for FUs. A cycle is an idle cycle if
the FU is not triggering any operation. However, the active energy
does not exist for FUs as a whole, but is defined for each
operation. Thus, energy characteristics of the FUs include
(operation,~energy) pairs.

In pipelined FUs, the delay is the maximum delay of any two adjacent
pipeline stages. The delay of a pipeline stage is
\begin{equation}
d_{stage} = \frac{t}{l}
\end{equation}
where 
$t$ is the time taken from reading the register of input stage to
writing the register of next stage,
$l$ is the number of cycles (latency) taken to execute the pipeline stage.
Figure~\ref{fig:pipeline_delay} exemplifies the delay concept of an FU
which has two pipeline stages with different latencies and delays. The
total delay of the represented FU is
\begin{equation}
d = max \left(\frac{27ns}{3}, \frac{22ns}{2} \right) =
    max \left(9ns, 11ns \right) = 11ns
\end{equation}
This delay is pre-computed and stored into the cost database.

\begin{figure}[tb]
\centering \includegraphics[width=0.60\textwidth]{eps/FUDelay.eps}
\caption{A pipeline with two stages having different latencies and delays.}
\label{fig:pipeline_delay}
\end{figure}

\subsubsection{Area}

The area of an FU is obtained directly from the cost database.
\begin{equation}
A_{FU} = A_{db}
\end{equation}
where 
$A_{db}$ is the area of the FU entry (obtained from the cost database).

\subsubsection{Energy}

The energy of an FU cannot be obtained directly from the cost database
but it must be calculated from the energies in the cost database, and
utilization information of different operations as follows
\begin{equation}
E_{FU} = E_i N_i + \sum E_k N_k
\end{equation}

where
$E_i$ is idle energy of the FU (obtained from the cost database),
$N_i$ is the number cycles that the FU is idle
      (obtained from the simulation trace database),
$E_k$ is the energy of the FU consumed for performing operation $k$ once
      (obtained from the cost database), and
$N_k$ is the number of times operation $k$ was executed
      (obtained from the simulation trace database).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Register Files}

\subsubsection{Architectural Properties}

RFs are defined by the following properties:
\begin{description}
\item[size]%
  Number of registers in the RF.
\item[read ports]%
  Number of read ports, that is, output ports.
\item[write ports]%
  Number of write ports, that is, input ports.
\item[bit width]%
  Bit width of the RF, i.e., the width of one register in the RF.
\end{description}

\emph{TODO HW guys: Test the effect of the max read ports at the same
time and max read ports when writing to the same register? Are they
added to the properties?}

\subsubsection{Implementation Characteristics}

RF characteristics differs from the common characteristics. Area,
delay and idle energy is defined for the RFs. A cycle is an idle cycle
if the RF is not reading nor writing. However, active energy does not
exist for the RFs, but the energies are defined for different
combinations of used reads and writes.

\subsubsection{Area}

The area of an RF is obtained directly from the cost database.
\begin{equation}
A_{RF} = A_{db}
\end{equation}
where 
$A_{db}$ is the area of the RF entry (obtained from the cost database).

\subsubsection{Energy}

The energy of an RF cannot be obtained directly from the cost database
but it must be calculated from the energies in the cost database, and
utilization statistics as follows
\begin{equation}
E_{RF} = E_i U_i + \sum_{r=1}^{n} \sum_{w=1}^{m} E_{r,w} U_{r,w}
\end{equation}

where
$E_i$ is idle energy of the RF (obtained from the cost database),
$U_i$ is the number cycles that the RF is idle
      (obtained from the simulation trace database),
$n$   is the number of read ports that the RF contains,
$m$   is the number of write ports that the RF contains,
$E_{r,w}$ is the energy of the RF consumed when $r$ ports are read and 
          $w$ ports are written (obtained from the cost database), and
$U_{r,w}$ is the number of times $r$ reads and $w$ writes occurs
          simultaneously into the RF
          (obtained from the simulation trace database).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Immediate Units}

Immediate units are treated like a specialized RFs.
\footnote{There is one thing that is not captured by the model that
treats IUs as RFs: the instruction templates used to write the long
immediates. They determine, in (small) part, the complication of the
decoding/control logic. There may be two machines with exactly the
same IUs, but with completely different (in number and complication)
templates. Thus, this is out of IU model "as special RF".}

\emph{TODO HW guys: Can IUs be treated like a specialised RF?}

\subsubsection{Architectural Properties}

IUs are defined just like RFs. In the following, the properties
of the RFs are described from the IUs point of view:
\begin{description}
\item[size]%
  Number of registers in the IU (obtained directly from the ADF)
\item[read ports]%
  Number of read ports (obtained directly from the ADF).
\item[write ports]%
  Number of write ports which always equals to one.
\item[bit width]%
  Bit width of the IU, i.e., the width of one register in the IU
  (obtained directly from the ADF).
\end{description}

\subsubsection{Implementation Characteristics}

See RFs.

IU's read operation happens when a value is transported from the IU
into a bus just like normal RF. A write operation is considered to happen
when an instruction template, for which one of the destinations the
IU is, is used.

\subsubsection{Area}

See RFs.

\subsubsection{Energy}

See RFs.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Global Control Unit}

GCU estimation is divided into two parts:
\begin{enumerate}
\item Operations that GCU supports, i.e., jump and trap.

\item Logic that controls the functionality of the processor. Includes
      control signals for interconnection and units.
\end{enumerate}

\subsubsection{Operations}

Operation part of the GCU is estimated like an FU. However, an
additional architectural property, that is, program counter width is
used.
\footnote{If GCU is treated like an FU, a problem is the bitwidth of
the jumping operations. It is crucial because it determines the
maximum size of the instruction address space! So, much more than what
a "normal" input port bitwidth (for an operation) determines...
However, this problem causes very little inaccuracy overall.}

\subsubsection{Control Logic}

\emph{TODO: Totally unknown how to estimate this even with decent accuracy.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transport Buses}

The buses are estimated on per-segment basis. Each segment of the bus
is treated like a bus.

\subsubsection{Architectural Properties}

The bus is defined by the following properties:
\begin{description}
\item[bit width]%
  The width of the bus in bits.
\item[fanin]%
  Number of output sockets connected to the bus. In addition, one
  connection is added if the bus supports short immediates, since it
  can be considered as an output socket. Furthermore, one connection
  is added if the bus is actually a segment and writing to another
  segment, or if the bus is an input bus of a bridge.
\item[fanout]%
  Number of input sockets connected to the bus. Furthermore, one
  connection is added if the bus is actually a segment and reading
  from another segment, or if the bus is an output bus of a bridge.
  \footnote{The situation is different in case of buses implemented
  with tristate input connections. In this case, the output due to an
  output segment is quite different from the other outputs of a
  segment: instead of driving a MUX input (the input socket of a
  unit), this output drives another tristate, which in turn drives the
  next segment.}
\end{description}

\subsubsection{Implementation Characteristics}

Bus characteristics do not differ from the common characteristics:
area, delay, active energy and idle energy. A bus is considered to be
active in the cycles where a value is written into it.

\subsubsection{Area}

The area of a bus is
\begin{equation}
A_{bus} = A_{db}
\end{equation}

where
$A_{db}$ is the area of the bus (obtained from the cost database).

\subsubsection{Energy}

The energy of a bus is
\begin{equation}
E_{bus} = E_i U_i + E_a U_a
\end{equation}

where
$E_i$ is idle energy of the bus (obtained from the cost database),
$U_i$ is the number of cycles that the bus is idle
      (obtained from the simulation trace database),
$E_a$ is active energy of the bus (obtained from the cost database), and
$U_a$ is the number of cycles that the bus is active
      (obtained from the simulation trace database).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Unconnected Sockets}

Sockets that are not connected to the buses are not sensible from the
hardware cost point of view. Thus, they are ignored by the Estimator.
Output sockets are described in Section~\ref{sec:output_sockets} and
input sockets in Section~\ref{sec:input_sockets}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Output Sockets}
\label{sec:output_sockets}

\subsubsection{Architectural Properties}

An output socket entry in the cost database represents a bunch of the
output socket bit lines having same fanin and fanout. Each bunch of
output socket bit lines may have different architectural properties. A
bunch of output socket bit lines are defined by the following
properties:
\begin{description}
\item[bit width]%
  The width of the output socket in bits.
\item[fanout]%
  Number of buses the output socket is connected to.
\item[fanin]%
  Number of ports the output socket is connected to.
\end{description}

\subsubsection{Implementation Characteristics}

Output socket's characteristics do not differ from the common
characteristics: area, delay, active energy and idle energy. An output
socket is considered to be active in the cycles where a value is
written into it from the FU or RF port.

The output socket is estimated by a bunch of bit lines at a
time. Thus, the delay of the output socket is the delay of the slowest
bunch of bit lines.

\subsubsection{Area}

The area of an output socket is obtained by adding up the area of each
bunch of bit lines as follows
\begin{equation}
A_{outsock} = \sum_{k=p}^{1} \sum_{i=n}^{1} \sum_{j=m}^{1} A_{k,i,j}
\end{equation}
where
$p$ is the number of bits in the widest bus or port connected to the
    output socket (obtained from the ADF),
$n$ is the number of ports in the target processor
    (obtained from the ADF),
$m$ is the number of buses in the target processor
    (obtained from the ADF), and
$A_{k,i,j}$ is the area of a bunch of bit lines having bit width $k$,
            driving $j$ buses, and reading from $i$ ports (obtained
            from the cost database).

An output socket which is driving four buses of various bit widths is
depicted in Fig.~\ref{fig:output_socket_eval}. Its total area is
\begin{equation}
A = A_{8,2,4} + A_{4,2,3} + A_{4,1,3} + A_{16,1,1}
\end{equation}
The first eight bit lines of the output socket are reading from two
ports since they contain more than eight bits. In addition, these
first eight bit lines are driving all of the four buses since each of
the buses is composed of eight or more bits. Due to the fact that the
bit width of three buses and two ports, i.e., namely Bus2, Bus3, Bus4,
Port1, and Port2 is more than eight and at least 12, next four bit
lines read from those two ports and drive these three buses. Next
four bit lines are reading from only one port, i.e., Port2, and
writing to the same three buses than the previous four bit lines. The
upper 16 bit lines of the output socket are reading from one port,
i.e., Port2, and driving only one bus, i.e., Bus4, since no other port
or bus have more than 16 bits. Other combinations does not exist. For
example, bit lines that are reading from two ports and writing to two
buses do not exist.

\begin{figure}[tb]
\centering \includegraphics[width=0.70\textwidth]{eps/OutputSocketEval.eps}
\caption{An output socket connected into two output ports and driving
         four buses of various bit widths.}
\label{fig:output_socket_eval}
\end{figure}

\subsubsection{Energy}

The energy of a bunch of bit lines of an output socket is
\begin{equation}
E = E_i U_i + E_a U_a
\end{equation}

where
$E_i$ is idle energy of one bit line of the output socket
      (obtained from the cost database),
$U_i$ is the number cycles that the output socket is idle
      (obtained from the simulation trace database),
$E_a$ is active energy of one bit line of the output socket
      (obtained from the cost database), and
$U_a$ is the number cycles that the output socket is active
      (obtained from the simulation trace database).

The total energy of an output socket is achieved by adding up the energy
of each bunch of bit lines as follows
\begin{equation}
E_{outsock} = \sum_{k=p}^{1} \sum_{i=n}^{1} \sum_{j=m}^{1} E_{k,i,j}
\end{equation}
where
$p$ is the number of bits in the widest bus or port connected to the
    output socket (obtained from the ADF),
$n$ is the number of ports in the target processor
    (obtained from the ADF),
$m$ is the number of buses in the target processor
    (obtained from the ADF), and
$E_{k,i,j}$ is the energy of a bunch of bit lines having bit width $k$,
            driving $j$ buses, and reading from $i$ ports (obtained
            from the cost database).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Input Sockets}
\label{sec:input_sockets}

The input socket is estimated in the same way as the output
socket. The only difference is in the meaning of the architectural
properties, i.e., fanin and fanout. Fanin of an input socket means
the number of buses that the socket is reading whereas fanout means
the number of ports the socket is writing to.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Bridges}
\label{sec:last_resource_model}

The bridges are taken into account in two ways. First, the fanout of
the input bus is incresed by one as well as the fanin of the output
bus of the bridge. Second, an additional output socket is
calculated. The fanin and fanout of the socket are one, and the bit
width is the width of the output bus.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Estimation Statistics}

The Estimator produces the statistics that it calculates for the user
to the standard output. The following statistics about the target TTA
processor are included in the output:
\begin{itemize}
\item total area and energy
\item cycle time and critical path
\item area and energy taken by each FU, RF, IU, GCU, bus and socket
\item separately area and energy taken by all FUs, RFs, IUs,
      buses and socket
\item area and energy taken by the interconnection network, that is,
      the buses and the sockets
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{DATABASES}

All bases of data used by the Estimator are managed externally by the
TCE domain library. These bases of data are: ADF, specified
in~\cite{ADF-specs}, the TPEF, specified in~\cite{TPEF-specs}, the
Simulation Trace Database, specified in~\cite{SimulatorSpecs}, and the
Hardware Database, specified in~\cite{HDBDesign}.

\subsection{Match Type in the Database Queries}
\label{sec:match_type}

\emph{TODO: This Section should be probably removed or
      moved to Estimator design?}

The estimator needs to access entries in the cost database. To
estimate a target processor, queries can be sometimes managed even
though the perfect match for a certain hardware resource does not
exist.  It is totally up to the estimation algorithm implementation
whether it supports non-perfect matching of architecture, i.e., each
estimation algorithm can be queried whether it is able to estimate
costs for the processor part at hand.  Perfect match means that there
is a database entry for which each architectural property of a
hardware resource is equal to. Implementation characteristics of other
entries can be utilized inthe evaluation if the behavior of the
resource is, for example, linear. The following query types, usually
called \emph{match types}, can be supported for each entry field:
\begin{itemize}
\item exact match: matches if an entry with the same value of the
      field given by the search key is found in the database,
\item superset: matches if greater property or a superset is
      found in the database,
\item subset: matches if smaller property or a subset is
      found in the database,
\item interpolation: matches if smaller and greater property is
      found in the database; then linear approximation is used for
      calculating new characteristics for the new database entry.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Intensity of Use}

Some client applications need to perform a very large number of
queries. The number of queries greatly depends on the number of
resources in the ADF but very large machine could require as many as
200 queries.

\section{Files and Configuration}

The input files that the Estimator reads are described in
Section~\ref{sec:perspective}.

\section{Helper Applications}

The hardware database database is a binary SQLite database. The
database can be queried and modified through standard SQL queries
using the SQLite client application.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{OTHER PRODUCT REQUIREMENTS}

\section{Performance Requirements}

The Estimator performs queries to the cost database multiple times in
one estimation. The number of queries depends on the number of
resources in the ADF but in a very large ADF it could be more than
200. Thus, the queries must be fast to avoid bottlenecks in the design
space explorer which is using the Estimator for the cost
estimation. Due to the same reason, all other activities during the
estimation of a resource, in addition to the database queries, must be
fast. In case queries cannot be optimized to be fast enough, other techniques
for speeding up the estimation process can be applied, for example, result 
caching, etc.

\chapter{REJECTED OR ABANDONED IDEAS}

\begin{description}
\item[30.08.2004]
        Cycle time is removed from the architectural properties. It
        was used to find resources made for a specific clock speed. A
        similar, more convinient functionality can be obtained by
        looking for the delays. Cycle time had not much meaning; it
        was more like a synthesis parameter. -~T.~Rantanen

\item[30.08.2004]
        Bus segments could have been handled by using the number of
        segments as one more architectural property for the
        buses. Motiviations for not doing so are: there is no
        difference, essentially, between single- segment bus and one
        segment, and one more parameter/dimension is avoided in the
        bus entry. -~T.~Rantanen

\item[30.08.2004]
        The costs caused by the output part of the segment could have
        been taken into account by adding architectural property
        called ``segment writes'' in to the bus entry. This boolean
        property would indicate whether a segment writes to another
        segment. -~T.~Rantanen

\item[30.08.2004]
        The bit width of the bus couldn't be removed from the
        architectural properties since the characteristics of the MUX
        buses are not linear in terms of bit width. The following area
        and energy models were tried for the buses to avoid bit width
        in the database:

        \begin{equation}
        A = b (A_2 - A_1) + A_1
        \end{equation}
        where
        $b$   is the bit width,
        $A_1$ is the area of the bus having bit width 1, and
        $A_2$ is the area of the bus having bit width 2.

        \begin{equation}
        E = b (E_a - E_c) + E_a + E_i
        \end{equation}
        where
        $b$   is the bit width,
        $E_a$ is the active energy of the bus,
        $E_c$ is the energy consumed in the control of the bus, and
        $E_i$ is the idle energy of the bus.

        This model was rejected since its very dependent on specific
        values. Adding bit width to the database instead of this model
        allows more freedom to the bus model and linearity of the
        characteristics. -~T.~Pitkänen

\item[30.08.2004]
        If the input socket is narrower than the bus it is reading
        from, the costs affected by the extension are
        ignored. -~T.~Rantanen

\item[20.11.2004]
        If a researcher wants to try his/her own cost models, (s)he
        would probably need to use plugin modules to implement
        different estimation behaviour. However, the plugin modules
        are not supported in current estimator. -~T.~Rantanen

\item[20.11.2004]
        The delay required by the input socket data transfer and
        control signal is very different. The control signal must be
        ready when the data is has already passed an output socket and
        a bus. This time is much bigger than the delay of the data
        transfer in the input socket. Delay of the control signal
        cannot be taken into account by the current cost model. This
        causes some error in the energy estimation. If we want to take
        it into account, we would need to but delays for both the data
        transfer and control signal into the database for input
        sockets. -~T.~Pitkänen

\item[10.01.2005]
        The user cannot decide freely which ports has registers. An
        output port always has a register. Hoever, the input port may
        either has a register or not. This means that latency 0 is not
        supported and in case of latency 1, the output register exists
        but the input register does not. -~T.~Rantanen
\end{description}


\chapter{IDEAS FOR FURTHER DEVELOPMENT}

\begin{description}
\item[24.08.2004]
        Estimation of memories could be implemented with the help of
        information in the address spaces. In addition, the size of
        the program can be found in TPEF. -~T.~Rantanen
\end{description}

\chapter{PENDING ISSUES}

\begin{description}
\item[25.09.2005]
        Rejected alternatives should be rechecked. There are some that will be
        used. -~T.~Rantanen

\item[25.09.2005]
        Command line usage should be updated according to plugin usage
        when its clear enough. -~T.~Rantanen

\item[25.09.2005]
        The cost model should be proofread and updated. -~T.~Rantanen
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%  References are generated with BibTeX from a bibtex file.
\bibliographystyle{alpha}
\cleardoublepage
%% Equivalent to a chapter in the table of contents
\addcontentsline{toc}{chapter}{BIBLIOGRAPHY}
\bibliography{Bibliography}


\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
