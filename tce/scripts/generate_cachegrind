#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
    Copyright (c) 2002-2009 Tampere University.

    This file is part of TTA-Based Codesign Environment (TCE).

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
"""
"""
Creates a profile file loadable into kcachegrind for
a visual profile from a ttasim trace database.

@author Pekka Jääskeläinen 2009

Set following settings in ttasim before initializing simulation to
collect the needed traces:

setting procedure_transfer_tracking 1
setting profile_data_saving 1

-*- mode: python -*-
"""
import sys
import os.path

try:
    import sqlite3
except Exception:
    try:
        from pysqlite2 import dbapi2 as sqlite3
    except Exception:
        sys.stderr.write("pysqlite for SQLite 3 library required\n")
        sys.exit(1)


class CachegrindGenerator(object):

    def __init__(self, input_file, target_file):
        input_filen = input_file

        if not os.path.exists(input_filen):
            raise Exception("%s not found" % input_filen)
        self.conn = sqlite3.connect(input_filen)

        call_trace_filen = input_file + ".calls"

        if not os.path.exists(call_trace_filen):
            raise Exception("%s not found" % call_trace_filen)
        self.call_trace = open(call_trace_filen, "r")

        profile_filen = input_file + ".profile"

        if not os.path.exists(profile_filen):
            raise Exception("%s not found" % profile_filen)
        self.profile = open(profile_filen, "r")

        disasm_filen = input_file.split(".trace")[0] + ".S"

        if os.path.exists(disasm_filen):
            self.disasm = open(disasm_filen, "r").readlines()
            # first instruction at 1 (flat disassembly line number)
            positions = "lines"
            self.first_address = 1
        else:
            self.disasm = None
            # first instruction at 0 (instruction address)
            positions = "instructions"
            self.first_address = 0

        self.target_file = open(target_file, 'w+')

        self._load_function_address_ranges()
        self.program_calls = None
        self._load_cycle_count()

        events = ["Cycles"]
        totals = [self.cycle_count]
        if self.disasm:
            events.append("NOPs")
            totals.append(self._count_nops())

        self.target_file.write(
"""# Trace file generated by 'generate_cachegrind' script of TCE.
cmd: ttasim
positions: %s
events: %s
summary: %s
fl=%s
""" % (positions, " ".join(events), " ".join([str(x) for x in totals]), disasm_filen))

    def _count_nops(self):
        nops = 0
        for line in self.disasm:
            nops += line.count('...')
        return nops

    def _load_cycle_count(self):
        cursor = self.conn.cursor()
        cursor.execute('''
SELECT integer_value FROM totals WHERE value_name = 'cycle_count';''')
        self.cycle_count = int(cursor.fetchone()[0])
        cursor.close()

    def _load_function_address_ranges(self):
        """Loads the different data structures used to find procedure
        address range info."""
        cursor = self.conn.cursor()
        address_ranges = cursor.execute('''
SELECT first_address, last_address, procedure_name
FROM procedure_address_range
ORDER BY first_address ASC;''')
        self.f_entry_points = dict()
        for range in address_ranges:
            self.f_entry_points[int(range[0])] = range[2]
        cursor.close()

    def generate_instruction_profile(self):
        """Outputs the instruction profile to standard output.

        Also prints out the call data."""
        cursor = self.conn.cursor()
        i_exec_counts = [(int(x.split('\t')[0]), int(x.split('\t')[1])) for x in self.profile.readlines()]

        got_one = False
        for (address, count) in i_exec_counts:
            got_one = True
            if address in self.f_entry_points:
                func = self.f_entry_points[address]
                self.target_file.write('\nfn=%s\n' % func)
            # Print exclusive instruction profile data.
            self.target_file.write('%d %d' % \
                        (address + self.first_address, count))

            if self.disasm:
                line = self.disasm[address]
                nops = line.count('...')
                slots = line.count(',') + 1

                if slots == 0:
                    raise Exception("Illegal assembly file, did you produce it with tcedisasm -F?")
                # Count the bus utilization percentage.
                self.target_file.write(' %d' % nops)

            self.target_file.write('\n')

            if address in self.program_calls:
                # Print inclusive call data for all destination functions
                # called by the call instruction (can be many in case of
                # indirect function pointer calls).
                calls = self.program_calls[address]
                for call in calls.values():
                    self.target_file.write('cfn=%s\n' \
                                               'calls=%d %d\n' \
                                               '%d %d\n' % \
                                               (call.target_func, call.total_calls,
                                                call.target_address + self.first_address,
                                                address + self.first_address,
                                                call.total_inclusive_cycles))

        #for row in results:

        cursor.close()

        if not got_one:
            sys.stderr.write("No instruction counts found. Enable 'profile_data_saving' in ttasim.\n")
            sys.exit(1)

    def generate_call_data(self):
        """Generates the inclusive call profile data to the output."""

        class TraceCall(object):
            """Info about a single call in the trace."""
            def __init__(self, func, target_address, source_address, start_cycle):
                self.target_func = func
                self.target_address = target_address
                self.source_address = source_address
                self.total_inclusive_cycles = 0
                self.start_cycle = start_cycle

            def set_end_cycle(self, end_cycle):
                self.end_cycle = end_cycle
                self.total_inclusive_cycles = self.end_cycle - self.start_cycle

        class ProgramCall(object):
            """Call stats of a call in the program."""
            def __init__(self, target_func, source_address, target_address):
                self.source_address = source_address
                self.target_func = target_func
                self.target_address = target_address
                self.total_inclusive_cycles = 0
                self.total_calls = 0

        call_stack = []
        # Calls in the program, caller_address -> {callee_address, ProgramCall}
        # 2 levels of mapping due to the possibility of function pointer calls
        # to multiple target functions
        program_calls = {}

        # Go through the call trace, pushing call objects to the "call stack"
        # and augmenting their data whenever a call has returned.
        cursor = self.conn.cursor()

        procedures = [x for x in cursor.execute('''
SELECT procedure_address_range.first_address as address,
       procedure_address_range.last_address,
       procedure_address_range.procedure_name
FROM procedure_address_range
ORDER BY address ASC;
''')]
        def find_procedure_name(address, procedures=procedures):
            for (first_addr, last_addr, name) in procedures:
                if int(first_addr) <= address and address <= int(last_addr):
                    return name
            raise Exception("Could not find procedure for instruction at %d." % address)

        def update_program_call_stats(finished_call, program_calls=program_calls):
            program_call_dict = \
                program_calls.get(finished_call.source_address, {})

            program_call = \
                program_call_dict.get(\
                finished_call.target_address,
                ProgramCall(\
                    finished_call.target_func, finished_call.source_address,
                    finished_call.target_address))
            program_call.total_inclusive_cycles += finished_call.total_inclusive_cycles
            program_call.total_calls += 1

            program_call_dict[finished_call.target_address] = program_call
            program_calls[finished_call.source_address] = program_call_dict

        got_one = False
        for call_info in self.call_trace.readlines():
            cycle, address, source_address, is_return = \
                call_info.split('\t')

            cycle = int(cycle)
            address = int(address)
            source_address = int(source_address)
            is_return = bool(is_return.strip() != '0')

            procedure_name = find_procedure_name(address)

            got_one = True
            if not is_return:
                call_stack.append(TraceCall(procedure_name, address, source_address, cycle))
            else:
                finished_call = call_stack.pop()
                finished_call.set_end_cycle(cycle)
                update_program_call_stats(finished_call)

        if not got_one:
            sys.stderr.write(
                "No call trace available. " +
                "Enable 'procedure_transfer_tracking' in ttasim.\n")
            sys.exit(1)


        max_cycle = self.cycle_count
        # Unwind the call stack as exit has been called at some point
        # without returning from all functions (usually just _start).
        # Need to account the unreturned function calls to the
        # call profile.
        while len(call_stack) > 0:
            finished_call = call_stack.pop()
            finished_call.set_end_cycle(max_cycle)

            if finished_call.source_address == 0:
                continue # skip _start, no one calls it, called on reset automatically

            update_program_call_stats(finished_call)

        self.program_calls = program_calls
        cursor.close()

    def finish(self):
        """Flushes and closes the output and DB connections."""
        self.target_file.close()
        self.conn.close()


if __name__ == "__main__":
    try:
        trace_file = sys.argv[1]
        if not os.path.exists(sys.argv[1]):
            raise Exception()
    except Exception:
        sys.stderr.write("Input trace database file missing.\n")
        sys.exit(1)

    try:
        output_file = sys.argv[2]
    except Exception:
        output_file = trace_file + ".cachegrind"

    gen = CachegrindGenerator(trace_file, output_file)
    gen.generate_call_data()
    gen.generate_instruction_profile()
    gen.finish()

