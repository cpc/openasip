/*
 Copyright (C) 2021-2023 Tampere University.

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA

*/
/**
 * @file RV32MicroCodeGenerator.cc
 *
 * Implementation of RV32MicroCodeGenerator class.
 *
 * @author Kari Hepola 2021-2023 (kari.hepola@tuni.fi)
 * @note rating: red
 */

#include <cmath>
#include <vector>
#include <string>
#include <memory>
#include <fstream>
#include <utility>
#include <bitset>

#include "RV32MicroCodeGenerator.hh"
#include "Machine.hh"
#include "Socket.hh"
#include "Bus.hh"
#include "RFPort.hh"
#include "FUPort.hh"
#include "BaseFUPort.hh"
#include "Port.hh"
#include "SpecialRegisterPort.hh"
#include "FunctionUnit.hh"
#include "RegisterFile.hh"
#include "InstructionField.hh"
#include "BinaryEncoding.hh"
#include "MoveSlot.hh"
#include "DestinationField.hh"
#include "Instruction.hh"
#include "HWOperation.hh"
#include "TerminalRegister.hh"
#include "TerminalFUPort.hh"
#include "SimValue.hh"
#include "TerminalImmediate.hh"
#include "Move.hh"
#include "CodeCompressorPlugin.hh"
#include "ProgramImageGenerator.hh"
#include "InstructionBitVector.hh"
#include "Environment.hh"
#include "HDLTemplateInstantiator.hh"
#include "FileSystem.hh"
#include "MachineConnectivityCheck.hh"
#include "ControlUnit.hh"
#include "OperationTriggeredFormat.hh"
#include "RISCVFields.hh"
#include "InstructionFormat.hh"
#include "BitVector.hh"
#include "MapTools.hh"
#include "VectorTools.hh"
#include "MachineConnectivityCheck.hh"
#include "LicenseGenerator.hh"

#define RV32_RTL_GEN_VERBOSE 0

using namespace std;

namespace ProGe {

RV32MicroCodeGenerator::RV32MicroCodeGenerator(
    const Machine& machine, const BinaryEncoding& bem,
    const std::string& entityName)
    : 
      MicroCodeGenerator(machine, bem, entityName),
      RF_(NULL),
      rs1Bus_(NULL),
      rs2Bus_(NULL),
      rdBus_(NULL),
      rs1RFPort_(NULL),
      rs2RFPort_(NULL),
      rdRFPort_(NULL),
      pig_(new ProgramImageGenerator()),
      NOP_(""),
      bypassInstructionRegister_(false),
      hasForwarding_(false),
      variableLengthOpLatency_(false),
      eVariant_(false) {
    Machine::BusNavigator busNav = machine.busNavigator();
    for (int i = 0; i < busNav.count(); i++) {
        busses_.push_back(busNav.item(i));
    }

    initializeOperations();

    findOperationPorts();
    findOperationSources();

    pig_->loadBEM(bem);
    pig_->loadMachine(machine);

    generateNOP();

    findRF();
    connectRF();
    findBusWidths();
    if (RV32_RTL_GEN_VERBOSE) {
        if (hasForwarding_) {
            std::cout << "Generated bypass logic" << std::endl;
        } else {
            std::cout << "Not required connectivity for bypass logic"
                      << std::endl;
        }
    }
}

RV32MicroCodeGenerator::~RV32MicroCodeGenerator() { delete pig_; }

void
RV32MicroCodeGenerator::findOperationSources() {
    for (const auto& op : rdPorts_) {
        if (sourceOperationMap_.count(op.second)) {
            sourceOperationMap_.at(op.second).push_back(op.first);
        } else {
            sourceOperationMap_.insert({op.second, {op.first}});
        }
    }
}

void
RV32MicroCodeGenerator::initializeOperations() {
    for (int i = 0; i < bem_->instructionFormatCount(); i++) {
        InstructionFormat fTemp = bem_->instructionFormat(i);
        std::map<std::string, int> ops = fTemp.operations();
        for (const auto& op : ops) {
            std::string name = op.first;
            int encoding = op.second;
            BitVector bits = BitVector();
            if (fTemp.name() == "riscv_r_type") {
                bits.pushBack(encoding, 17);
                std::string encBits = bits.toString();
                if (MapTools::containsKey(operationNameTable, name)) {
                    const std::string tceOpName = operationNameTable.at(name);
                    rOperations_.insert({tceOpName, encBits});
                } else {
                    rOperations_.insert({name, encBits});
                }
            } else if (fTemp.name() == "riscv_i_type") {
                std::string encBits;
                // Shift operations use imm bits for opcode
                if (name == "srai" || name == "slli" || name == "srli") {
                    bits.pushBack(encoding, 17);
                    encBits = bits.toString();
                } else {
                    bits.pushBack(encoding, 10);
                    encBits = bits.toString();
                }
                if (MapTools::containsKey(operationNameTable, name)) {
                    const std::string tceOpName = operationNameTable.at(name);
                    iOperations_.insert({tceOpName, encBits});
                } else {
                    iOperations_.insert({name, encBits});
                }
            } else if (fTemp.name() == "riscv_s_type") {
                bits.pushBack(encoding, 10);
                std::string encBits = bits.toString();
                if (MapTools::containsKey(operationNameTable, name)) {
                    const std::string tceOpName = operationNameTable.at(name);
                    sOperations_.insert({tceOpName, encBits});
                } else {
                    sOperations_.insert({name, encBits});
                }
            } else if (fTemp.name() == "riscv_b_type") {
                bits.pushBack(encoding, 10);
                std::string encBits = bits.toString();
                if (MapTools::containsKey(operationNameTable, name)) {
                    const std::string tceOpName = operationNameTable.at(name);
                    bOperations_.insert(
                        {operationNameTable.at(name), encBits});
                } else {
                    bOperations_.insert({name, encBits});
                }
            } else if (fTemp.name() == "riscv_u_type") {
                bits.pushBack(encoding, 7);
                std::string encBits = bits.toString();
                if (MapTools::containsKey(operationNameTable, name)) {
                    const std::string tceOpName = operationNameTable.at(name);
                    ujOperations_.insert({tceOpName, encBits});
                } else {
                    ujOperations_.insert({name, encBits});
                }
            } else if (fTemp.name() == "riscv_j_type") {
                bits.pushBack(encoding, 7);
                std::string encBits = bits.toString();
                if (MapTools::containsKey(operationNameTable, name)) {
                    const std::string tceOpName = operationNameTable.at(name);
                    ujOperations_.insert({tceOpName, encBits});
                } else {
                    ujOperations_.insert({name, encBits});
                }
            }
        }
    }
}

void
RV32MicroCodeGenerator::validateOperations() const {
    for (const auto& op : sOperations_) {
        const std::string opName = op.first;
        if (!machine_->hasOperation(opName)) {
            throwOperationNotFoundError(opName);
        }
    }
    for (const auto& op : bOperations_) {
        const std::string opName = op.first;
        if (!machine_->hasOperation(opName)) {
            throwOperationNotFoundError(opName);
        }
    }
    for (const auto& op : ujOperations_) {
        const std::string opName = op.first;
        if (op.first != "move") {
            if (!machine_->hasOperation(opName)) {
                throwOperationNotFoundError(opName);
            }
        }
    }
    for (const auto& op : rOperations_) {
        const std::string opName = op.first;
        if (!machine_->hasOperation(opName)) {
            throwOperationNotFoundError(opName);
        }
    }
}

FunctionUnit*
RV32MicroCodeGenerator::mapFunctionUnit(const std::string& operation) const {
    Machine::FunctionUnitNavigator fuNav = machine_->functionUnitNavigator();
    for (int i = 0; i < fuNav.count(); i++) {
        FunctionUnit* fu = fuNav.item(i);
        if (fu->hasOperation(operation)) {
            return fu;
        }
    }
    if (machine_->controlUnit()->hasOperation(operation)) {
        return static_cast<FunctionUnit*>(machine_->controlUnit());
    }
    throwOperationNotFoundError(operation);
    return NULL;
}

void
RV32MicroCodeGenerator::throwOperationNotFoundError(
    const std::string& op) const {
    std::string msg = "Cannot find operation '" + op + "\' in machine.";
    throw InvalidData(__FILE__, __LINE__, __func__, msg);
}

void
RV32MicroCodeGenerator::throwTriggeringPortError(
    const BaseFUPort* port, const std::string& type) const {
    std::string fuName = port->parentUnit()->name();
    std::string msg = type + " operand port \'" + port->name() +
                      "\' in FU \'" + fuName +
                      "\' not mapped as triggering port";
    throw InvalidData(__FILE__, __LINE__, __func__, msg);
}

void
RV32MicroCodeGenerator::throwInputPortError(
    const BaseFUPort* port, const std::string& type) const {
    std::string fuName = port->parentUnit()->name();
    std::string msg = type + " operand port \'" + port->name() +
                      "\' in FU \'" + fuName + "\' not mapped as input";
    throw InvalidData(__FILE__, __LINE__, __func__, msg);
}

void
RV32MicroCodeGenerator::throwOutputPortError(
    const BaseFUPort* port, const std::string& type) const {
    std::string fuName = port->parentUnit()->name();
    std::string msg = type + " operand port \'" + port->name() +
                      "\' in FU \'" + fuName + "\' not mapped as output";
    throw InvalidData(__FILE__, __LINE__, __func__, msg);
}

void
RV32MicroCodeGenerator::throwOperandCountError(
    const std::string& op, int required, int found) const {
    std::string msg = "Operation " + op +
                      " has invalid amount of operands. " +
                      std::to_string(required) + " required, " +
                      std::to_string(found) + " found.";
    throw InvalidData(__FILE__, __LINE__, __func__, msg);
}

void
RV32MicroCodeGenerator::addRPorts(const std::string& opName) {
    FunctionUnit* fu = mapFunctionUnit(opName);
    HWOperation* op = fu->operation(opName);
    if (op->operandCount() != 3) {
        throwOperandCountError(opName, 3, op->operandCount());
    }
    FUPort* rs1Port = op->port(1);
    ;
    FUPort* rs2Port = op->port(2);
    FUPort* rdPort = op->port(3);
    if (!rs1Port->isTriggering()) {
        throwTriggeringPortError(rs1Port, "rs1");
    }
    if (!rs2Port->isInput()) {
        throwInputPortError(rs2Port, "rs2");
    }
    if (!rdPort->isOutput()) {
        throwOutputPortError(rdPort, "rd");
    }
    rs1Ports_.insert({opName, rs1Port});
    rs2Ports_.insert({opName, rs2Port});
    // Do not add custom ops to simm ports
    if (MapTools::containsValue(operationNameTable, opName)) {
        const std::string riscvOpName =MapTools::keyForValue
        <string, map<string, string>, string>(operationNameTable, opName);
        // Do not add M-extension ops
        if (!VectorTools::containsValue(mExtensionOps, riscvOpName)) {
            simmPorts_.insert({opName, rs2Port});
        }
    }
    rdPorts_.insert({opName, rdPort});
}

void
RV32MicroCodeGenerator::addIPorts(const std::string& opName) {
    if (rOperations_.count(opName)) {
        return;
    }
    FunctionUnit* fu = mapFunctionUnit(opName);
    HWOperation* op = fu->operation(opName);
    const int operandCount = (opName == "calla") ? 2 : 3;
    if (op->operandCount() != operandCount) {
        throwOperandCountError(opName, operandCount, op->operandCount());
    }
    FUPort* rs1Port = op->port(1);
    FUPort* simmPort = op->port(2);
    BaseFUPort* rdPort;
    if (opName != "calla") {
        rdPort = op->port(3);
        if (!rdPort->isOutput()) {
            throwOutputPortError(rdPort, "rd");
        }
    } else {
        rs1Port = op->port(2);
        simmPort = op->port(1);
        rdPort = machine_->controlUnit()->returnAddressPort();
    }
    rs1Ports_.insert({opName, rs1Port});
    simmPorts_.insert({opName, simmPort});
    rdPorts_.insert({opName, rdPort});
}

void
RV32MicroCodeGenerator::addBPorts(const std::string& opName) {
    FunctionUnit* fu = mapFunctionUnit(opName);
    HWOperation* op = fu->operation(opName);
    if (op->operandCount() != 3) {
        throwOperandCountError(opName, 3, op->operandCount());
    }
    FUPort* simmPort = op->port(1);
    FUPort* rs1Port = op->port(2);
    FUPort* rs2Port = op->port(3);
    if (!simmPort->isTriggering()) {
        throwTriggeringPortError(simmPort, "imm");
    } else if (!rs1Port->isInput()) {
        throwInputPortError(rs1Port, "rs1");
    } else if (!rs2Port->isInput()) {
        throwInputPortError(rs1Port, "rs2");
    }
    rs1Ports_.insert({opName, rs1Port});
    simmPorts_.insert({opName, simmPort});
    rs2Ports_.insert({opName, rs2Port});
}

void
RV32MicroCodeGenerator::addUJPorts(const std::string& opName) {
    if (opName == "move") {
        return;
    }
    ControlUnit* fu = dynamic_cast<ControlUnit*>(mapFunctionUnit(opName));
    HWOperation* op = fu->operation(opName);
    FUPort* simmPort = op->port(1);
    BaseFUPort* rdPort;
    if (opName == "apc") {
        rdPort = op->port(2);
        if (!rdPort->isOutput()) {
            throwOutputPortError(rdPort, "rd");
        }
    } else {
        rdPort = fu->returnAddressPort();
    }
    if (!simmPort->isTriggering()) {
        throwTriggeringPortError(simmPort, "imm");
    }
    rdPorts_.insert({opName, rdPort});
    simmPorts_.insert({opName, simmPort});
}

void
RV32MicroCodeGenerator::addSPorts(const std::string& opName) {
    FunctionUnit* fu = mapFunctionUnit(opName);
    HWOperation* op = fu->operation(opName);
    if (op->operandCount() != 3) {
        throwOperandCountError(opName, 3, op->operandCount());
    }
    FUPort* rs1Port = op->port(1);
    FUPort* simmPort = op->port(2);
    FUPort* rs2Port = op->port(3);
    if (!rs1Port->isTriggering()) {
        throwTriggeringPortError(rs1Port, "rs1");
    }
    if (!rs2Port->isInput()) {
        throwInputPortError(rs2Port, "rs2");
    }
    if (!simmPort->isInput()) {
        throwInputPortError(simmPort, "imm");
    }
    rs1Ports_.insert({opName, rs1Port});
    simmPorts_.insert({opName, simmPort});
    rs2Ports_.insert({opName, rs2Port});
}

void
RV32MicroCodeGenerator::findOperationPorts() {
    for (const auto& op : rOperations_) {
        addRPorts(op.first);
    }
    for (const auto& op : iOperations_) {
        addIPorts(op.first);
    }
    for (const auto& op : sOperations_) {
        addSPorts(op.first);
    }
    for (const auto& op : bOperations_) {
        addBPorts(op.first);
    }
    for (const auto& op : ujOperations_) {
        addUJPorts(op.first);
    }
}

void
RV32MicroCodeGenerator::generateNOP() {
    CodeCompressorPlugin* compressor = &pig_->compressor();
    Instruction* instruction = new Instruction();
    InstructionBitVector* bits = compressor->bemInstructionBits(*instruction);
    NOP_ = bits->toString();
    delete instruction;
}

void
RV32MicroCodeGenerator::findRF() {
    Machine::RegisterFileNavigator rfNav = machine_->registerFileNavigator();
    // TODO: Design can have multiple register files. Iterate over all of
    // them and find one that fits based on connectivity.
    for (int i = 0; i < rfNav.count(); i++) {
        RegisterFile* rf = rfNav.item(0);
        if (rf->inputPortCount() > 0 && rf->outputPortCount() > 1 &&
            rf->zeroRegister()) {
            if (rf->size() > 31 && rf->width() == 32) {
                RF_ = rf;
            } else if (rf->size() == 16 && rf->width() == 32) {
                RF_ = rf;
                eVariant_ = true;
            }
        }
    }
    if (RF_ == NULL) {
        std::string msg = "Could not find a valid register file for RISC-V";
        throw InvalidData(__FILE__, __LINE__, __func__, msg);
    }
}

void
RV32MicroCodeGenerator::findBusWidths() {
    for (int i = 0; i < bem_->moveSlotCount(); i++) {
        MoveSlot& slot = bem_->moveSlot(i);
        if (slot.name() == rs1Bus_->name()) {
            rs1BusWidth_ = slot.width();
            assert(slot.hasDestinationField());
            rs1RFStart_ = slot.destinationField().width();
            rs1BusStart_ = slot.bitPosition();
        } else if (slot.name() == rs2Bus_->name()) {
            rs2BusWidth_ = slot.width();
            assert(slot.hasDestinationField());
            rs2RFStart_ = slot.destinationField().width();
            rs2BusStart_ = slot.bitPosition();
        } else if (slot.name() == rdBus_->name()) {
            rdBusWidth_ = slot.width();
            rdRFStart_ = 0;
            rdBusStart_ = slot.bitPosition();
        } else if (slot.name() == simmBus_->name()) {
            simmBusWidth_ = slot.width();
            simmRFStart_ = 0;
            simmBusStart_ = slot.bitPosition();
        }
    }
    assert(rs1BusWidth_ > 0);
    assert(rs2BusWidth_ > 0);
    assert(rdBusWidth_ > 0);
    assert(simmBusWidth_ > 0);
}

void
RV32MicroCodeGenerator::connectRF() {
    RFPort* rs1RFPort = NULL;
    RFPort* rs2RFPort = NULL;
    RFPort* rdRFPort = NULL;

    std::vector<RFPort*> RFOutputPorts;
    std::vector<RFPort*> RFInputPorts;
    for (int i = 0; i < RF_->portCount(); i++) {
        RFPort* tmpPort = RF_->port(i);
        if (tmpPort->outputSocket() != NULL) {
            RFOutputPorts.push_back(tmpPort);
        } else if (tmpPort->inputSocket() != NULL) {
            RFInputPorts.push_back(tmpPort);
        }
    }

    assert(RFInputPorts.size() > 0);
    assert(RFOutputPorts.size() > 1);

    Connection rs1;
    Connection rs2;
    Connection rd;
    Connection simm;

    // Find candidates for rs1, rs2 and rd busses.
    bool success = false;
    bool forwarding = false;
    for (int l = 0; l < 2 && !success; l++) {
        // First try with forwarding enabled
        forwarding = !forwarding;
        for (unsigned int i = 0; i < RFOutputPorts.size() && !success; i++) {
            std::vector<RFPort*> tmpRFOutputPorts = RFOutputPorts;
            rs1RFPort = RFOutputPorts.at(i);
            tmpRFOutputPorts.erase(tmpRFOutputPorts.begin() + i);
            for (unsigned int j = 0; j < tmpRFOutputPorts.size() && !success;
                 j++) {
                rs2RFPort = tmpRFOutputPorts.at(j);
                for (unsigned int k = 0; k < RFInputPorts.size() && !success;
                     k++) {
                    std::vector<RFPort*> tmpRFInputPorts;
                    tmpRFInputPorts = RFInputPorts;
                    rdRFPort = RFInputPorts.at(k);

                    rs1.port = rs1RFPort;
                    rs2.port = rs2RFPort;
                    rd.port = rdRFPort;

                    rs1.bus = NULL;
                    rs2.bus = NULL;
                    rd.bus = NULL;
                    simm.bus = NULL;

                    success =
                        findConnectedBusses(rs1, rs2, rd, simm, forwarding);
                    if (success) {
                        break;
                    }
                }
            }
        }
    }

    if (!success) {
        std::string msg =
            "Could not find enough connectivity in the "
            "interconnect to construct RISC-V control and decode logic. Make "
            "sure "
            "the minimum connections are in place and that the operand-port "
            "bindings are valid in FUs";
        throw InvalidData(__FILE__, __LINE__, __func__, msg);
    }
    hasForwarding_ = forwarding;

    rs1Bus_ = rs1.bus;
    rs2Bus_ = rs2.bus;
    rdBus_ = rd.bus;
    simmBus_ = simm.bus;
    rs1RFPort_ = rs1RFPort;
    rs2RFPort_ = rs2RFPort;
    rdRFPort_ = rdRFPort;
}

std::set<Port*>
RV32MicroCodeGenerator::operationPorts(
    const std::unordered_map<std::string, BaseFUPort*>& ports) const {
    std::set<Port*> retval;
    for (const auto& op : ports) {
        retval.insert(static_cast<Port*>(op.second));
    }
    return retval;
}

bool
RV32MicroCodeGenerator::findConnectedBusses(
    Connection& rs1, Connection& rs2, Connection& rd, Connection& simm,
    const bool& forwarding) const {
    std::set<Port*> rs1Ports = operationPorts(rs1Ports_);
    rs1Ports.insert(rs1.port);

    std::set<Port*> rs2Ports = operationPorts(rs2Ports_);
    rs2Ports.insert(rs2.port);

    std::set<Port*> simmPorts = operationPorts(simmPorts_);

    std::set<Port*> rdPorts = operationPorts(rdPorts_);

    if (forwarding) {
        rs1Ports.insert(rdPorts.begin(), rdPorts.end());
        rs2Ports.insert(rdPorts.begin(), rdPorts.end());
    }

    rdPorts.insert(rd.port);

    // Brute forces all combinations until all ports can be mapped to a bus
    for (unsigned int i = 0; i < busses_.size(); i++) {
        std::vector<Bus*> tmpBusses = busses_;
        rs1.bus = NULL;
        rs2.bus = NULL;
        rd.bus = NULL;
        simm.bus = NULL;
        Bus* tmpBus = busses_.at(i);
        if (!MachineConnectivityCheck::isConnected(rs1Ports, *tmpBus)) {
            continue;
        }
        rs1.bus = tmpBus;
        tmpBusses.erase(tmpBusses.begin() + i);
        rs2.bus = NULL;
        for (unsigned int j = 0; j < tmpBusses.size(); j++) {
            tmpBus = tmpBusses.at(j);
            if (!MachineConnectivityCheck::isConnected(rs2Ports, *tmpBus)) {
                continue;
            }
            rs2.bus = tmpBus;
            tmpBusses.erase(tmpBusses.begin() + j);
            for (unsigned int k = 0; k < tmpBusses.size(); k++) {
                tmpBus = tmpBusses.at(k);
                if (!MachineConnectivityCheck::isConnected(
                        rdPorts, *tmpBus)) {
                    continue;
                }
                rd.bus = tmpBus;
                tmpBusses.erase(tmpBusses.begin() + k);
                for (unsigned int h = 0; h < tmpBusses.size(); h++) {
                    tmpBus = tmpBusses.at(h);
                    if (MachineConnectivityCheck::isConnected(
                            simmPorts, *tmpBus) &&
                        tmpBus->immediateWidth() > 0) {
                        simm.bus = tmpBus;
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

std::unordered_map<std::string, InstructionBitVector*>
RV32MicroCodeGenerator::constructRInstructions(Port* src1, Port* src2) const {
    std::unordered_map<std::string, InstructionBitVector*> retval;
    CodeCompressorPlugin* compressor = &pig_->compressor();
    for (const auto& op : rOperations_) {
        Instruction* instruction = new Instruction();
        HWOperation* operation =
            mapFunctionUnit(op.first)->operation(op.first);

        FUPort* rs1Port = static_cast<FUPort*>(rs1Ports_.at(op.first));
        FUPort* rs2Port = static_cast<FUPort*>(rs2Ports_.at(op.first));
        FUPort* rdPort = static_cast<FUPort*>(rdPorts_.at(op.first));

        if (dynamic_cast<RFPort*>(src1)) {
            instruction->addMove(std::make_shared<Move>(
                new TerminalRegister(*src1, 0),
                new TerminalFUPort(*rs1Port, *operation), *rs1Bus_));
        } else {
            instruction->addMove(std::make_shared<Move>(
                new TerminalFUPort(*static_cast<BaseFUPort*>(src1)),
                new TerminalFUPort(*rs1Port, *operation), *rs1Bus_));
        }

        if (dynamic_cast<RFPort*>(src2)) {
            instruction->addMove(std::make_shared<Move>(
                new TerminalRegister(*src2, 0), new TerminalFUPort(*rs2Port),
                *rs2Bus_));
        } else {
            instruction->addMove(std::make_shared<Move>(
                new TerminalFUPort(*static_cast<BaseFUPort*>(src2)),
                new TerminalFUPort(*rs2Port), *rs2Bus_));
        }

        instruction->addMove(std::make_shared<Move>(
            new TerminalFUPort(*rdPort), new TerminalRegister(*rdRFPort_, 0),
            *rdBus_));

        InstructionBitVector* bits =
            compressor->bemInstructionBits(*instruction);
        delete instruction;
        retval.insert({op.first, bits});
    }
    return retval;
}

std::unordered_map<std::string, InstructionBitVector*>
RV32MicroCodeGenerator::constructIInstructions(
    Port* src1, Port* /*src2*/) const {
    std::unordered_map<std::string, InstructionBitVector*> retval;
    CodeCompressorPlugin* compressor = &pig_->compressor();
    for (const auto& op : iOperations_) {
        Instruction* instruction = new Instruction();

        HWOperation* operation =
            mapFunctionUnit(op.first)->operation(op.first);

        FUPort* rdPort = static_cast<FUPort*>(rdPorts_.at(op.first));

        // ALU operations are a special case as they are shared with R type
        if (op.first != "calla") {
            FUPort* simmPort = static_cast<FUPort*>(simmPorts_.at(op.first));
            FUPort* rs1Port = static_cast<FUPort*>(rs1Ports_.at(op.first));

            if (dynamic_cast<RFPort*>(src1)) {
                instruction->addMove(std::make_shared<Move>(
                    new TerminalRegister(*src1, 0),
                    new TerminalFUPort(*rs1Port, *operation), *rs1Bus_));
            } else {
                instruction->addMove(std::make_shared<Move>(
                    new TerminalFUPort(*static_cast<BaseFUPort*>(src1)),
                    new TerminalFUPort(*rs1Port, *operation), *rs1Bus_));
            }

            instruction->addMove(std::make_shared<Move>(
                new TerminalImmediate(SimValue(0, simmBus_->width())),
                new TerminalFUPort(*simmPort), *simmBus_));

        } else {
            FUPort* rs1Port = static_cast<FUPort*>(rs1Ports_.at(op.first));
            FUPort* simmPort = static_cast<FUPort*>(simmPorts_.at(op.first));

            if (dynamic_cast<RFPort*>(src1)) {
                instruction->addMove(std::make_shared<Move>(
                    new TerminalRegister(*src1, 0),
                    new TerminalFUPort(*rs1Port), *rs1Bus_));
            } else {
                instruction->addMove(std::make_shared<Move>(
                    new TerminalFUPort(*static_cast<BaseFUPort*>(src1)),
                    new TerminalFUPort(*rs1Port), *rs1Bus_));
            }

            instruction->addMove(std::make_shared<Move>(
                new TerminalImmediate(SimValue(0, simmBus_->width())),
                new TerminalFUPort(*simmPort, *operation), *simmBus_));
        }

        instruction->addMove(std::make_shared<Move>(
            new TerminalFUPort(*rdPort), new TerminalRegister(*rdRFPort_, 0),
            *rdBus_));

        InstructionBitVector* bits =
            compressor->bemInstructionBits(*instruction);
        delete instruction;
        retval.insert({op.first, bits});
    }
    return retval;
}

std::unordered_map<std::string, InstructionBitVector*>
RV32MicroCodeGenerator::constructSInstructions(Port* src1, Port* src2) const {
    std::unordered_map<std::string, InstructionBitVector*> retval;
    CodeCompressorPlugin* compressor = &pig_->compressor();
    for (const auto& op : sOperations_) {
        Instruction* instruction = new Instruction();
        HWOperation* operation =
            mapFunctionUnit(op.first)->operation(op.first);

        FUPort* simmPort = static_cast<FUPort*>(simmPorts_.at(op.first));
        FUPort* rs1Port = static_cast<FUPort*>(rs1Ports_.at(op.first));
        FUPort* rs2Port = static_cast<FUPort*>(rs2Ports_.at(op.first));

        if (dynamic_cast<RFPort*>(src1)) {
            instruction->addMove(std::make_shared<Move>(
                new TerminalRegister(*src1, 0),
                new TerminalFUPort(*rs1Port, *operation), *rs1Bus_));
        } else {
            instruction->addMove(std::make_shared<Move>(
                new TerminalFUPort(*static_cast<BaseFUPort*>(src1)),
                new TerminalFUPort(*rs1Port, *operation), *rs1Bus_));
        }

        instruction->addMove(std::make_shared<Move>(
            new TerminalImmediate(SimValue(0, simmBus_->width())),
            new TerminalFUPort(*simmPort), *simmBus_));

        if (dynamic_cast<RFPort*>(src2)) {
            instruction->addMove(std::make_shared<Move>(
                new TerminalRegister(*src2, 0), new TerminalFUPort(*rs2Port),
                *rs2Bus_));
        } else {
            instruction->addMove(std::make_shared<Move>(
                new TerminalFUPort(*static_cast<BaseFUPort*>(src2)),
                new TerminalFUPort(*rs2Port), *rs2Bus_));
        }

        InstructionBitVector* bits =
            compressor->bemInstructionBits(*instruction);
        delete instruction;
        retval.insert({op.first, bits});
    }
    return retval;
}

std::unordered_map<std::string, InstructionBitVector*>
RV32MicroCodeGenerator::constructBInstructions(Port* src1, Port* src2) const {
    std::unordered_map<std::string, InstructionBitVector*> retval;
    CodeCompressorPlugin* compressor = &pig_->compressor();
    for (const auto& op : bOperations_) {
        Instruction* instruction = new Instruction();
        HWOperation* operation =
            mapFunctionUnit(op.first)->operation(op.first);

        FUPort* rs1Port = static_cast<FUPort*>(rs1Ports_.at(op.first));
        FUPort* simmPort = static_cast<FUPort*>(simmPorts_.at(op.first));
        FUPort* rs2Port = static_cast<FUPort*>(rs2Ports_.at(op.first));

        instruction->addMove(std::make_shared<Move>(
            new TerminalImmediate(SimValue(0, simmBus_->width())),
            new TerminalFUPort(*simmPort, *operation), *simmBus_));

        if (dynamic_cast<RFPort*>(src1)) {
            instruction->addMove(std::make_shared<Move>(
                new TerminalRegister(*src1, 0), new TerminalFUPort(*rs1Port),
                *rs1Bus_));
        } else {
            instruction->addMove(std::make_shared<Move>(
                new TerminalFUPort(*static_cast<BaseFUPort*>(src1)),
                new TerminalFUPort(*rs1Port), *rs1Bus_));
        }

        if (dynamic_cast<RFPort*>(src2)) {
            instruction->addMove(std::make_shared<Move>(
                new TerminalRegister(*src2, 0), new TerminalFUPort(*rs2Port),
                *rs2Bus_));
        } else {
            instruction->addMove(std::make_shared<Move>(
                new TerminalFUPort(*static_cast<BaseFUPort*>(src2)),
                new TerminalFUPort(*rs2Port), *rs2Bus_));
        }

        InstructionBitVector* bits =
            compressor->bemInstructionBits(*instruction);
        delete instruction;
        retval.insert({op.first, bits});
    }
    return retval;
}

std::unordered_map<std::string, InstructionBitVector*>
RV32MicroCodeGenerator::constructUJInstructions() const {
    std::unordered_map<std::string, InstructionBitVector*> retval;
    CodeCompressorPlugin* compressor = &pig_->compressor();
    InstructionBitVector* bits;

    for (const auto& op : ujOperations_) {
        Instruction* instruction = new Instruction();
        if (op.first == "move") {
            HWOperation* operation = mapFunctionUnit("add")->operation("add");
            FUPort* rs1Port = static_cast<FUPort*>(rs1Ports_.at("add"));
            FUPort* simmPort = static_cast<FUPort*>(simmPorts_.at("add"));
            FUPort* rdPort = static_cast<FUPort*>(rdPorts_.at("add"));
            instruction->addMove(std::make_shared<Move>(
                new TerminalRegister(*rs1RFPort_, 0),
                new TerminalFUPort(*rs1Port, *operation), *rs1Bus_));

            instruction->addMove(std::make_shared<Move>(
                new TerminalImmediate(SimValue(0, simmBus_->width())),
                new TerminalFUPort(*simmPort), *simmBus_));

            instruction->addMove(std::make_shared<Move>(
                new TerminalFUPort(*rdPort),
                new TerminalRegister(*rdRFPort_, 0), *rdBus_));

            bits = compressor->bemInstructionBits(*instruction);
            retval.insert({"move", bits});
            delete instruction;
        } else if (op.first == "callr" or op.first == "apc") {
            FUPort* rdPort = static_cast<FUPort*>(rdPorts_.at(op.first));

            instruction->addMove(std::make_shared<Move>(
                new TerminalFUPort(*rdPort),
                new TerminalRegister(*rdRFPort_, 0), *rdBus_));

            bits = compressor->bemInstructionBits(*instruction);
            delete instruction;
            retval.insert({op.first, bits});

        } else {
            FUPort* simmPort = static_cast<FUPort*>(simmPorts_.at(op.first));
            FUPort* rdPort = static_cast<FUPort*>(rdPorts_.at(op.first));

            HWOperation* operation =
                mapFunctionUnit(op.first)->operation(op.first);

            instruction->addMove(std::make_shared<Move>(
                new TerminalImmediate(SimValue(0, simmBus_->width())),
                new TerminalFUPort(*simmPort, *operation), *simmBus_));

            instruction->addMove(std::make_shared<Move>(
                new TerminalFUPort(*rdPort),
                new TerminalRegister(*rdRFPort_, 0), *rdBus_));

            bits = compressor->bemInstructionBits(*instruction);
            delete instruction;

            retval.insert({op.first, bits});
        }
    }

    return retval;
}

void
RV32MicroCodeGenerator::addBitsToMap(
    std::unordered_map<std::string, InstructionBitVector*> instructions,
    const std::map<std::string, std::string> encodings,
    std::ofstream& stream) const {
    assert(instructions.size() == encodings.size());
    for (const auto& op : instructions) {
        stream << "    elsif(fu_opcode(" << encodings.at(op.first).size()
               << " - 1 downto 0) = "
               << "\"" << encodings.at(op.first) << "\""
               << ") then" << std::endl
               << "      moves <= \"" << op.second->toString() << "\";"
               << std::endl;
        delete op.second;
    }
}

void
RV32MicroCodeGenerator::generateFUTargetProcess(std::ofstream& stream) {
    std::unordered_map<std::string, std::string> operations;
    operations.insert(rOperations_.begin(), rOperations_.end());
    operations.insert(iOperations_.begin(), iOperations_.end());
    operations.insert(sOperations_.begin(), sOperations_.end());
    operations.insert(bOperations_.begin(), bOperations_.end());
    operations.insert(ujOperations_.begin(), ujOperations_.end());
    int len = std::ceil(std::log2(sourceOperationMap_.size()));

    stream << "  process(fu_opcode)" << std::endl
           << "  begin" << std::endl
           << "    target_fu <= to_unsigned(0, " << len << ");" << std::endl;

    int id = 0;
    bool firstCond = true;
    std::string cond;
    for (const auto& p : sourceOperationMap_) {
        sourcePortID_.insert({p.first, id});
        for (const auto& op : p.second) {
            if (firstCond) {
                cond = "    if ";
                firstCond = false;
            } else {
                cond = "    elsif ";
            }
            // Add is a special case as it is used in LUI
            if (op == "add") {
                int iLen = iOperations_.at(op).size();
                int uLen = ujOperations_.at("move").size();
                stream << cond << "fu_opcode(" << iLen << "-1 downto 0)"
                       << " = \"" << iOperations_.at(op) << "\""
                       << " or "
                       << "fu_opcode = \"" << rOperations_.at(op)
                       << "\" or fu_opcode(" << uLen << "-1 downto 0) = \""
                       << ujOperations_.at("move") << "\""
                       << " then\n";

            } else if (iOperations_.count(op) && rOperations_.count(op)) {
                int iLen = iOperations_.at(op).size();
                stream << cond << "fu_opcode(" << iLen << "-1 downto 0)"
                       << " = \"" << iOperations_.at(op) << "\"  or "
                       << "fu_opcode = \"" << rOperations_.at(op)
                       << "\" then\n";
            } else {
                int opLen = operations.at(op).size();
                stream << cond << "fu_opcode(" << opLen << "-1 downto 0)"
                       << "= \"" << operations.at(op) << "\" then\n";
            }
            stream << "      target_fu <= to_unsigned(" << id << ", " << len
                   << ");\n";
        }
        id++;
    }
    stream << "    end if;" << std::endl << "  end process;" << std::endl;

    stream << std::endl << std::endl;
    stream << "  process(clk, rstx)" << std::endl
           << "  begin" << std::endl
           << "    if(rstx = '0') then" << std::endl
           << "      target_fu_r <= (others => '0');" << std::endl
           << "    elsif clk'event and clk = '1' then" << std::endl
           << "      if glock_in = '0' and halt = '0' then" << std::endl
           << "        target_fu_r <= target_fu;" << std::endl
           << "      end if;" << std::endl
           << "    end if;" << std::endl
           << "  end process;" << std::endl
           << std::endl
           << std::endl;
}

void
RV32MicroCodeGenerator::addRs1ForwardingConditions(
    std::map<std::string, std::string> ops,
    std::unordered_map<std::string, InstructionBitVector*> (
        ProGe::RV32MicroCodeGenerator::*instructionFunc)(Port* p1, Port* p2)
        const,
    std::ofstream& stream) const {
    bool firstOpcodeCond = true;
    for (const auto& op : ops) {
        std::string opcodeCond = "        elsif ";
        if (firstOpcodeCond) {
            opcodeCond = "        if ";
            firstOpcodeCond = false;
        }
        stream << opcodeCond << "fu_opcode(" << op.second.size()
               << "-1 downto 0) = \"" << op.second << "\"";
        if (rOperations_.count(op.first) && iOperations_.count(op.first)) {
            stream << " or fu_opcode(" << iOperations_.at(op.first).size()
                   << "-1 downto 0) = \"" << iOperations_.at(op.first)
                   << "\"";
        }
        stream << "then\n";
        bool firstTargetCond = true;
        for (const auto& p : sourceOperationMap_) {
            std::string targetCond = "          elsif ";
            if (firstTargetCond) {
                targetCond = "          if ";
                firstTargetCond = false;
            }
            stream << targetCond + "target_fu_r = "
                   << sourcePortID_.at(p.first) << " then \n";
            std::unordered_map<std::string, InstructionBitVector*>
                instructions = (this->*instructionFunc)(p.first, rs2RFPort_);
            std::string bits = instructions.at(op.first)->toString();
            reverse(bits.begin(), bits.end());
            bits = bits.substr(rs1BusStart_, rs1BusWidth_);
            reverse(bits.begin(), bits.end());
            stream << "            moves(rs1_start_c + rs1_width_c -1 downto"
                   << " rs1_start_c)"
                   << " <= \"" << bits << "\";\n";
            for (const auto& val : instructions) {
                delete val.second;
            }
        }
        stream << "          end if;" << std::endl;
    }
    stream << "        end if;" << std::endl;
}

void
RV32MicroCodeGenerator::addRs2ForwardingConditions(
    std::map<std::string, std::string> ops,
    std::unordered_map<std::string, InstructionBitVector*> (
        ProGe::RV32MicroCodeGenerator::*instructionFunc)(Port* p1, Port* p2)
        const,
    std::ofstream& stream) const {
    bool firstOpcodeCond = true;
    for (const auto& op : ops) {
        std::string opcodeCond = "        elsif ";
        if (firstOpcodeCond) {
            opcodeCond = "        if ";
            firstOpcodeCond = false;
        }
        stream << opcodeCond << "fu_opcode(" << op.second.size()
               << "-1 downto 0) = \"" << op.second << "\" then\n";
        bool firstTargetCond = true;
        for (const auto& p : sourceOperationMap_) {
            std::string targetCond = "          elsif ";
            if (firstTargetCond) {
                targetCond = "          if ";
                firstTargetCond = false;
            }
            stream << targetCond + "target_fu_r = "
                   << sourcePortID_.at(p.first) << " then \n";
            std::unordered_map<std::string, InstructionBitVector*>
                instructions = (this->*instructionFunc)(rs1RFPort_, p.first);
            std::string bits = instructions.at(op.first)->toString();
            reverse(bits.begin(), bits.end());
            bits = bits.substr(rs2BusStart_, rs2BusWidth_);
            reverse(bits.begin(), bits.end());
            stream << "            moves(rs2_start_c + rs2_width_c -1 downto"
                   << " rs2_start_c)"
                   << " <= \"" << bits << "\";\n";
            for (const auto& val : instructions) {
                delete val.second;
            }
        }
        stream << "          end if;" << std::endl;
    }
    stream << "        end if;" << std::endl;
}

void
RV32MicroCodeGenerator::generateMap(const std::string& dstDirectory) {
    /*TODO: The if structure should be replaced with a case statement
            The problem is that the fu_opcode's width is different between
            formats. Don't care states in a case statement
             is a VHDL-2OO8 feature
    */
    const std::string DS = FileSystem::DIRECTORY_SEPARATOR;
    std::string mapFile = dstDirectory + DS + "rv32_microcode.vhdl";

    std::ofstream stream;
    stream.open(mapFile);
    stream << LicenseGenerator::generateMITLicense("2023", "--");

    stream << "library IEEE;" << std::endl
           << "use IEEE.std_logic_1164.all;" << std::endl
           << "use IEEE.numeric_std.all;" << std::endl
           << "use work." << entityName_ << "_globals.all;" << std::endl
           << std::endl
           << std::endl;

    stream << "entity rv32_microcode is" << std::endl << "port(" << std::endl;
    if (hasForwarding_) {
        stream << "  clk            : in std_logic;" << std::endl
               << "  rstx           : in std_logic;" << std::endl
               << "  glock_in       : in std_logic;" << std::endl
               << "  data_hazard_in : in std_logic;" << std::endl
               << "  rs1_hazard_in  : in std_logic;" << std::endl
               << "  rs2_hazard_in  : in std_logic;" << std::endl
               << "  halt           : in std_logic;" << std::endl;
    }
    stream << "  fu_opcode_in : in  std_logic_vector(16 downto 0);"
           << std::endl
           << "  moves_out    : out std_logic_vector(INSTRUCTIONWIDTH-1 "
              "downto 0));"
           << std::endl
           << std::endl
           << "end rv32_microcode;" << std::endl
           << std::endl
           << "architecture rtl of rv32_microcode is" << std::endl
           << "  signal fu_opcode : std_logic_vector(16 downto 0);"
           << std::endl
           << "  signal moves     : std_logic_vector(INSTRUCTIONWIDTH-1 "
              "downto 0);"
           << std::endl
           << "  constant rs1_start_c : integer := " << rs1BusStart_ << ";"
           << std::endl
           << "  constant rs2_start_c : integer := " << rs2BusStart_ << ";"
           << std::endl
           << "  constant rs1_width_c : integer := " << rs1BusWidth_ << ";"
           << std::endl
           << "  constant rs2_width_c : integer := " << rs2BusWidth_ << ";"
           << std::endl;
    if (hasForwarding_) {
        int len = std::ceil(std::log2(sourceOperationMap_.size()));
        stream << "  signal target_fu : unsigned(" << len << "-1 downto 0);"
               << std::endl;
        stream << "  signal target_fu_r : unsigned (" << len
               << "-1 downto 0);" << std::endl
               << "  signal data_hazard : std_logic;\n"
               << "  signal rs1_hazard : std_logic;\n"
               << "  signal rs2_hazard : std_logic;\n";
    }

    stream << std::endl
           << "  begin" << std::endl
           << std::endl
           << "  fu_opcode  <= fu_opcode_in;" << std::endl
           << "  moves_out  <= moves;" << std::endl
           << std::endl;
    if (hasForwarding_) {
        stream << "  data_hazard <= data_hazard_in;" << std::endl
               << "  rs1_hazard  <= rs1_hazard_in;" << std::endl
               << "  rs2_hazard  <= rs2_hazard_in;" << std::endl;
        stream << std::endl;
        generateFUTargetProcess(stream);
    }
    stream << "  process(fu_opcode";
    if (hasForwarding_) {
        stream << ", data_hazard, rs1_hazard, rs2_hazard, target_fu_r";
    }
    stream << ")" << std::endl;
    stream << "  begin" << std::endl;

    std::unordered_map<std::string, InstructionBitVector*> instructions =
        constructRInstructions(rs1RFPort_, rs2RFPort_);
    bool firstCond = true;
    for (const auto& op : instructions) {
        if (firstCond) {
            stream << "    if(fu_opcode = \"" << rOperations_.at(op.first)
                   << "\")  then" << std::endl
                   << "      moves <= \"" << op.second->toString() << "\";"
                   << std::endl;
            delete op.second;
            firstCond = false;
            continue;
        }
        stream << "    elsif(fu_opcode(" << rOperations_.at(op.first).size()
               << " - 1 downto 0) = \"" << rOperations_.at(op.first) << "\""
               << ") then" << std::endl
               << "      moves <= \"" << op.second->toString() << "\";"
               << std::endl;
        delete op.second;
    }

    instructions = constructIInstructions(rs1RFPort_, rs1RFPort_);
    addBitsToMap(instructions, iOperations_, stream);

    instructions = constructSInstructions(rs1RFPort_, rs2RFPort_);
    addBitsToMap(instructions, sOperations_, stream);

    instructions = constructBInstructions(rs1RFPort_, rs2RFPort_);
    addBitsToMap(instructions, bOperations_, stream);

    instructions = constructUJInstructions();
    addBitsToMap(instructions, ujOperations_, stream);

    stream << "    else" << std::endl;
    stream << "      moves <= \"" + NOP_ + "\";" << std::endl;

    stream << "    end if;" << std::endl;

    if (hasForwarding_) {
        stream << "    if(data_hazard = '1') then\n"
               << "      if(rs1_hazard = '1') then\n";
        addRs1ForwardingConditions(
            rOperations_,
            &ProGe::RV32MicroCodeGenerator::constructRInstructions, stream);
        addRs1ForwardingConditions(
            bOperations_,
            &ProGe::RV32MicroCodeGenerator::constructBInstructions, stream);
        addRs1ForwardingConditions(
            sOperations_,
            &ProGe::RV32MicroCodeGenerator::constructSInstructions, stream);
        addRs1ForwardingConditions(
            iOperations_,
            &ProGe::RV32MicroCodeGenerator::constructIInstructions, stream);
        stream << "      end if;\n"
               << "    if(rs2_hazard = '1') then\n";
        addRs2ForwardingConditions(
            rOperations_,
            &ProGe::RV32MicroCodeGenerator::constructRInstructions, stream);
        addRs2ForwardingConditions(
            bOperations_,
            &ProGe::RV32MicroCodeGenerator::constructBInstructions, stream);
        addRs2ForwardingConditions(
            sOperations_,
            &ProGe::RV32MicroCodeGenerator::constructSInstructions, stream);
        stream << "      end if;\n"
               << "    end if;\n";
    }

    stream << "  end process;" << std::endl;

    stream << "end architecture rtl;" << std::endl;

    stream.close();
}

std::string
RV32MicroCodeGenerator::generateOperationLatencyLogic(
    HDLTemplateInstantiator& instantiator) {
    std::map<std::string, std::string> operations;
    operations.insert(rOperations_.begin(), rOperations_.end());
    int maxVal = 1;
    for (const auto& op : iOperations_) {
        if (!rOperations_.count(op.first)) {
            operations.insert(op);
        }
    }
    std::map<std::string, int> opLatency;
    for (const auto& op : operations) {
        FunctionUnit* fu = mapFunctionUnit(op.first);
        HWOperation* operation = fu->operation(op.first);
        if (operation->latency() > 1) {
            opLatency.insert({op.first, operation->latency() - 1});
            if (operation->latency() > maxVal) {
                maxVal = operation->latency();
            }
        }
    }
    int len = std::ceil(std::log2((maxVal)) + 1);
    instantiator.replacePlaceholder("op-lat-width", std::to_string(len));
    if (opLatency.size() == 0) {
        return "op_latency <= to_unsigned(0,op_lat_width_c);";
    }
    variableLengthOpLatency_ = true;
    std::string logic =
        "process(fu_opcode)\n"
        "begin\n";
    bool firstCond = true;
    for (const auto& op : opLatency) {
        std::string cond = "  elsif ";
        if (firstCond) {
            cond = "  if ";
            firstCond = false;
        }
        if (rOperations_.count(op.first) && iOperations_.count(op.first)) {
            cond += "fu_opcode = \"" + rOperations_.at(op.first) + "\" or " +
                    "fu_opcode(" +
                    std::to_string(iOperations_.at(op.first).size()) +
                    "-1 downto 0) = \"" + iOperations_.at(op.first) +
                    "\" then\n";
        } else {
            cond += "fu_opcode(" +
                    std::to_string(operations.at(op.first).size()) +
                    "-1 downto 0) =  \"" + operations.at(op.first) +
                    "\" then\n";
        }
        logic += cond + "     op_latency <= to_unsigned(" +
                 std::to_string(op.second) + ",op_lat_width_c);\n";
    }
    logic +=
        "  else\n"
        "    op_latency <= to_unsigned(0,op_lat_width_c);\n"
        "  end if;\n"
        "end process;\n";
    return logic;
}

void
RV32MicroCodeGenerator::generateWrapper(
    HDLTemplateInstantiator& instantiator, const std::string& fileDst) {
    instantiator.replacePlaceholder(
        "rs1-bus-width", std::to_string(rs1BusWidth_));
    instantiator.replacePlaceholder(
        "rs2-bus-width", std::to_string(rs2BusWidth_));
    instantiator.replacePlaceholder(
        "rd-bus-width", std::to_string(rdBusWidth_));
    instantiator.replacePlaceholder(
        "simm-bus-width", std::to_string(simmBusWidth_));

    instantiator.replacePlaceholder(
        "rs1-bus-start", std::to_string(rs1BusStart_));
    instantiator.replacePlaceholder(
        "rs2-bus-start", std::to_string(rs2BusStart_));
    instantiator.replacePlaceholder(
        "rd-bus-start", std::to_string(rdBusStart_));
    instantiator.replacePlaceholder(
        "simm-bus-start", std::to_string(simmBusStart_));

    instantiator.replacePlaceholder(
        "rs1-rf-start", std::to_string(rs1RFStart_));
    instantiator.replacePlaceholder(
        "rs2-rf-start", std::to_string(rs2RFStart_));
    instantiator.replacePlaceholder(
        "rd-rf-start", std::to_string(rdRFStart_));
    instantiator.replacePlaceholder(
        "simm-rf-start", std::to_string(simmRFStart_));

    if (eVariant_) {
        instantiator.replacePlaceholder("rf-width", std::to_string(4));
    } else {
        instantiator.replacePlaceholder("rf-width", std::to_string(5));
    }

    std::string nop = NOP_;
    reverse(nop.begin(), nop.end());
    nop = nop.substr(rdBusStart_, rdBusWidth_);
    reverse(nop.begin(), nop.end());
    const std::string rdNOP = nop;

    instantiator.replacePlaceholder("rd-nop", rdNOP);
    instantiator.replacePlaceholder("nop-instruction", NOP_);
    instantiator.replacePlaceholder(
        "rv32-microcode-simm-assign", "simm_out <= simm_r;");

    const std::string DS = FileSystem::DIRECTORY_SEPARATOR;
    const std::string templateDir = Environment::dataDirPath("ProGe");

    instantiator.replacePlaceholder(
        "rv32-microcode-instruction-assign",
        "instruction <= instruction_in;");

    if (hasForwarding_) {
        std::string forwardingPorts =
            "  clk            : in std_logic;\n"
            "  rstx           : in std_logic;\n"
            "  glock_in       : in std_logic;\n"
            "  data_hazard_in : in std_logic;\n"
            "  rs1_hazard_in  : in std_logic;\n"
            "  rs2_hazard_in  : in std_logic;\n"
            "  halt           : in std_logic;\n";

        std::string forwardingPortMapping =
            "clk              => clk,\n"
            "rstx             => rstx,\n"
            "glock_in         => glock_in,\n"
            "data_hazard_in   => data_hazard,\n"
            "rs1_hazard_in    => rs1_hazard,\n"
            "rs2_hazard_in    => rs2_hazard,\n"
            "halt             => filling_instruction_pipeline,";

        instantiator.replacePlaceholder("forwarding-ports", forwardingPorts);
        instantiator.replacePlaceholder(
            "forwarding-port-mapping", forwardingPortMapping);
    } else {
        instantiator.replacePlaceholder(
            "data-hazard-stall", "and data_hazard = '0'");
        instantiator.replacePlaceholder(
            "data-hazard-assign-conds",
            "elsif(data_hazard_r = '1') then\n"
            "  data_hazard <= '0';");
        instantiator.replacePlaceholder(
            "data-hazard-detection-sensitivity-list-signals",
            ", data_hazard_r");
    }
    instantiator.replacePlaceholder(
        "rv32-microcode-op-latency-process",
        generateOperationLatencyLogic(instantiator));
    std::string otherStates;

    if (variableLengthOpLatency_) {
        otherStates += ",HANDLE_OP_LATENCY";
    }
    if (!bypassInstructionRegister_) {
        otherStates += ",FILL_INSTRUCTION_PIPELINE_2";
    }
    instantiator.replacePlaceholder(
        "rv32-microcode-other-states", otherStates);
    std::string executeLogic;
    std::string fsm_sensitivity_list_signals;
    executeLogic =
        "  if(glock_in = '1') then\n"
        "    bubble <= '1';\n"
        "    stall_ifetch <= '0';\n"
        "    NS <= EXECUTE;\n"
        "  elsif (rv_jump_wire = '1' or rv_auipc_wire = '1') then\n"
        "     rd_bus_move <= rd_move;\n"
        "     stall_ifetch <= '0';\n"
        "     bubble <= '1';\n"
        "     if rv_auipc_wire = '0' then\n"
        "       NS <= FILL_INSTRUCTION_PIPELINE;\n"
        "     end if;\n";
    if (!hasForwarding_) {
        fsm_sensitivity_list_signals = ", data_hazard";
        if (variableLengthOpLatency_) {
            executeLogic +=
                "  elsif(op_latency_stall = '1' and data_hazard = '0') then\n"
                "    bubble <= '0';\n"
                "    NS <= HANDLE_OP_LATENCY;\n"
                "    stall_ifetch <= '1';\n"
                "    rd_bus_move <= rd_nop_c;\n";
        }
        executeLogic +=
            "  elsif(data_hazard = '1') then\n"
            "    bubble <= '1';\n"
            "    rd_bus_move <= rd_nop_c;\n"
            "    stall_ifetch <= '1';\n"
            "    NS <= EXECUTE;\n"
            "  elsif (is_control_flow_op = '1') then\n"
            "    bubble <= '0';\n"
            "    stall_ifetch <= '1';\n"
            "    NS <= HANDLE_CONTROL_FLOW_OP;\n"
            "    handle_control_flow_ns <= '1';\n"
            "  else\n"
            "    bubble <= '0';\n"
            "    stall_ifetch <= '0';\n"
            "    NS <= EXECUTE;\n"
            "  end if;\n";
    } else {
        if (variableLengthOpLatency_) {
            executeLogic +=
                "  elsif(op_latency_stall = '1') then\n"
                "    bubble <= '0';\n"
                "    NS <= HANDLE_OP_LATENCY;\n"
                "    stall_ifetch <= '1';\n"
                "    rd_bus_move <= rd_nop_c;\n";
        }
        executeLogic +=
            "  elsif (is_control_flow_op = '1') then\n"
            "    bubble <= '0';\n"
            "    stall_ifetch <= '1';\n"
            "    NS <= HANDLE_CONTROL_FLOW_OP;\n"
            "    handle_control_flow_ns <= '1';\n"
            "  else\n"
            "    bubble <= '0';\n"
            "    stall_ifetch <= '0';\n"
            "    NS <= EXECUTE;\n"
            "  end if;\n";
    }
    if (variableLengthOpLatency_) {
        fsm_sensitivity_list_signals += ",  op_latency_stall";
        executeLogic +=
            "\n"
            "when HANDLE_OP_LATENCY =>\n"
            "  bubble <= '1';\n"
            "  stall_ifetch <= '1';\n"
            "  rd_bus_move <= rd_nop_c;\n"
            "  NS <= HANDLE_OP_LATENCY;\n"
            "  if(op_latency_stall = '0') then\n"
            "    NS <= EXECUTE;\n"
            "    stall_ifetch <= '0';\n"
            "    rd_bus_move <= rd_move;\n"
            "  end if;";
    }
    std::string instructionPipelineStates;
    if (bypassInstructionRegister_) {
        instructionPipelineStates =
            "when FILL_INSTRUCTION_PIPELINE =>\n"
            "  filling_instruction_pipeline <= '1';\n"
            "  bubble <= '1';\n"
            "  rd_bus_move <= rd_nop_c;\n"
            "  stall_ifetch <= '0';\n"
            "  NS <= EXECUTE;\n";
    } else {
        instructionPipelineStates =
            "when FILL_INSTRUCTION_PIPELINE =>\n"
            "  filling_instruction_pipeline <= '1';\n"
            "  bubble <= '1';\n"
            "  rd_bus_move <= rd_nop_c;\n"
            "  stall_ifetch <= '0';\n"
            "  NS <= FILL_INSTRUCTION_PIPELINE_2;\n"
            "\n"
            "\n"
            "when FILL_INSTRUCTION_PIPELINE_2 =>\n"
            "  filling_instruction_pipeline <= '1';\n"
            "  bubble <= '1';\n"
            "  rd_bus_move <= rd_nop_c;\n"
            "  stall_ifetch <= '0';\n"
            "  NS <= EXECUTE;\n"
            "\n";
    }
    instantiator.replacePlaceholder(
        "rv32-microcode-instruction-pipeline-logic",
        instructionPipelineStates);

    instantiator.replacePlaceholder(
        "rv32-microcode-fsm-sensitivity-list-signals",
        fsm_sensitivity_list_signals);
    instantiator.replacePlaceholder(
        "rv32-microcode-execute-logic", executeLogic);
    instantiator.instantiateTemplateFile(
        templateDir + DS + "rv32_microcode_wrapper.vhdl.tmpl",
        fileDst + DS + "rv32_microcode_wrapper.vhdl");
}

void
RV32MicroCodeGenerator::generateRTL(
    HDLTemplateInstantiator& instantiator, const std::string& fileDst) {
    generateMap(fileDst);
    generateWrapper(instantiator, fileDst);
}

void
RV32MicroCodeGenerator::setBypassInstructionRegister(const bool& value) {
    bypassInstructionRegister_ = value;
}

}  // namespace ProGe
