#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (c) 2002-2011 Tampere University.
#
# This file is part of TTA-Based Codesign Environment (TCE).
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
# Script that runs test cases primaly generated by test generator in rtlsim.
#
# Reads test case files from INPUT directory, runs them and outputs results
# under OUTPUT directory.
#
# INPUT is by default: "PROGEOUTPUT/tests". The variable is overriden by option
# -i, --input
# OUTPUT is by default: "PROGEOUTPUT/test-results". The variable is overriden
# by option -o, --output
# PROGEOUTPUT is by default: ".". The variable is overriden by option
# -x, --hdl-dir
#
# A single test case consists of files:
#  - a bustrace:         <test-case-name>.bustrace
#  - a instruction image <test-case-name>.img
#  - data images         <test-case-name>_<address_space>.img
# These files must be present for each <test-case-name> to be accepted.
# The bustrace is used to determine run time of the program and in
# verification.
#
# Automatically recognizes available RTL-simulator if they are in PATH. The
# simulators to search are GHDL and ModelSim.
#

import os, sys, optparse, collections, re, glob, subprocess, shutil, difflib
from os import path
from os import listdir
from optparse import OptionParser
from collections import OrderedDict
from subprocess import Popen

#TODO? should not actually delete old test results? May be only delete
#      results of test cases to be run.
#TODO? Recognize hdl_sim_stdout.txt and use it to determine success of
#      test case.

# Named tuple type of a single test case
Testcase = collections.namedtuple('Testcase',
                                  [ 'testname',
                                    'bustracefile',
                                    'runtime',
                                    'instr_image_file',
                                    'data_image_files' ]);

class InitError(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)

def setupOptionParser():
    """Initializes option parser."""

    usage = "usage: %prog [options]."
    optParser = optparse.OptionParser(usage)
    optParser.add_option('-i', '--input',
                         action="store", metavar="DIR",
                         dest="input_dir", default="./tests",
                         help="Path to directory containing test cases to"\
                         " be run. [default: %default]")
    optParser.add_option('-o', '--output',
                         action="store", metavar="DIR",
                         dest="output_dir", default="./test-results",
                         help="Path to put results of run test cases. "\
                         "The contents of the directory will be erased. "\
                         "[default: %default]")
    optParser.add_option('-x', '--hdl-dir',
                         action="store", metavar="DIR",
                         dest="proge_dir", default=".",
                         help="Path to directory where ProGe created HDL "\
                         "files. [default: %default]")
    optParser.add_option('-t', '--testcase',
                         action="append", metavar="TESTCASE",
                         dest="selected_testcases", default=None,
                         help="Runs only the specified test case by name. ")
    sim_choices = ['auto', 'modelsim', 'ghdl']
    optParser.add_option('-s', '--simulator',
                         action="store", dest="simulator", 
                         choices=sim_choices,
                         default='auto',
                         help="The simulator to be used in test runs. " +
                             "The choices are " + str(sim_choices) + ". " +
                             "[default: %default] ")
    #TODO add simulator select (ghdl, modelsim, [auto])
    #TODO add verbosity option to tell phases the script
    return optParser


def valid_options(options, args):
    """Checks the given or default option values are valid."""
    if not path.isdir(options.input_dir):
        print("Error: no such input directory: %s" % options.input_dir)
        return False
    if not path.isdir(options.proge_dir):
        print("Error: no such hdl directory: %s" % options.proge_dir)
        return False
    return True


def mkdirp(dir):
    """
    Emulates mkdir -p: creates directory including intermediate ones if
    not already existing.
    """
    if not path.exists(dir):
        # Use absolute path since makedirs may become confused of '..'es
        os.makedirs(path.abspath(dir))


def number_of_lines(filepath):
    return sum(1 for l in open(filepath))


def get_rtl_bustrace(progeoutdir):
    """
    Returns bustrace file name produced by RTL simulation. Returns
    None if the file is not found.
    """
    bustraces = glob.glob(path.join(progeoutdir, 'core0_execbus.dump'))
    if len(bustraces) > 0:
        return bustraces[0]
    bustraces = glob.glob(path.join(progeoutdir, 'execbus.dump'))
    if len(bustraces) > 0:
        return bustraces[0]
    return None


def diff_bustrace(ref_bustrace, new_bustrace):
    """
    Return True if the given bustraces differs.
    ref_bustrace is treated as reference file.
    """
    diff_content = None
    diff_status = False
    try:
        ref_file = open(ref_bustrace, 'r')
        ref_str = ref_file.readlines()
        new_file = open(new_bustrace, 'r')
        num_of_lines = len(ref_str)
        new_str = new_file.readlines()[:num_of_lines]
        diff_content = [ line for line in difflib.unified_diff(ref_str,
                                                               new_str,
                                                               ref_bustrace,
                                                               new_bustrace) ]
        diff_status = len(diff_content) != 0;
    except Exception as e:
#        print("Exception in diff_bustrace():", e #debug)
        return (True, None)

    return (diff_status, diff_content)


def get_testcases(options):
    """
    Collects valid testcases from input directory
    Returns list of named tuple Testcase.
    """
    inputdir = options.input_dir
    files = [ f for f in listdir(inputdir)
              if path.isfile(path.join(inputdir, f)) ]
    re_bustrace = re.compile(r'[\w-]+\.bustrace', re.IGNORECASE)
    cases = [ f for f in files[:] if re_bustrace.match(f) ]
    cases = [ f.replace('.bustrace', '') for f in cases[:] ]
    test_case_list = []
    for case in cases[:]:
        bustrace = path.join(inputdir, case + '.bustrace')
        instr_img = path.join(inputdir, case + '.img')
        if not path.isfile(instr_img) or not os.access(instr_img, os.R_OK):
            continue
        if not path.isfile(bustrace) or not os.access(bustrace, os.R_OK):
            continue
        data_imgs = [ path.join(inputdir, f) for f in listdir(inputdir)
                      if re.match(case + r'_\w*\.img', f)
                      and path.isfile(path.join(inputdir, f))
                      and os.access(path.join(inputdir, f), os.R_OK)]

        test_case_list.append(Testcase(testname=case,
                                       bustracefile=bustrace,
                                       runtime=number_of_lines(bustrace),
                                       instr_image_file=instr_img,
                                       data_image_files=data_imgs))

    # Sort by test name deterministic test run.
    test_case_list.sort(key=lambda tc: tc[0])
    if options.selected_testcases != None:
        return [ tc for tc in test_case_list[:]
                 if tc.testname in options.selected_testcases ]
    else:
        return test_case_list


def command_exists(cmd_name):
    """
    Returns true if the given command name can be invoked. Otherwise, returns
    false.
    """
    path_locations = os.environ.get("PATH").split(os.pathsep)
    for location in path_locations:
        if path.isfile(path.join(location, cmd_name)):
            return True
    return False;


def select_rtl_simulator(choice):
    """
    Returns runnable RTL simulator or None if the choice not available.
    The choices are auto, modelsim and ghdl. The choice auto select one of the
    latter.
    """
    # Ordered list of cadidates. 'simulator name': 'executable'
    rtlsim_choices = OrderedDict([('modelsim', 'vsim'),
                                  ('ghdl', 'ghdl') ])
    if choice == "auto":
        for rtl_simulator in rtlsim_choices:
            if command_exists(rtlsim_choices[rtl_simulator]):
                return rtl_simulator
    elif choice in rtlsim_choices:
        if command_exists(rtlsim_choices[choice]):
            return choice
    return None


def run_command(cmdString):
    """
    Runs a shell command silently and without providing any input.
    Returns exit code of the shell command.
    """
    devNull = open(os.devnull, 'w')
#    print("Running shell cmd: " + cmdString #debug)
    process = Popen(cmdString, shell=True, stdout=devNull, stderr=devNull,
                    close_fds=False)
    if process == None:
        print("Error: Could not create shell process.")
        sys.exit(2)
    process.communicate()
    return process.returncode


def rtl_compile_script(rtl_simulator):
    """
    Returns the name of the compilation script for given rtl simulator
    """
    if rtl_simulator == "modelsim":
        return "modsim_compile.sh"
    elif rtl_simulator == "ghdl":
        return "ghdl_compile.sh"
    else:
        raise LookUpError("Unknown RTL simulator Type.")


def rtl_simulate_script(rtl_simulator):
    """
    Returns the name of the compilation script for given rtl simulator
    """
    if rtl_simulator == "modelsim":
        return "modsim_simulate.sh"
    elif rtl_simulator == "ghdl":
        return "ghdl_simulate.sh"
    else:
        raise LookUpError("Unknown RTL simulator Type.")


def prepare_testbench(progeoutdir, rtl_simulator):
    """
    Initialized HDL test bench for running test cases.
    """
    simCommand = "cd %s; " % progeoutdir
    simCommand += "./" + rtl_compile_script(rtl_simulator)
    if rtl_simulator == "modelsim":
        simCommand += " -c; "
    return run_command(simCommand)


def get_data_address_space_name(testcase, data_image_file):
    """
    Extracts data address space name from data image file path.
    """
    result = path.basename(data_image_file)
    result = result.replace(testcase.testname + '_', '');
    result = result.replace('.img', '');
    return result

def load_images(progeoutdir, testcase):
    """
    Load instruction and data images for RTL simulation.
    """
    try:
        shutil.copyfile(testcase.instr_image_file,
                        path.join(progeoutdir, 'tb/imem_init.img'))
    except IOError as e:
        raise IOError("Error: Could not load instruction image: " + e)
    if len(testcase.data_image_files) > 0:
        # Note: test bench does not support 1+ data memories yet
        try:
            for data_image_file in testcase.data_image_files:
                addr_space_name = get_data_address_space_name(testcase,
                                                              data_image_file)
                shutil.copyfile(data_image_file,
                                path.join(progeoutdir, 
                                          'tb/dmem_' 
                                          + addr_space_name 
                                          + '_init.img'))
        except IOError as e:
            raise IOError("Error: Could not load data image: " + e)
    else:
        # create dummy data image since test bench does not expect non-existent
        # file.
        try:
            open(path.join(progeoutdir, 'tb/dmem_init.img'), 'w').close()
        except IOError as e:
            raise IOError("Error: Could not load data image: " + e)

def run_simulation(progeoutdir, rtl_simulator,
                   num_of_instructions, timeout=1000000000):
    """
    Runs simulation by given number of instructions timeouted by timeout in
    nanoseconds.
    """
    simCommand = "cd %s; " % progeoutdir
    simCommand += "./" + rtl_simulate_script(rtl_simulator) + " "
    if rtl_simulator == "modelsim":
        simCommand += "-c "
    simCommand += "-i %d -r %d; " % (num_of_instructions, timeout);
    return run_command(simCommand) == 0


def run_testcase(testcase, rtl_simulator, progeoutdir, outputdir):
    """
    Runs the given test case in RTL-simulator.
    Assumes that test bench is prepared before calling this.
    Returns tuple of (success status, reason)
    """
    #TODO do cleanup

    load_images(progeoutdir, testcase)

    # Directory where test case specific results are placed
    tc_result_dir = path.join(outputdir, testcase.testname)

    reason = None
    success = run_simulation(progeoutdir, rtl_simulator, testcase.runtime)
    if not success:
        reason = "Simulation error"

    if success:
        ref_file = testcase.bustracefile
        assert path.isfile(ref_file)
        new_file = get_rtl_bustrace(progeoutdir)
        if new_file == None:
            success = False
            reason = "No bustrace"
        else:
            differs, diff = diff_bustrace(ref_file, new_file)
            if differs:
                success = False
                reason = "Bustrace mismatch"
                mkdirp(tc_result_dir)
                diff_file = open(path.join(tc_result_dir, "bustrace.diff"),
                                 'w')
                diff_file.writelines(diff)
                diff_file.close()

    # Save dump files if the test case fails for further inspection
    if not success:
        mkdirp(tc_result_dir)
        for dumpfile in glob.glob(path.join(progeoutdir, "*.dump")):
            try:
                shutil.copy(dumpfile, tc_result_dir)
            except:
                pass

    #TODO return status (OK, FAIL, TIMEOUT, ERROR)
    return (success, reason)


def clear_simulation_files(progeoutdir):
    """
    Clears simulation related files.
    """
    dumpfiles = [ path.join(progeoutdir, f) for f in listdir(progeoutdir)
                  if path.isfile(path.join(progeoutdir, f)) and
                  re.match(r'.*\.dump', f, re.IGNORECASE) ]
    for dumpfile in dumpfiles[:]:
        os.remove(dumpfile);

def test_result_format(testname, success, reason):
    """
    Makes pretty test result string.
    """
    status_str = ""
    reason_str = ""
    if success:
        status_str = "OK"
    else:
        status_str = "FAIL"
        reason_str = "(%s)" % reason
    return "{0:>6} {1} {2}".format(status_str, testname, reason_str)


def run_testcases(progeoutdir, outputdir, list_of_testcases, rtl_simulator):
    """
    Accepts list of named tuple Testcase. Runs each test case in
    RTL-simulator and collects data from it.
    """
    if prepare_testbench(progeoutdir, rtl_simulator) != 0:
        print("Test bench compilation failed.")
        return False

    num_failing = 0
    summary_file = open(path.join(outputdir, "summary.log"), 'a')
    for testcase in list_of_testcases[:]:
        try:
            clear_simulation_files(progeoutdir)
            success, reason = run_testcase(testcase, rtl_simulator,
                                           progeoutdir, outputdir)
            if not success:
                num_failing += 1
            print(test_result_format(testcase.testname, success, reason))
            summary_file.write(test_result_format(
                    testcase.testname, success, reason) + '\n')

        except Exception as e:
            print("caught exception:", e)

    #TODO compile coverage report
    summary_file.close()
    return num_failing



def prepare_testrun_env(options):
    """
    Makes checks and clean ups before running the test cases.
    """
    def expect_proge_file(filepath):
        if (not path.exists(path.join(options.proge_dir, filepath)) or
            not path.isfile(path.join(options.proge_dir, filepath))):
            raise InitError("Could not locate " + filepath + " in " +
                            options.proge_dir + " (hdl-dir)")

    expect_proge_file(rtl_compile_script(
            select_rtl_simulator(options.simulator)))
    expect_proge_file(rtl_simulate_script(
            select_rtl_simulator(options.simulator)))

    mkdirp(options.output_dir)
    clear_simulation_files(options.output_dir)

    # If the dir already existed and is non-empty, delete old test results.
    assert path.isdir(options.output_dir)
    for file_or_dir in listdir(options.output_dir):
        file_or_dir = path.join(options.output_dir, file_or_dir)
        if path.isfile(file_or_dir):
            os.remove(file_or_dir)
        elif path.isdir(file_or_dir):
            shutil.rmtree(file_or_dir)


def main():
    """The main function."""
    optParser = setupOptionParser()
    (options, args) = optParser.parse_args()
    if not valid_options(options, args):
        return 1
    testcases = get_testcases(options)
    simulator = select_rtl_simulator(options.simulator)
    if simulator == None:
        print("No RTL simulator available.")
        return 1
#    print("Using RTL-simulator: " + simulator)
    try:
        prepare_testrun_env(options)
    except InitError as e:
        print(e)
        return 1
    num_failing = run_testcases(options.proge_dir, options.output_dir, \
                                testcases, simulator)
    # If num_failing == 0, evaluates to True
    return num_failing

if __name__ == '__main__':
    sys.exit(main())
