/*
 * Copyright (C) 2025 Tampere University.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
 */
 
module FUNAME_coprocessor
  import cvxif_sup_pkg::*;
#(
    // CVXIF Types According to the CVA6
    parameter  int unsigned NrRgprPorts         = 3,
    parameter  type         readregflags_t      = logic,
    parameter  type         writeregflags_t     = logic,
    parameter  type         id_t                = logic,
    parameter  type         hartid_t            = logic,
    parameter  type         x_compressed_req_t  = logic,
    parameter  type         x_compressed_resp_t = logic,
    parameter  type         x_issue_req_t       = logic,
    parameter  type         x_issue_resp_t      = logic,
    parameter  type         x_register_t        = logic,
    parameter  type         x_commit_t          = logic,
    parameter  type         x_result_t          = logic,
    parameter  type         cvxif_req_t         = logic,
    parameter  type         cvxif_resp_t        = logic,
    localparam type         registers_t         = logic [NrRgprPorts-1:0][31:0]
) (
    input  logic        clk_i,        // Clock
    input  logic        rst_ni,       // Asynchronous reset active low
    input  cvxif_req_t  cvxif_req_i,
    output cvxif_resp_t cvxif_resp_o
); 

  //Compressed interface
  logic               x_compressed_valid_i;
  logic               x_compressed_ready_o;
  x_compressed_req_t  x_compressed_req_i;
  x_compressed_resp_t x_compressed_resp_o;
  //Issue interface
  logic               x_issue_valid_i;
  logic               x_issue_ready_o;
  x_issue_req_t       x_issue_req_i;
  x_issue_resp_t      x_issue_resp_o;
  //Commit interface
  logic               x_commit_valid_i;
  x_commit_t          x_commit_i;
  // Register interface signals
  x_register_t        register;
  logic               register_valid;
  //Result interface
  logic               x_result_valid_o;
  logic               x_result_ready_i;
  x_result_t          x_result_o;

  assign x_compressed_valid_i            = cvxif_req_i.compressed_valid;
  assign x_compressed_req_i              = cvxif_req_i.compressed_req;
  assign x_issue_valid_i                 = cvxif_req_i.issue_valid;
  assign x_issue_req_i                   = cvxif_req_i.issue_req;
  assign x_commit_valid_i                = cvxif_req_i.commit_valid;
  assign x_commit_i                      = cvxif_req_i.commit;
  assign x_result_ready_i                = cvxif_req_i.result_ready;
  assign register                        = cvxif_req_i.register;
  assign register_valid                  = cvxif_req_i.register_valid;

  assign cvxif_resp_o.compressed_ready = x_compressed_ready_o;
  assign cvxif_resp_o.compressed_resp  = x_compressed_resp_o;
  assign cvxif_resp_o.issue_ready      = x_issue_ready_o;
  assign cvxif_resp_o.issue_resp       = x_issue_resp_o;
  assign cvxif_resp_o.result_valid     = x_result_valid_o;
  assign cvxif_resp_o.result           = x_result_o;
  assign cvxif_resp_o.register_ready   = x_issue_ready_o;

  //Compressed interface handler/decoder
  cvxifcompressed_decoder #(
    .x_compressed_req_t (x_compressed_req_t),
    .x_compressed_resp_t(x_compressed_resp_t)
  ) compressed_decoder_i (
    .clk_i              (clk_i), //No current use
    .compressed_valid   (x_compressed_valid_i),
    .x_compressed_req   (x_compressed_req_i),
    .x_compressed_resp  (x_compressed_resp_o),
    .compressed_ready   (x_compressed_ready_o)
  );

  logic[cvxif_sup_pkg::NConfigbits_C-1 : 0]       configbits_in_i;  // For input config bits
  logic               				    	              x_result_valid_i; // For intermediate result valid			
  logic[cvxif_sup_pkg::NConfigbits_C-1 : 0]       configbits_o;     // For config bits out the FU
  logic[cvxif_sup_pkg::X_RFW_WIDTH-1 : 0]         result_data_out;  // For data out from the function unit
  logic instr_accept, instr_ready;
  logic[31:0] instruction_in;
  CONFIG_DEFINE
  assign x_issue_ready_o       = instr_ready && register.rs_valid[0] && register.rs_valid[1] && (NrRgprPorts == 3 ? register.rs_valid[2] : 1'b1);
  assign x_issue_resp_o.accept = instr_accept;
  assign instruction_in        = cvxif_sup_pkg::OpcodeMask & x_issue_req_i.instr;
  assign x_result_valid_i      = x_issue_valid_i & x_issue_ready_o & instr_accept;
  assign configbits_in_i       = {x_result_valid_i, x_issue_req_i.instr[11:7], x_issue_resp_o.writeback, x_issue_req_i.hartid, x_issue_req_i.id};

  fu_FUNAME function_unit_i (
      .clk(clk_i),
      .rstx(rst_ni),
      .operation_enable_in(x_issue_valid_i),
      .result_ready_in(x_result_ready_i),
      .configbits_in(configbits_in_i),
      .operation_in(instruction_in), 
      CONFIG_ENINPUT1.data_OUTPUTF_out(result_data_out),
      CONFIG_BITS.configbits_out(configbits_o),
      .accept_o(instr_accept),
      .ready_o(instr_ready)
  );

  always_comb begin
    x_issue_resp_o.writeback = 1'b0;
    if (instr_accept) begin
        x_issue_resp_o.writeback = 1'b1;
    end
  end

  instr_tracker_FUNAME #(
    .IdWidth(cvxif_sup_pkg::X_ID_WIDTH),
    .HWidth(cvxif_sup_pkg::X_HARTID_WIDTH),
    .IdBits(cvxif_sup_pkg::IdBits)
  ) instruction_tracker_i (
    .clk(clk_i),
    .rstx(rst_ni),
    .commit_hartid_i(x_commit_i.hartid),      
    .commit_id_i(x_commit_i.id),
    .commit_kill_i(x_commit_i.commit_kill),
    .commit_valid_i(x_commit_valid_i),
    .issue_hartid_i(x_issue_req_i.hartid),
    .issue_id_i(x_issue_req_i.id),
    .issue_valid_i(x_issue_resp_o.accept),
    SEARCH_CONFIGOUT_COMMIT_TRACKER.output_hartid_i(configbits_o[cvxif_sup_pkg::X_ID_WIDTH + cvxif_sup_pkg::X_HARTID_WIDTH - 1 : cvxif_sup_pkg::X_ID_WIDTH]),
    .output_id_i(configbits_o[cvxif_sup_pkg::X_ID_WIDTH - 1 : 0]),
    .output_valid_i(configbits_o[cvxif_sup_pkg::NConfigbits_C-1])
  );

  always_comb begin
    x_result_valid_o   = configbits_o[cvxif_sup_pkg::NConfigbits_C-1];  
    x_result_o.id      = configbits_o[cvxif_sup_pkg::X_ID_WIDTH - 1 : 0]; 
    x_result_o.rd      = configbits_o[cvxif_sup_pkg::NConfigbits_C-2 : cvxif_sup_pkg::NConfigbits_C - 1 - 5];                             
    x_result_o.we      = configbits_o[cvxif_sup_pkg::X_ID_WIDTH + cvxif_sup_pkg::X_HARTID_WIDTH + cvxif_sup_pkg::X_DUALWRITE : cvxif_sup_pkg::X_ID_WIDTH + cvxif_sup_pkg::X_HARTID_WIDTH] & x_result_valid_o;              
    x_result_o.hartid  = configbits_o[cvxif_sup_pkg::X_ID_WIDTH + cvxif_sup_pkg::X_HARTID_WIDTH - 1 : cvxif_sup_pkg::X_ID_WIDTH];
    x_result_o.data    = result_data_out;
  end

endmodule
