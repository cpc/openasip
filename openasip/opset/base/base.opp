<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<osal version="0.1">

  <operation>
    <name>ADDSUB</name>
    <description>Add and sub the inputs and store results to 3 and 4, respectively.</description>
    <inputs>2</inputs>
    <outputs>2</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <out element-count="1" element-width="32" id="4" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(add, IO(1), IO(2), IO(3));
      EXEC_OPERATION(sub, IO(1), IO(2), IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL1ADD</name>
    <description>Array indexing for 16-bit data types</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      SimValue shifted;
      EXEC_OPERATION(shl, IO(1), 1, shifted);
      EXEC_OPERATION(add, shifted, IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL1ADD64</name>
    <description>Array indexing for 16-bit data types</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <in element-count="1" element-width="64" id="2" type="SLongWord"/>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      SimValue shifted;
      EXEC_OPERATION(shl64, IO(1), 1, shifted);
      EXEC_OPERATION(add64, shifted, IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL2ADD</name>
    <description>Array indexing for 32-bit data types</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      SimValue shifted;
      EXEC_OPERATION(shl, IO(1), 2, shifted);
      EXEC_OPERATION(add, shifted, IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL2ADD64</name>
    <description>Array indexing for 32-bit data types</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <in element-count="1" element-width="64" id="2" type="SLongWord"/>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      SimValue shifted;
      EXEC_OPERATION(shl64, IO(1), 2, shifted);
      EXEC_OPERATION(add64, shifted, IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL3ADD64</name>
    <description>Array indexing for 64-bit data types</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <in element-count="1" element-width="64" id="2" type="SLongWord"/>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      SimValue shifted;
      EXEC_OPERATION(shl64, IO(1), 3, shifted);
      EXEC_OPERATION(add64, shifted, IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ADD</name>
    <description>Integer addition. Output 3 is sum of inputs 1 and 2.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(add, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ADD64</name>
    <description>Integer addition. Output 3 is sum of inputs 1 and 2.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="64" id="2" type="SLongWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(add64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SUB</name>
    <description>Integer subtraction. Input 1 is minuend,  input 2 is subtrahend and output 3 is difference.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sub, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SUB64</name>
    <description>Integer subtraction. Input 1 is minuend,  input 2 is subtrahend and output 3 is difference.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <in element-count="1" element-width="64" id="2" type="SLongWord"/>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sub64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDW</name>
    <description>Loads a 32-bit word in big endian byte order. Input 1 is address and output 2 read data.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldw, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LD32</name>
    <description>Loads a 32-bit word in little endian byte order and sign-extend it</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="64" id="1" type="ULongWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ld32, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDU32</name>
    <description>Loads a 32-bit word in little endian byte order and zero-extend it</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="64" id="1" type="ULongWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldu32, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LD64</name>
    <description>Loads a 64-bit long word in little endian byte order.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="64" id="1" type="ULongWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="64" id="2" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ld64, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>STW</name>
    <description>Stores a 32-bit word to big endian byte order. Input 1 is address and output 2 is write data.</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>
      EXEC_OPERATION(stw, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ST32</name>
    <description>Stores a 32-bit word to little endian byte order.</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="64" id="1" type="ULongWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>
      EXEC_OPERATION(st32, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ST64</name>
    <description>Stores a 64-bit long word to little endian byte order.</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="64" id="1" type="ULongWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="64" id="2" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>
      EXEC_OPERATION(st64, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>EQ</name>
    <description>Equality comparison. Output 3 returns '1' if inputs 1 and 2 are equal and otherwise returns '0'.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(eq, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>EQ64</name>
    <description>Equality comparison. Output 3 returns '1' if inputs 1 and 2 are equal and otherwise returns '0'.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="64" id="2" type="SLongWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(eq64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GT</name>
    <description>Greater-than signed integer comparison. 
Output returns '1' if input 1 is greater than input 2 and otherwise returns '0'.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="1" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gt, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GT64</name>
    <description>Greater-than signed integer comparison for 64-bit value
Output returns '1' if input 1 is greater than input 2 and otherwise returns '0'.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <in element-count="1" element-width="64" id="2" type="SLongWord"/>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gt64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GTU</name>
    <description>Greater-than unsigned integer comparison. Output returns '1' if input 1 is greater than input 2 and otherwise returns '0'.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gtu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GTU64</name>
    <description>Greater-than unsigned long integer comparison. Output returns '1' if input 1 is greater than input 2 and otherwise returns '0'.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <in element-count="1" element-width="64" id="2" type="ULongWord"/>
    <out element-count="1" element-width="64" id="3" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gtu64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LT</name>
    <description>Less-than signed integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gt, IO(2), IO(1), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LT64</name>
    <description>Less-than signed integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <in element-count="1" element-width="64" id="2" type="SLongWord"/>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gt64, IO(2), IO(1), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LTU</name>
    <description>Less-than unsigned integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gtu, IO(2), IO(1), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LTU64</name>
    <description>Less-than unsigned integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <in element-count="1" element-width="64" id="2" type="ULongWord"/>
    <out element-count="1" element-width="64" id="3" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gtu64, IO(2), IO(1), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NE</name>
    <description>Not equal signed integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="1" id="3" type="SIntWord"/>
    <trigger-semantics> 
      SimValue t1;
      EXEC_OPERATION(eq, IO(1), IO(2), t1);
      EXEC_OPERATION(xor, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(gt, IO(1), IO(2), t1);
      EXEC_OPERATION(gt, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NE64</name>
    <description>Not equal signed integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="64" id="2" type="SLongWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(eq64, IO(1), IO(2), t1);
      EXEC_OPERATION(xor64, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(gt64, IO(1), IO(2), t1);
      EXEC_OPERATION(gt64, IO(2), IO(1), t2);
      EXEC_OPERATION(ior64, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GE</name>
    <description>Greater or equal signed integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="1" id="3" type="SIntWord"/>
    <trigger-semantics> 
      SimValue t1;
      EXEC_OPERATION(gt, IO(2), IO(1), t1);
      EXEC_OPERATION(xor, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(gt, IO(1), IO(2), t1);
      EXEC_OPERATION(eq, IO(1), IO(2), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GE64</name>
    <description>Greater or equal signed long integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <in element-count="1" element-width="64" id="2" type="SLongWord"/>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(gt64, IO(2), IO(1), t1);
      EXEC_OPERATION(xor64, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(gt64, IO(1), IO(2), t1);
      EXEC_OPERATION(eq64, IO(1), IO(2), t2);
      EXEC_OPERATION(ior64, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GEU</name>
    <description>Greater or equal unsigned integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(gtu, IO(2),IO(1), t1);
      EXEC_OPERATION(xor, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(gtu, IO(1), IO(2), t1);
      EXEC_OPERATION(eq, IO(1), IO(2), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GEU64</name>
    <description>Greater or equal unsigned integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <in element-count="1" element-width="64" id="2" type="ULongWord"/>
    <out element-count="1" element-width="64" id="3" type="ULongWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(gtu64, IO(2),IO(1), t1);
      EXEC_OPERATION(xor64, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(gtu64, IO(1), IO(2), t1);
      EXEC_OPERATION(eq64, IO(1), IO(2), t2);
      EXEC_OPERATION(ior64, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LE</name>
    <description>Less or equal signed integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="1" id="3" type="SIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(gt, IO(1),IO(2), t1);
      EXEC_OPERATION(xor, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(eq, IO(1), IO(2), t1);
      EXEC_OPERATION(gt, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LE64</name>
    <description>Less or equal signed integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <in element-count="1" element-width="64" id="2" type="SLongWord"/>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(gt64, IO(1),IO(2), t1);
      EXEC_OPERATION(xor64, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(eq64, IO(1), IO(2), t1);
      EXEC_OPERATION(gt64, IO(2), IO(1), t2);
      EXEC_OPERATION(ior64, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LEU</name>
    <description>Less or equal unsigned integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(gtu, IO(1),IO(2), t1);
      EXEC_OPERATION(xor, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(eq, IO(1), IO(2), t1);
      EXEC_OPERATION(gtu, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LEU64</name>
    <description>Less or equal unsigned integer comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <in element-count="1" element-width="64" id="2" type="ULongWord"/>
    <out element-count="1" element-width="64" id="3" type="ULongWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(gtu64, IO(1),IO(2), t1);
      EXEC_OPERATION(xor64, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(eq64, IO(1), IO(2), t1);
      EXEC_OPERATION(gtu64, IO(2), IO(1), t2);
      EXEC_OPERATION(ior64, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL</name>
    <description>Left logical shift. Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="5" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shl, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL1_32</name>
    <description>Left logical shift by 1. Input 1 is value to be shifted and Output 2 is result from operation.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shl, IO(1), 1, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL2_32</name>
    <description>Left logical shift by 2. Input 1 is value to be shifted and Output 2 is result from operation.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shl, IO(1), 2, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL4_32</name>
    <description>Left logical shift by 4. Input 1 is value to be shifted and Output 2 is result from operation.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shl, IO(1), 4, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL8_32</name>
    <description>Left logical shift by 8. Input 1 is value to be shifted and Output 2 is result from operation.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shl, IO(1), 8, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL16_32</name>
    <description>Left logical shift by 16. Input 1 is value to be shifted and Output 2 is result from operation.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shl, IO(1), 16, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL64</name>
    <description>Left logical shift. Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <in element-count="1" element-width="64" id="2" type="SLongWord"/>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shl64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL1_64</name>
    <description>Left logical shift by one bit.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <out element-count="1" element-width="64" id="2" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shl64, IO(1), 1, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL2_64</name>
    <description>Left logical shift by two bits.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <out element-count="1" element-width="64" id="2" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shl64, IO(1), 2, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL4_64</name>
    <description>Left logical shift by four bits.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <out element-count="1" element-width="64" id="2" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shl64, IO(1), 4, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL8_64</name>
    <description>Left logical shift by eight bits.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <out element-count="1" element-width="64" id="2" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shl64, IO(1), 8, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL16_64</name>
    <description>Left logical shift by 16 bits.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <out element-count="1" element-width="64" id="2" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shl64, IO(1), 16, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL32_64</name>
    <description>Left logical shift by 32 bits.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <out element-count="1" element-width="64" id="2" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shl64, IO(1), 32, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHR</name>
    <description>Arithmetic shift right (sign bit duplicated). Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="5" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shr, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHR1_32</name>
    <description>Arithmetic shift right by one bit.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shr, IO(1), 1, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHR2_32</name>
    <description>Arithmetic shift right by two bits.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shr, IO(1), 2, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHR4_32</name>
    <description>Arithmetic shift right by four bits</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shr, IO(1), 4, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHR8_32</name>
    <description>Arithmetic shift right by eight bits.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shr, IO(1), 8, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHR16_32</name>
    <description>Arithmetic shift right by 16 bits.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shr, IO(1), 16, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHR64</name>
    <description>Arithmetic shift right (sign bit duplicated). Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <in element-count="1" element-width="64" id="2" type="SLongWord"/>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shr64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHR1_64</name>
    <description>Arithmetic shift right (sign bit duplicated) by one bit</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <out element-count="1" element-width="64" id="2" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shr64, IO(1), 1, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHR2_64</name>
    <description>Arithmetic shift right (sign bit duplicated) by two bits</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <out element-count="1" element-width="64" id="2" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shr64, IO(1), 2, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHR4_64</name>
    <description>Arithmetic shift right (sign bit duplicated) by four bits</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <out element-count="1" element-width="64" id="2" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shr64, IO(1),4, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHR8_64</name>
    <description>Arithmetic shift right (sign bit duplicated) by 8 bits</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <out element-count="1" element-width="64" id="2" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shr64, IO(1),8, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHR16_64</name>
    <description>Arithmetic shift right (sign bit duplicated) by 16 bits</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <out element-count="1" element-width="64" id="2" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shr64, IO(1),16, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHR32_64</name>
    <description>Arithmetic shift right (sign bit duplicated) by 32 bits</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <out element-count="1" element-width="64" id="2" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shr64, IO(1),32, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHRU</name>
    <description>Logical shift right (most siginificant bits zeroed). Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="5" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
  </operation>

  <operation>
    <name>SHRU1_32</name>
    <description>Logical shift right by one bit.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shru, IO(1), 1, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHRU2_32</name>
    <description>Logical shift right by two bits</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shru, IO(1), 2, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHRU4_32</name>
    <description>Logical shift right by four bits</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shru, IO(1), 4, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHRU8_32</name>
    <description>Logical shift right by eight bits</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shru, IO(1), 8, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHRU16_32</name>
    <description>Logical shift right by 16 bits</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shru, IO(1), 16, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHRU64</name>
    <description>Logical shift right (most siginificant bits zeroed). Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <in element-count="1" element-width="64" id="2" type="ULongWord"/>
    <out element-count="1" element-width="64" id="3" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shru64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHRU1_64</name>
    <description>Logical shift right (most siginificant bits zeroed) by one bit.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <out element-count="1" element-width="64" id="2" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shru64, IO(1), 1, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHRU2_64</name>
    <description>Logical shift right (most siginificant bits zeroed) by two bits.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <out element-count="1" element-width="64" id="2" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shru64, IO(1), 2, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHRU4_64</name>
    <description>Logical shift right (most siginificant bits zeroed) by four bits.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <out element-count="1" element-width="64" id="2" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shru64, IO(1), 4, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHRU8_64</name>
    <description>Logical shift right (most siginificant bits zeroed) by eight bits.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <out element-count="1" element-width="64" id="2" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shru64, IO(1), 8, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHRU16_64</name>
    <description>Logical shift right (most siginificant bits zeroed) by 16 bits.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <out element-count="1" element-width="64" id="2" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shru64, IO(1), 16, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHRU32_64</name>
    <description>Logical shift right (most siginificant bits zeroed) by 32 bits.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <out element-count="1" element-width="64" id="2" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shru64, IO(1), 32, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>AND</name>
    <description>Bitwise AND. Operands 1 and 2 are inputs and 3 is output result.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(and, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>AND64</name>
    <description>Bitwise AND. Operands 1 and 2 are inputs and 3 is output result.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="64" id="2" type="ULongWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="64" id="3" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(and64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>IOR</name>
    <description>Inclusive OR. Operands 1 and 2 are inputs and 3 is output result.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(ior, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>IOR64</name>
    <description>Inclusive OR. Operands 1 and 2 are inputs and 3 is output result.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="64" id="2" type="ULongWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="64" id="3" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(ior64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>XOR</name>
    <description>Exclusive OR. Operands 1 and 2 are inputs and 3 is output result.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(xor, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>XOR64</name>
    <description>Exclusive OR. Operands 1 and 2 are inputs and 3 is output result.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="64" id="2" type="ULongWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="64" id="3" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(xor64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>JUMP</name>
    <description>Absolute jump to the given instruction address.</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(jump, IO(1));
    </trigger-semantics>
  </operation>

  <operation>
    <name>JUMPR</name>
    <description>PC-relative jump to the given instruction address.</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(jumpr, IO(1));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CALL</name>
    <description>Calls a function at the given absolute instruction address. The return address is saved in the return address register (RA).</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-call/>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(call, IO(1));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CALLA</name>
    <description>Sums the two input values and calls the result address. The return address is saved in the return address register (RA).</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-call/>
    <in element-count="1" element-width="64" id="1" type="ULongWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="64" id="2" type="ULongWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <trigger-semantics>
      SimValue addr;
      EXEC_OPERATION(add, IO(1), IO(2), addr);
      EXEC_OPERATION(call, addr);
    </trigger-semantics>
  </operation>

  <operation>
    <name>APC</name>
    <description>Adds the input value with the program counter and moves the result to output.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <out element-count="1" element-width="64" id="2" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(apc, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CALLR</name>
    <description>Calls a function at the given PC-relative instruction address. The return address is saved in the return address register (RA).</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-call/>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(callr, IO(1));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MIN</name>
    <description>Returns the smaller of the two signed integer values. Operands 1 and 2 are inputs and 3 is output result.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(min, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MIN64</name>
    <description>Returns the smaller of the two signed integer values. Operands 1 and 2 are inputs and 3 is output result.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="64" id="2" type="SLongWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(min, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MAX64</name>
    <description>Returns the larger of the two signed input values. Operands 1 and 2 are inputs and 3 is output result.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="64" id="2" type="SLongWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(max, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MAX</name>
    <description>Returns the larger of the two signed input values. Operands 1 and 2 are inputs and 3 is output result.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(max, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MINU</name>
    <description>Returns the smaller of the two unsigned input values.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(minu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MINU64</name>
    <description>Returns the smaller of the two unsigned input values.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="64" id="2" type="ULongWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="64" id="3" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(minu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MAXU</name>
    <description>Returns the larger of the two unsigned input values.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(maxu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MAXU64</name>
    <description>Returns the larger of the two unsigned input values.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="64" id="2" type="ULongWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="64" id="3" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(maxu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDQ</name>
    <description>Loads a byte and sign extends it to the output port width.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="SIntWord">
      <mem-data/>
    </out>
    <trigger-semantics>
      SimValue tmp;
      EXEC_OPERATION(ldq, IO(1), tmp);
      EXEC_OPERATION(sxqw, tmp, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LD8</name>
    <description>Loads a byte and sign extends it to the output port width (identical to LDQ).</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="64" id="1" type="ULongWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="SIntWord">
      <mem-data/>
    </out>
    <trigger-semantics>
      SimValue tmp;
      EXEC_OPERATION(ldq, IO(1), tmp);
      EXEC_OPERATION(sxqw, tmp, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDH</name>
    <description>Reads half word from memory with sign extension.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="SIntWord">
      <mem-data/>
    </out>
    <trigger-semantics>
      SimValue tmp;
      EXEC_OPERATION(ldh, IO(1), tmp);
      EXEC_OPERATION(sxhw, tmp, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LD16</name>
    <description>Loads a 16-bit word in little endian byte order and sign extends to the output port width.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="64" id="1" type="ULongWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="SIntWord">
      <mem-data/>
    </out>
    <trigger-semantics>
      SimValue tmp;
      EXEC_OPERATION(ld16, IO(1), tmp);
      EXEC_OPERATION(sxhw, tmp, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDD</name>
    <description>Reads double word from memory.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="64" id="2" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldd, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>STQ</name>
    <description>Stores a byte to an absolute byte address in memory.</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="8" id="2" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>
      EXEC_OPERATION(stq, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ST8</name>
    <description>Stores a byte to an absolute byte address in memory (identical to STQ).</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="8" id="2" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>
      EXEC_OPERATION(stq, IO(1), IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(st8, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>STH</name>
    <description>Stores a 16-bit word to big endian byte order.</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="16" id="2" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>
      EXEC_OPERATION(sth, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ST16</name>
    <description>Stores a 16-bit word to little endian byte order.</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="16" id="2" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>EXEC_OPERATION(st16, IO(1), IO(2));

</trigger-semantics>
  </operation>

  <operation>
    <name>STD</name>
    <description>Store double word to memory.</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="64" id="2" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>
      EXEC_OPERATION(std, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SXBW</name>
    <description>sign extend from 1 bit to 32 bits</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="1" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sxbw, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SXQW</name>
    <description>Sign extend from 8 bits of the input 1 to 32 bits into output 2.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="8" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sxqw, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SXHW</name>
    <description>Sign extend from 16 bits of of the input 1 to 32 bits into output 2.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sxhw, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SXB64</name>
    <description>sign extend from 1 bit to 64 bits</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="8" id="1" type="SIntWord"/>
    <out element-count="1" element-width="64" id="2" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sxb64, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SXQ64</name>
    <description>Sign extend from 8 bits of the input 1 to 64 bits into output 2.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="8" id="1" type="SIntWord"/>
    <out element-count="1" element-width="64" id="2" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sxq64, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SXH64</name>
    <description>Sign extend from 16 bits of of the input 1 to 64 bits into output 2.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="64" id="2" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sxh64, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SXW64</name>
    <description>Sign extend from 32 bits of of the input 1 to 32 bits into output 2.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="64" id="2" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sxw64, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ZXW64</name>
    <description>Zero- extend from 32 bits of of the input 1 to 32 bits into output 2.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="64" id="2" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(and64, IO(1), 4294967295, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(zxw64, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>TRUNCWH</name>
    <description>truncate 32 bit int to 16 bit int</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="16" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(truncwh, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEG</name>
    <description>Arithmetic negation, signed integer.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(neg, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEG64</name>
    <description>Arithmetic negation, signed integer.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <out element-count="1" element-width="64" id="2" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(neg64, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEGF</name>
    <description>Arithmetic negation, floating-point.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <out element-count="1" element-width="32" id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(negf, IO(1), IO(2));
    </trigger-semantics>
    <trigger-semantics>
      SimValue tmp;
      EXEC_OPERATION(subf, IO(1), IO(1), tmp);
      EXEC_OPERATION(subf, tmp, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEGH</name>
    <description>Arithmetic negation, half floating-point.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(negf, t1, t2);
      EXEC_OPERATION(cfh, t2, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(negh, IO(1), IO(2));
    </trigger-semantics>
    <trigger-semantics>
      SimValue tmp;
      EXEC_OPERATION(subh, IO(1), IO(1), tmp);
      EXEC_OPERATION(subh, tmp, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MAXF</name>
    <description>Returns the larger of the two floating-point input values.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="FloatWord"/>
  </operation>

  <operation>
    <name>MINF</name>
    <description>Returns the smaller of the two floating-point input values.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="FloatWord"/>
  </operation>

  <operation>
    <name>MAXH</name>
    <description>Returns the larger of the two half floating-point input values.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(maxf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MINH</name>
    <description>Returns the smaller of the two half floating-point input values.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(minf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MUL</name>
    <description>32-bit integer multiplication of the inputs 1 and 2 with lower result bits in the output 3.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(mul, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MULHI</name>
    <description>32-bit integer multiplication of the signed inputs 1 and 2 with higher result bits in the output 3.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
  </operation>

  <operation>
    <name>MULHIU</name>
    <description>32-bit integer multiplication of the unsigned inputs 1 and 2 with higher result bits in the output 3.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
  </operation>

  <operation>
    <name>MULHISU</name>
    <description>32-bit integer multiplication of the signed input 1 and unsigned input 2 with higher result bits in the output 3.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
  </operation>

  <operation>
    <name>MUL64</name>
    <description>64-bit integer multiplication of the inputs 1 and 2 with lower result bits in the output 3.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="64" id="2" type="SLongWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(mul64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>DIV</name>
    <description>Integer division.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(div, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>DIV64</name>
    <description>Long Integer division.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <in element-count="1" element-width="64" id="2" type="SLongWord"/>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(div64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>DIVU</name>
    <description>Unsigned integer division.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(divu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>DIVU64</name>
    <description>Unsigned long integer division.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <in element-count="1" element-width="64" id="2" type="ULongWord"/>
    <out element-count="1" element-width="64" id="3" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(divu64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ADDF</name>
    <description>Floating-point addition. Output 3 is sum of inputs 1 and 2.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(addf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SUBF</name>
    <description>Floating-point substraction.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(subf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MULF</name>
    <description>32-bit floating-point multiplication</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(mulf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>DIVF</name>
    <description>Floating-point division.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(divf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>EQF</name>
    <description>Floating-point compare equal (ordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(eqf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEF</name>
    <description>Not equal floating-point comparison (ordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(nef, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(gtf, IO(1), IO(2), t1);
      EXEC_OPERATION(gtf, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GTF</name>
    <description>Greater-than floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gtf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GEF</name>
    <description>Greater or equal floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gef, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(gtf, IO(1), IO(2), t1);
      EXEC_OPERATION(eqf, IO(1), IO(2), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LTF</name>
    <description>Less-than floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(ltf, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(gtf, IO(2), IO(1), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LEF</name>
    <description>Less or equal floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(lef, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(eqf, IO(1), IO(2), t1);
      EXEC_OPERATION(gtf, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>EQUF</name>
    <description>Floating-point compare equal (unordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>EXEC_OPERATION(eqf, IO(1), IO(2), IO(3));



</trigger-semantics>
  </operation>

  <operation>
    <name>NEUF</name>
    <description>Not equal floating-point comparison (unordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1;
EXEC_OPERATION(eqf, IO(1), IO(2), temp1);
EXEC_OPERATION(xor, temp1, 1, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>GTUF</name>
    <description>Greater-than floating-point comparison (unordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>EXEC_OPERATION(gtf, IO(1), IO(2), IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>GEUF</name>
    <description>Greater or equal floating-point comparison (unordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1, temp2;
EXEC_OPERATION(gtf, IO(1), IO(2), temp1);
EXEC_OPERATION(eqf, IO(1), IO(2), temp2);
EXEC_OPERATION(ior, temp1, temp2, IO(3));


</trigger-semantics>
  </operation>

  <operation>
    <name>LTUF</name>
    <description>Less-than floating-point comparison (unordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1, temp2, temp3;
EXEC_OPERATION(gtf, IO(1), IO(2), temp1);
EXEC_OPERATION(eqf, IO(1), IO(2), temp2);
EXEC_OPERATION(ior, temp1, temp2, temp3);
EXEC_OPERATION(xor, temp3, 1, IO(3));



</trigger-semantics>
  </operation>

  <operation>
    <name>LEUF</name>
    <description>Less or equal floating-point comparison (unordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1;
EXEC_OPERATION(gtf, IO(1), IO(2), temp1);
EXEC_OPERATION(xor,temp1,1, IO(3));

</trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(eqf, IO(1), IO(2), t1);
      EXEC_OPERATION(gtf, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ADDH</name>
    <description>Half precision floating-point addition. Output 3 is sum of inputs 1 and 2.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="16" id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(addf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SUBH</name>
    <description>Half floating-point substraction.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(subf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(subh, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MULH</name>
    <description>16-bit floating-point multiplication.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="16" id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(mulf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(mulh, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>DIVH</name>
    <description>Half float division.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(divf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(divh, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MACH</name>
    <description>Multiply and accumulate (half floating-point).</description>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="16" id="3" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="16" id="4" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mulh, IO(2), IO(3), t1);
      EXEC_OPERATION(addh, IO(1), t1, IO(4));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2, t3, t4, t5;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(chf, IO(3), t3);
      EXEC_OPERATION(mulf, t2, t3, t4);
      EXEC_OPERATION(addf, t1, t4, t5);
      EXEC_OPERATION(cfh, t5, IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MSUH</name>
    <description>Multiply and substract (half floating-point).</description>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="16" id="3" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="16" id="4" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mulh, IO(2), IO(3), t1);
      EXEC_OPERATION(subh, IO(1), t1, IO(4));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2, t3, t4, t5;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(chf, IO(3), t3);
      EXEC_OPERATION(mulf, t2, t3, t4);
      EXEC_OPERATION(subf, t1, t4, t5);
      EXEC_OPERATION(cfh, t5, IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MACF</name>
    <description>Multiply and accumulate (floating-point).</description>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="3" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="4" type="FloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mulf, IO(2), IO(3), t1);
      EXEC_OPERATION(addf, IO(1), t1, IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MSUF</name>
    <description>Multiply and substract (floating-point).</description>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="3" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="4" type="FloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mulf, IO(2), IO(3), t1);
      EXEC_OPERATION(subf, IO(1), t1, IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MAC</name>
    <description>Multiply and accumulate (signed integer).</description>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="3" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="4" type="SIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mul, IO(2), IO(3), t1);
      EXEC_OPERATION(add, t1, IO(1), IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MAC64</name>
    <description>Multiply and accumulate (signed long).</description>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <in element-count="1" element-width="64" id="2" type="SLongWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="64" id="3" type="SLongWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="64" id="4" type="SLongWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mul64, IO(2), IO(3), t1);
      EXEC_OPERATION(add64, t1, IO(1), IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>EQH</name>
    <description>Half floating-point compare equal.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(eqf, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(eqh, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEH</name>
    <description>Not equal half floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(nef, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(neh, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(gth, IO(1), IO(2), t1);
      EXEC_OPERATION(gth, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEUH</name>
    <description>Not equal half floating-point comparison (unordered).</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(neuf, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GTH</name>
    <description>Greater-than half floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(gtf, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(gth, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GEH</name>
    <description>Greater or equal half floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(gef, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(geh, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(gth, IO(1), IO(2), t1);
      EXEC_OPERATION(eqh, IO(1), IO(2), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LTH</name>
    <description>Less-than half floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(ltf, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(lth, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(gth, IO(2), IO(1), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LEH</name>
    <description>Less or equal half floating-point comparison.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <in element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <out element-count="1" element-width="1" id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(lef, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(leh, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(eqh, IO(1), IO(2), t1);
      EXEC_OPERATION(gth, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CFI</name>
    <description>Converts floating-point to integer.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cfi, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CFIU</name>
    <description>Converts floating-point to unsigned integer.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cfiu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CIF</name>
    <description>Converts integer to float.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cif, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CIFU</name>
    <description>Converts unsigned integer to floating-point.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cifu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CFD</name>
    <description>Converts single precision floating-point to double.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <out element-count="1" element-width="64" id="2" type="DoubleWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cfd, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CDF</name>
    <description>Converts double precision floating-point to single precision.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="DoubleWord"/>
    <out element-count="1" element-width="32" id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cdf, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CHI</name>
    <description>Converts half floating-point to signed integer.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(cfi, t1, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(chi, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CHIU</name>
    <description>Converts half floating-point to unsigned integer.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(cfiu, t1, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(chiu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CIH</name>
    <description>Converts integer to half floating-point.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(cif, IO(1), t1);
      EXEC_OPERATION(cfh, t1, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(cih, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CIHU</name>
    <description>Converts unsigned integer to half floating-point.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(cifu, IO(1), t1);
      EXEC_OPERATION(cfh, t1, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(cihu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CHF</name>
    <description>Converts half precision floating-point to single precision.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="32" id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(chf, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CFH</name>
    <description>Converts single precision floating-point to half.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cfh, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ROTL</name>
    <description>Rotate left.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
  </operation>

  <operation>
    <name>ROTL64</name>
    <description>Rotate left.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <in element-count="1" element-width="64" id="2" type="ULongWord"/>
    <out element-count="1" element-width="64" id="3" type="ULongWord"/>
  </operation>

  <operation>
    <name>ROTR</name>
    <description>Rotate right.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(rotr, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ROTR64</name>
    <description>Rotate right.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <in element-count="1" element-width="64" id="2" type="ULongWord"/>
    <out element-count="1" element-width="64" id="3" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(rotr64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ABS</name>
    <description>Absolute value.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <out element-count="1" element-width="32" id="2" type="SIntWord"/>
  </operation>

  <operation>
    <name>ABS64</name>
    <description>Absolute value.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <out element-count="1" element-width="64" id="2" type="SLongWord"/>
  </operation>

  <operation>
    <name>ABSF</name>
    <description>Floating-point absolute value.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <out element-count="1" element-width="32" id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(absf, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ABSH</name>
    <description>Half precision floating-point absolute value.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(absf, t1, t2);
      EXEC_OPERATION(cfh, t2, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(absh, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDQU</name>
    <description>Loads a byte and zero extends to the output port width.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldqu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDU8</name>
    <description>Loads a byte and zero extends to the output port width (identical to LDQU).</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="64" id="1" type="ULongWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="UIntWord">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldqu, IO(1), IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(ldu8, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDHU</name>
    <description>Loads a 16-bit word in big endian byte order and zero extends to 32 bits.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="16" id="2" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldhu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDU16</name>
    <description>Loads a 16-bit word in little endian byte order and zero extends to 32 bits.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="64" id="1" type="ULongWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="UIntWord">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldu16, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MOD</name>
    <description>Integer modulo.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(mod, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>REM</name>
    <description>Integer remainder.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(rem, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MOD64</name>
    <description>Integer modulo.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="SLongWord"/>
    <in element-count="1" element-width="64" id="2" type="SLongWord"/>
    <out element-count="1" element-width="64" id="3" type="SLongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(mod64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MODU</name>
    <description>Integer modulo (unsigned)</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(modu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>REMU</name>
    <description>Integer remainder (unsigned)</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(remu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MODU64</name>
    <description>Integer modulo (unsigned)</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <in element-count="1" element-width="64" id="2" type="ULongWord"/>
    <out element-count="1" element-width="64" id="3" type="ULongWord"/>
    <trigger-semantics>
      EXEC_OPERATION(modu64, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>STDOUT</name>
    <description>Writes a single 8bit char to "standard output" which is platform dependent. In simulator outputs the character to simulator console. Used for debugging. printf() uses this by default.</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <side-effects/>
    <in element-count="1" element-width="8" id="1" type="RawData"/>
    <trigger-semantics>
      EXEC_OPERATION(stdout, IO(1));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NOT</name>
    <description>Bitwise negation.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>NOT64</name>
    <description>Bitwise negation.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="ULongWord"/>
    <out element-count="1" element-width="64" id="2" type="ULongWord"/>
  </operation>

  <operation>
    <name>ANDN</name>
    <description>Does a bitwise negation (NOT) on the 2nd input followed by AND of the 1st input and the negated 2nd output. Special instruction in TI C64X.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>	SimValue negResult, mulin;
	EXEC_OPERATION(not, IO(2), negResult);
	EXEC_OPERATION(and, negResult, IO(1), IO(3));










</trigger-semantics>
  </operation>

  <operation>
    <name>LMBD</name>
    <description>Leftmost Bit Detection (from TI C64X). Counts the number of 0's or 1's in the bit representation of operand 1 before the first 1 or 0. 2nd operand is used to tell whether to search for a 0 or 1.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
  </operation>

  <operation>
    <name>STREAM_IN</name>
    <description>The "default streaming" operation for input.
Reads one sample of input from the data stream. The width of the sample is defined by the function unit output port width. 
When triggered with 0 writes a new sample to the output, if there are one ore more samples to be read in the buffer, otherwise causes a global lock.
The IN file can be set using TTASIM_STREAM_IN_FILE environment variable.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <affects>
      <operation name="STREAM_IN_STATUS"/>
    </affects>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="RawData"/>
  </operation>

  <operation>
    <name>STREAM_OUT</name>
    <description>The "default streaming" operation for output.
Writes one sample to the output data stream. The width of the sample is
defined by the function unit input port width.
In case no room is available in the output buffer, causes a global lock.
The OUT file can be set using TTASIM_STREAM_OUT_FILE environment variable.</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <side-effects/>
    <affects>
      <operation name="STREAM_OUT_STATUS"/>
    </affects>
    <in element-count="1" element-width="32" id="1" type="RawData"/>
  </operation>

  <operation>
    <name>STREAM_IN_STATUS</name>
    <description>The "default streaming" operation for querying input buffer status.

Trigger with 0.

Return an integer with the following meanings:

0 = buffer empty
1 = not empty nor full (implies a buffer size &gt; 1 sample and that there is at least one sample in the buffer)
2 = buffer full

This operation allows handling stream buffer underflow without a global lock, thus allows doing something useful (run another thread, for example) while the buffer is empty.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <affected-by>
      <operation name="STREAM_IN"/>
    </affected-by>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>STREAM_OUT_STATUS</name>
    <description>The "default streaming" operation for querying output buffer status.

Trigger with 0.

Return an integer with the following meanings:

0 = buffer empty
1 = not empty nor full (implies a buffer size &gt; 1 sample and that there is at least one sample in the buffer)
2 = buffer full

This operation allows handling stream buffer overflow without a global lock, thus allows doing something useful (run another thread, for example) while the
buffer is full.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <affected-by>
      <operation name="STREAM_OUT"/>
    </affected-by>
    <in element-count="1" element-width="32" id="1" type="RawData"/>
    <out element-count="1" element-width="32" id="2" type="RawData"/>
  </operation>

  <operation>
    <name>RTIMER</name>
    <description>Real time timer. 

Counts time (given in microseconds) down from the given value until reaches zero.

When triggered with 0, returns the current timer value, when triggered with a value greater than 0, sets the timer value.

The simulation behavior definition assumes 100MHz clock frequency, which can be modified using the environment variable TCE_RTIMER_CLOCK=MHZ.

</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>RTC</name>
    <description>Real time clock.

Counts time (microseconds) up from zero.

When triggered with 0, resets the timer value to zero, when triggered with a value greater than 0, returns the timer value.

The simulation behavior definition assumes 100MHz clock frequency, which can be modified using the environment variable TCE_RTIMER_CLOCK=MHZ.

</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>ORDF</name>
    <description>Returns 1 if floating point input operands are ordered. i.e. neither of the input operands is NaN.

</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in element-count="1" element-width="32" id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1, temp2;
EXEC_OPERATION(eqf, IO(1), IO(1), temp1);
EXEC_OPERATION(eqf, IO(2), IO(2), temp2);
EXEC_OPERATION(and, temp1, temp2, IO(3));



</trigger-semantics>
  </operation>

  <operation>
    <name>UORDF</name>
    <description>Returns 1 if the two floating point operands are unordered. i.e. isNaN(io1) || isNan(io2).

</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <in element-count="1" element-width="32" id="2" type="FloatWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1, temp2, temp3;
EXEC_OPERATION(eqf, IO(1), IO(1), temp1);
EXEC_OPERATION(eqf, IO(2), IO(2), temp2);
EXEC_OPERATION(and, temp1, temp2, temp3);
EXEC_OPERATION(xor, temp3, 1, IO(3));



</trigger-semantics>
  </operation>

  <operation>
    <name>SQRTF</name>
    <description>Performs a square root of a single precision floating point. For example, the MIPS R4000 FPU implements it.
</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="FloatWord"/>
    <out element-count="1" element-width="32" id="2" type="FloatWord"/>
  </operation>

  <operation>
    <name>SQRTH</name>
    <description>Performs a square root of a half precision floating point.
    </description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(sqrtf, t1, t2);
      EXEC_OPERATION(cfh, t2, IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>INVSQRTH</name>
    <description>Performs a inverse square root of a half-precision floating point.
</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
  </operation>

  <operation>
    <name>SQUAREH</name>
    <description>Computes the square of a half-precision floating point.
</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(mulf, t1, t1, t2);
      EXEC_OPERATION(cfh, t2, IO(2));
    </trigger-semantics>
    <trigger-semantics>
EXEC_OPERATION(mulh, IO(1), IO(1), IO(2));
</trigger-semantics>
  </operation>

  <operation>
    <name>LEDS</name>
    <description>Control leds by writing a bit pattern. Bit 1 switches a led on and 0 switches off.</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
  </operation>

  <operation>
    <name>LDW4</name>
    <description>Loads vector of 4 words from memory.</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(3));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(4));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>STW4</name>
    <description>Stores 4 words to memory consecutively.</description>
    <inputs>5</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(stw, tmp, IO(3));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(4));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(5));



</trigger-semantics>
  </operation>

  <operation>
    <name>LDW2</name>
    <description>Loads two words from memory.</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>STW2</name>
    <description>Stores two words to memory.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(stw, tmp, IO(3));




</trigger-semantics>
  </operation>

  <operation>
    <name>STW8</name>
    <description>Writes 8 words to memory</description>
    <inputs>9</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(stw, tmp, IO(3));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(4));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(5));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(6));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(7));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(8));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(9));




</trigger-semantics>
  </operation>

  <operation>
    <name>LDW8</name>
    <description>Loads 8 words from memory.</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(3));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(4));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(5));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(6));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(7));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(8));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>BCAST2</name>
    <description>Copies data to two outputs</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <in element-count="1" element-width="32" id="1" type="RawData"/>
    <out element-count="1" element-width="32" id="2" type="RawData"/>
    <out element-count="1" element-width="32" id="3" type="RawData"/>
  </operation>

  <operation>
    <name>BCAST4</name>
    <description>Copies data to four outputs.</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <in element-count="1" element-width="32" id="1" type="RawData"/>
    <out element-count="1" element-width="32" id="2" type="RawData"/>
    <out element-count="1" element-width="32" id="3" type="RawData"/>
    <out element-count="1" element-width="32" id="4" type="RawData"/>
    <out element-count="1" element-width="32" id="5" type="RawData"/>
  </operation>

  <operation>
    <name>BCAST8</name>
    <description>Copies data to eight outputs.</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <in element-count="1" element-width="32" id="1" type="RawData"/>
    <out element-count="1" element-width="32" id="2" type="RawData"/>
    <out element-count="1" element-width="32" id="3" type="RawData"/>
    <out element-count="1" element-width="32" id="4" type="RawData"/>
    <out element-count="1" element-width="32" id="5" type="RawData"/>
    <out element-count="1" element-width="32" id="6" type="RawData"/>
    <out element-count="1" element-width="32" id="7" type="RawData"/>
    <out element-count="1" element-width="32" id="8" type="RawData"/>
    <out element-count="1" element-width="32" id="9" type="RawData"/>
  </operation>

  <operation>
    <name>LDH2</name>
    <description>Reads two half words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldh, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>LDHU2</name>
    <description>Reads two half words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldhu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>LDH4</name>
    <description>Reads four half words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldh, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDHU4</name>
    <description>Reads four half words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldhu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDH8</name>
    <description>Reads eight half words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldh, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(5));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(6));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(7));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(8));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDHU8</name>
    <description>Reads eight half words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldhu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(5));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(6));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(7));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(8));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDQ2</name>
    <description>Reads two quarter words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>LDQU2</name>
    <description>Reads two quarter words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldqu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>LDQ4</name>
    <description>Reads four quarter words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDQU4</name>
    <description>Reads four quarter words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldqu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDQ8</name>
    <description>Reads eight quarter words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(5));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(6));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(7));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(8));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDQU8</name>
    <description>Reads eight quarter words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </out>
    <out element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldqu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(5));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(6));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(7));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(8));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>STH2</name>
    <description>Stores two half words to memory</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(sth, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(sth, tmp, IO(3));
</trigger-semantics>
  </operation>

  <operation>
    <name>STH4</name>
    <description>Stores four half words to memory</description>
    <inputs>5</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(sth, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(sth, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>STH8</name>
    <description>Stores eight half words to memory</description>
    <inputs>9</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(sth, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(sth, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(5));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(6));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(7));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(8));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>STQ2</name>
    <description>Stores two quarter words to memory</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(stq, tmp, IO(3));
</trigger-semantics>
  </operation>

  <operation>
    <name>STQ4</name>
    <description>Stores four quarter words to memory</description>
    <inputs>5</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(stq, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>STQ8</name>
    <description>Stores eight quarter words to memory</description>
    <inputs>9</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="3" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="4" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="5" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="6" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="7" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="8" type="RawData">
      <mem-data/>
    </in>
    <in element-count="1" element-width="32" id="9" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(stq, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(5));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(6));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(7));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(8));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>ECC</name>
    <description>Execution cycle counter. Free running counter that counts execution cycles i.e. cycles when reset and global lock are not active. Handy for profiling hardware execution.
ISS behavior will return the current cycle count.
Input operand is discarded.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>LCC</name>
    <description>Lock cycle counter. Free running counter that count global lock cycles. On hardware, reset most probably zeroes the counter. ISS behavior will always return zero. Handy for profiling hardware execution.
Input operand is discarded.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <out element-count="1" element-width="32" id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>SELECT</name>
    <description>Select one of two values</description>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="32" id="1" type="RawData"/>
    <in element-count="1" element-width="32" id="2" type="RawData"/>
    <in element-count="1" element-width="32" id="3" type="UIntWord"/>
    <out element-count="1" element-width="32" id="4" type="RawData"/>
    <trigger-semantics>
    </trigger-semantics></operation>

  <operation>
    <name>SELECT64</name>
    <description>Select one of two values</description>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="64" id="1" type="RawData"/>
    <in element-count="1" element-width="64" id="2" type="RawData"/>
    <in element-count="1" element-width="64" id="3" type="ULongWord"/>
    <out element-count="1" element-width="64" id="4" type="RawData"/>
    <trigger-semantics>
    </trigger-semantics></operation>

  <operation>
    <name>CHS</name>
    <description>Convert half to short</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="2" type="SIntWord"/>
  </operation>

  <operation>
    <name>CHSU</name>
    <description>Convert half to short unsigned</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="HalfFloatWord"/>
    <out element-count="1" element-width="16" id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>CSH</name>
    <description>Convert short to half</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="SIntWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
  </operation>

  <operation>
    <name>CSHU</name>
    <description>Convert short to half unsigned</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in element-count="1" element-width="16" id="1" type="UIntWord"/>
    <out element-count="1" element-width="16" id="2" type="HalfFloatWord"/>
  </operation>

  <operation>
    <name>SLEEP</name>
    <description>Puts the core to sleep (global lock) until an external signal wakes it up. The simulation model waits for a POSIX signal SIGUSR1.</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <side-effects/>
    <in element-count="1" element-width="1" id="1" type="RawData"/>
  </operation>

  <operation>
    <name>ALD8</name>
    <description>Little endian base + offset load</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>SimValue address;
EXEC_OPERATION(add, IO(1), IO(2), address);
EXEC_OPERATION(ld8, address, IO(3));



</trigger-semantics>
  </operation>

  <operation>
    <name>ALDU8</name>
    <description>Little endian base + offset load</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue address;
EXEC_OPERATION(add, IO(1), IO(2), address);
EXEC_OPERATION(ldu8, address, IO(3));


</trigger-semantics>
  </operation>

  <operation>
    <name>ALD16</name>
    <description>Little endian base + offset load</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>SimValue address;
EXEC_OPERATION(add, IO(1), IO(2), address);
EXEC_OPERATION(ld16, address, IO(3));




</trigger-semantics>
  </operation>

  <operation>
    <name>ALDU16</name>
    <description>Little endian base + offset load</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue address;
EXEC_OPERATION(add, IO(1), IO(2), address);
EXEC_OPERATION(ldu16, address, IO(3));




</trigger-semantics>
  </operation>

  <operation>
    <name>ALD32</name>
    <description>Little endian base + offset load</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <out element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue address;
EXEC_OPERATION(add, IO(1), IO(2), address);
EXEC_OPERATION(ld32, address, IO(3));



</trigger-semantics>
  </operation>

  <operation>
    <name>AST32</name>
    <description>Base + offset store. The input 1 is the base address, input 2 the offset and input 3 the data.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <in element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue address;
EXEC_OPERATION(add, IO(1), IO(2), address);
EXEC_OPERATION(st32, address, IO(3));


</trigger-semantics>
  </operation>

  <operation>
    <name>AST16</name>
    <description>Base + offset store. The input 1 is the base address, input 2 the offset and input 3 the data.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <in element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue address;
EXEC_OPERATION(add, IO(1), IO(2), address);
EXEC_OPERATION(st16, address, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>AST8</name>
    <description>Base + offset store. The input 1 is the base address, input 2 the offset and input 3 the data.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <in element-count="1" element-width="32" id="3" type="UIntWord"/>
    <trigger-semantics>SimValue address;
EXEC_OPERATION(add, IO(1), IO(2), address);
EXEC_OPERATION(st8, address, IO(3));


</trigger-semantics>
  </operation>

  <operation>
    <name>BNZ</name>
    <description>Branch-if-not-zero. Jumps to the given location if the value is non-zero.

Input 1: The value to be tested.
Input 2: The branch target.</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="RawData"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>EXEC_OPERATION(bnz, IO(1));
  </trigger-semantics>
  </operation>

  <operation>
    <name>BNZR</name>
    <description>Branch-if-not-zero. Jumps to the given PC relative location if the value is non-zero.

Input 1: The value to be tested.
Input 2: The branch target.</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="RawData"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>EXEC_OPERATION(bnzr, IO(1));

</trigger-semantics>
  </operation>

  <operation>
    <name>BZ1</name>
    <description>Branch-if-zero. Jumps to the given location if the lowest bit of value is zero.

Input 1: The value to be tested.
Input 2: The branch target.</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="1" id="1" type="RawData"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>EXEC_OPERATION(bz1, IO(1));

</trigger-semantics>
  </operation>

  <operation>
    <name>BNZ1</name>
    <description>Branch-if-not-zero. Jumps to the given location if the lowest bit of value is non-zero.

Input 1: The value to be tested.
Input 2: The branch target.</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="1" id="1" type="RawData"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <trigger-semantics>EXEC_OPERATION(bnz1, IO(1));


</trigger-semantics>
  </operation>

  <operation>
    <name>BEQ</name>
    <description>Branch-if-equal. Compares the first two operands, uses the third as branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(eq, IO(1), IO(2), cr);
       EXEC_OPERATION(bnz, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BNE</name>
    <description>Branch-if-not-equal. Compares the first two operands, uses the third as branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(ne, IO(1), IO(2), cr);
       EXEC_OPERATION(bnz, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BGT</name>
    <description>Branch-if-greater. Compares the first two operands, uses the third as branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(gt, IO(1), IO(2), cr);
       EXEC_OPERATION(bnz, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BLT</name>
    <description>Branch-if-lesser. Compares the first two operands, uses the third as branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(lt, IO(1), IO(2), cr);
       EXEC_OPERATION(bnz, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BGTU</name>
    <description>Unsigned branch-if-greater. Compares the first two operands, uses the third as branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(gtu, IO(1), IO(2), cr);
       EXEC_OPERATION(bnz, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BLTU</name>
    <description>Unsigned branch-if-lesser. Compares the first two operands, uses the third as branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(ltu, IO(1), IO(2), cr);
       EXEC_OPERATION(bnz, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BLE</name>
    <description>Branch-if-less-or-equal. Compares the first two operands, uses the third as branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(le, IO(1), IO(2), cr);
       EXEC_OPERATION(bnz, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BGE</name>
    <description>Branch-if-greater-or-equal. Compares the first two operands, uses the third as branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(ge, IO(1), IO(2), cr);
       EXEC_OPERATION(bnz, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BLEU</name>
    <description>Unsigned branch-if-less-or-equal. Compares the first two operands, uses the third as branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(leu, IO(1), IO(2), cr);
       EXEC_OPERATION(bnz, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BGEU</name>
    <description>Unsigned branch-if-greater-equal. Compares the first two operands, uses the third as branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(geu, IO(1), IO(2), cr);
       EXEC_OPERATION(bnz, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BEQR</name>
    <description>Branch-if-equal. Compares the first two operands, uses the third as PC relative branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(eq, IO(1), IO(2), cr);
       EXEC_OPERATION(bnzr, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BNER</name>
    <description>Branch-if-not-equal. Compares the first two operands, uses the third as PC relative branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(ne, IO(1), IO(2), cr);
       EXEC_OPERATION(bnzr, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BGTR</name>
    <description>Branch-if-greater. Compares the first two operands, uses the third as PC relative branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(gt, IO(1), IO(2), cr);
       EXEC_OPERATION(bnzr, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BLTR</name>
    <description>Branch-if-lesser. Compares the first two operands, uses the third as PC relative branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(lt, IO(1), IO(2), cr);
       EXEC_OPERATION(bnzr, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BGTUR</name>
    <description>Unsigned branch-if-greater. Compares the first two operands, uses the third as PC relative branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(gtu, IO(1), IO(2), cr);
       EXEC_OPERATION(bnzr, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BLTUR</name>
    <description>Unsigned branch-if-lesser. Compares the first two operands, uses the third as PC relative branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(ltu, IO(1), IO(2), cr);
       EXEC_OPERATION(bnzr, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BLER</name>
    <description>Branch-if-less-or-equal. Compares the first two operands, uses the third as PC relative branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(le, IO(1), IO(2), cr);
       EXEC_OPERATION(bnzr, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BGER</name>
    <description>Branch-if-greater-or-equal. Compares the first two operands, uses the third as PC relative branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="SIntWord"/>
    <in element-count="1" element-width="32" id="2" type="SIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(ge, IO(1), IO(2), cr);
       EXEC_OPERATION(bnzr, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BLEUR</name>
    <description>Unsigned branch-if-less-or-equal. Compares the first two operands, uses the third as PC relative branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(leu, IO(1), IO(2), cr);
       EXEC_OPERATION(bnzr, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>BGEUR</name>
    <description>Unsigned branch-if-greater-equal. Compares the first two operands, uses the third as PC relative branch target.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
    <in element-count="1" element-width="32" id="3" type="SIntWord"/>
    <trigger-semantics>
       SimValue cr;
       EXEC_OPERATION(geu, IO(1), IO(2), cr);
       EXEC_OPERATION(bnzr, cr, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>HWLOOP</name>
    <description>Hardware-loop instruction to iterate given number of instruction. Operand-1: Iteration count and Operand-2: Number of instructions.
          The instruction only guarantees the loop-iterations. Insturction cache behaviour (eg: Loop bufffers) are left to hardware to handle.
      </description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <side-effects/>
    <control-flow/>
    <in element-count="1" element-width="32" id="1" type="UIntWord"/>
    <in element-count="1" element-width="32" id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>STDOUT_RISCV</name>
    <description>Writes a single 8bit char to "standard output" which is platform dependent. Used for debugging. printf() uses this by default.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <in element-count="1" element-width="8" id="1" type="RawData"/>
    <in element-count="1" element-width="8" id="2" type="RawData"/>
    <out element-count="1" element-width="1" id="3" type="RawData"/>
  </operation>

</osal>
